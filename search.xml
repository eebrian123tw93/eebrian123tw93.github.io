<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>20240123小日常</title>
    <url>/posts/20240123163300-3f5d67a6.html</url>
    <content><![CDATA[<h1 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h1><p>今天真是個又累又氣的一天。花了4小時找一個差異。事情是這樣子的：這陣子在做<a href="/posts/20240122021600-ef8abaf3.html" title="使用WebCodecs API對H264解碼">使用WebCodecs API對H264解碼</a>，接下來換H265。經過了幾次測試都發現我的瀏覽器無法支援H265的解碼。於是我跑去問主管該如何處理，他給我了他的經驗，他的電腦竟然可以用Chrome播放H265&#x2F;MP4的格式。我請他將檔案給我，讓我跑跑看，結果我的也不行。我以為主管的電腦有比較好，結果問之下也沒有。<br> <span id="more"></span></p>
<p>就這樣我有來來回回在網路找資源，還下載了其他瀏覽器測試，還另外下載解碼包<a href="https://www.codecguide.com/download_kl.htm">K-Lite Codec Pack</a>，結論都是無法。這樣搞了大概3個小時，結果最後我發現，在一個網站上竟然說在Intel 6代以後的CPU都支援H265解碼。我想我的是Intel® Core™ i7-10700處理器應該早就支援了。於是我就去安裝我內顯的驅動，猜怎麼著，還是不行。原來我電腦上有一張獨顯，那張獨顯完全不支援H265。用測試軟體<a href="https://bluesky-soft.com/en/DXVAChecker.html">DXVAChecker</a>跑獨顯和內顯的解碼能力，我真的要罵出髒話，獨顯的解碼能力竟然低於內顯，而且是低很多的檔次。想說這顆爛獨顯到底有何用，只是單純讓我外接的嗎？還是來考驗我的除錯能力？</p>
<p>就這樣我用內顯重開電腦之後，H265&#x2F;MP4的影片就可以播放了。真的是讓我浪費了好多時間和精力啊啊啊啊！<br><img src="/images/20240124094118.png"><br>上面這張是獨顯 <code>AMD Radeon™ HD 7470</code><br>下面這張是<code>Intel® Core™ i7-10700</code> 內顯 <code>Intel® UHD Graphics 630</code><br><img src="/images/20240124094050.png"></p>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://www.codecguide.com/download_kl.htm">Download K-Lite Codec Pack</a></li>
<li><a href="https://bluesky-soft.com/en/DXVAChecker.html">DXVAChecker</a></li>
<li><a href="https://www.cnblogs.com/lidabo/p/16742377.html">HEVC 软硬件的支持</a></li>
<li><a href="https://blog.csdn.net/Dontla/article/details/132752490">解决chrome浏览器不能播放H265视频播放问题……</a></li>
</ul>
]]></content>
      <categories>
        <category>小日常</category>
      </categories>
      <tags>
        <tag>H265</tag>
      </tags>
  </entry>
  <entry>
    <title>20240319小日常</title>
    <url>/posts/20240319163300-5da60ff1.html</url>
    <content><![CDATA[<h1 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h1><p>這些天每天上班都處在一個迴圈的感覺，每解決完一個問題，就會有新的問題，最近的任務是要移植代碼到新的板子上，學到了很多像是 bikbake pkg_config ycoto….，蠻多點都是大概過一下，沒問題就往下…</p>
<p>有一個地方卡比較久就是要使用 adb root 的權限比較大，如果是用adb user 登入adb  然後再 su，雖然是root 但是權限還是有問題，像是要insmod 都說沒權限，氣鼠掉ㄟ<br> <span id="more"></span></p>
<p>再來就是 bitbake 裡面 <a href="https://blog.csdn.net/u014603518/article/details/127800875">FILES_${PN}</a> 會將檔案加入打包中，但要小心在do_rootfs會重複就會有問題每次在測試有沒有打包進去都要花超久時間驗證，因為一次都要20分鐘以上。</p>
<p>再來是bitbake 更改設定kernel ，因為預設kernel 沒有開IPC，多虧有<a href="https://www.youtube.com/watch?v=uErrAUtxgt4&list=PLwqS94HTEwpQmgL1UsSwNk_2tQdzq3eVJ&index=45&ab_channel=Tech-A-Byte">Yocto Tutorial - 28 Kernel Configuration using Config Fragments | diffconfig</a>，才能順利在板子上跨進程溝通。</p>
<p>在其中還有學到使用locate 指令用來快速尋找檔案，和find比起來，當要搜尋整台電腦時，會用 locate ，搜資較夾底下的內容時會用find。</p>
<p>再來是概念的問題，在送資料到其他地方處理時，最簡單的方法是複製，但這樣會造成cpu負擔，期待的方法是零複製，DMA(Direct Memory Access,直接存儲取訪問) , 只要配置好address ，讓另一個進程直接去讀取</p>
<p>雖然以前高中的時候，玩過android root，但是還是會有一堆坑要踩，還有很多需要學習，這些以後可以幫助我解決更多其他問題 。</p>
]]></content>
      <categories>
        <category>小日常</category>
      </categories>
      <tags>
        <tag>adb</tag>
        <tag>bitbake</tag>
        <tag>yocto</tag>
      </tags>
  </entry>
  <entry>
    <title>20240701小日常 1</title>
    <url>/posts/20240701082200-daad86cc.html</url>
    <content><![CDATA[<h1 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h1><p>從五月到七月上旬，陸陸續續推了大概43個 commmits，主要是在 WEB 新增功能 還有重構。<br>這大概是最近碰到最多的網頁的code的吧!!!</p>
<p>第一個功能就是將wfs.js換成用 jmuxer ，順便支援H265 功能，還有一不分是 wfs.js 已經被改的不成樣子了，但觀察到的是 這個套件將 websocket 連線 和 decode H264 的代碼耦合，維護性很低。<br>這邊遇到比較困難的事，串流過來的格式，瀏覽器不一定會支援，所以要去解析 I frame 裡面的NaLu資料 轉成像 <code>hev1.1.6.L123.B0</code> 的字串，詢問瀏覽器支不支援<code>window.MediaSource.isTypeSupported(codecString)</code>，感謝同事和主管的幫忙，因為中間還要去了解將 sps 欄位拉出來<br> <span id="more"></span><br> 推薦<a href="https://github.com/virinext/hevcesbrowser">hevcesbrowser</a>工具，可以解析H265裡面的 NALU 單元 </p>
<ul>
<li><a href="https://blog.csdn.net/lbc2100/article/details/79628380">h265 Nalu类型判断及 sps 数据解析</a></li>
<li><a href="https://www.cnblogs.com/hankgo/p/17239345.html">H.265编码协议—SPS语法解析</a></li>
</ul>
<p>發現js有地方是用到相同的code ，但是又各自寫各自的<br>就來學習 js 的封裝，將property function 封裝<br>一開始是用 class ，但發現<br>class 會出現雷點，<code>this</code> 可能拿到的不是指到物件，避免呼叫者的使用不當，最後用 Factory Method 進行封裝</p>
<ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10194639">Good Morning, JS (Day 9, ES6 Class 地雷)</a></li>
<li><a href="https://hackmd.io/@lunzaizai/ryVK_oUUt">[JavaScript] 建構子 &#x2F; 工廠函式（factory function）創造物件？</a></li>
</ul>
<p>未完下篇<a href="/posts/20240701092200-43a4d776.html" title="20240701小日常 2">20240701小日常 2</a></p>
]]></content>
      <categories>
        <category>小日常</category>
      </categories>
      <tags>
        <tag>H265</tag>
        <tag>FactoryMethod</tag>
        <tag>I幀</tag>
        <tag>javascript</tag>
        <tag>工廠函式</tag>
      </tags>
  </entry>
  <entry>
    <title>20240701小日常 2</title>
    <url>/posts/20240701092200-43a4d776.html</url>
    <content><![CDATA[<p>接續上篇<a href="/posts/20240701082200-daad86cc.html" title="20240701小日常 1">20240701小日常 1</a></p>
<h1 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h1><p>接下的功能是Camrea在瀏覽器要支援雙向對話的功能，這邊其實包含兩個功能要單獨看，一個是播放聲音，一個是錄音將音訊傳給Camrea，在看code的時候發現，哇!，都註解掉了，原來前人都鋪好錄了，打開不就好了，但是沒有向的這麼簡單。</p>
<p>接下就是遇到的問題，這是是用websocket做連線雙向溝通，在播放聲音功能的部分，出現類似心跳聲的聲音，到網路上搜尋到的代碼，寫發都差不多，幾乎都一樣，但是為甚麼會有問題，一開始以為是 過來的PCM格式設定不一樣，或者buffer被干擾， 或者 websocket在傳輸時，資料沒有完整，結果都不是，是因為每當websocket onMessage 收到資料就直接播放，但是每個buffer 只有 0.125 秒，api就 每0.125 秒 一直 start stop，我猜心跳聲就是一秒內 start stop 8次造成的，最後的解法是將 buffer Queue 起來 然後 merge 起來 ，累積1 秒再播放，心跳聲就解除了。<br> <span id="more"></span><br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">mergeBuffers</span> = (<span class="params">bufferList</span>) =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> totalLength = bufferList.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, buffer</span>) =&gt;</span> acc + buffer.<span class="property">length</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">const</span> mergedBuffer = audioContext.<span class="title function_">createBuffer</span>(<span class="number">1</span>, totalLength, audioContext.<span class="property">sampleRate</span>);</span><br><span class="line">	<span class="keyword">let</span> offset = <span class="number">0</span>;</span><br><span class="line">	bufferList.<span class="title function_">forEach</span>(<span class="function"><span class="params">buffer</span> =&gt;</span> &#123;</span><br><span class="line">		mergedBuffer.<span class="title function_">copyToChannel</span>(buffer.<span class="title function_">getChannelData</span>(<span class="number">0</span>), <span class="number">0</span>, offset);</span><br><span class="line">		offset += buffer.<span class="property">length</span>;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">return</span> mergedBuffer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source = audioContext.<span class="title function_">createBufferSource</span>();</span><br><span class="line">source.<span class="property">buffer</span> = buffer;</span><br><span class="line">source.<span class="title function_">connect</span>(audioContext.<span class="property">destination</span>);</span><br><span class="line">source.<span class="property">onended</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">	isPlaying = <span class="literal">false</span>;</span><br><span class="line">	<span class="title function_">playFromQueue</span>();</span><br><span class="line">&#125;;</span><br><span class="line">source.<span class="title function_">start</span>();</span><br></pre></td></tr></table></figure></p>
<p>再來就是錄音將音訊傳給Camrea，再chrome的政策裡面一定要https才能只用麥克風<br>但是有時候有想看封包，再啟動時，帶入參數可以跳過</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">google-chrome --unsafely-treat-insecure-origin-as-secure=<span class="string">&quot;http://example.com&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p><a href="https://stackoverflow.com/questions/46299723/navigator-mediadevices-getusermedia-with-http-server">navigator.mediaDevices.getUserMedia with http server</a></p>
</li>
<li><p><a href="https://blog.csdn.net/qq_33878858/article/details/114382864">新版chrome 解决在http协议下无法调用摄像头和麦克风的问题（不安全）</a><br>另一個問題是 前面建立 websocket 連線都正常，但在我要開啟麥克風傳資料回去的時候，不知為何會自動斷線，有時候是傳了6個Data出去，有時候是傳了10個Data，非常不固定，但是最後都一定會斷線，調查了一段時間，用wireshark攔封包發現不知為何 server 會 收到 0x80(關閉代碼) ，然後將連線關閉，但瀏覽器應該不會隨意傳送關閉代碼，而且websocket傳送的時候會將Data mask 起來，查了一下發現 server 的 那段接收 auduio 的 code ，已經過時，原本的server 會去處理websocket protocol 的流程(解包)，但是這段我發現還有經過主管的詢問，處理 websocket protocol 已經在 lighttp 處理完了<a href="https://redmine.lighttpd.net/projects/lighttpd/wiki/Mod_wstunnel">mod_wstunnel</a>，到後面就沒有 websocket 的 frame ，也不需要判斷是否收到(關閉代碼)，所以拔掉那段code，就正常了</p>
</li>
<li><p><a href="https://redmine.lighttpd.net/projects/lighttpd/wiki/Mod_wstunnel">mod_wstunnel</a>會處理掉websocket 封包 將解包後的 Data 往後送</p>
</li>
</ul>
<p>常常很需要了解，全部過程，甚至底層，才能解決問題</p>
<p>未完下篇<a href="/posts/20240701102200-34a3e7e0.html" title="20240701小日常 3">20240701小日常 3</a></p>
]]></content>
      <categories>
        <category>小日常</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>audio</tag>
        <tag>micphone</tag>
      </tags>
  </entry>
  <entry>
    <title>20240701小日常 3</title>
    <url>/posts/20240701102200-34a3e7e0.html</url>
    <content><![CDATA[<p>接續上篇<a href="/posts/20240701092200-43a4d776.html" title="20240701小日常 2">20240701小日常 2</a></p>
<h1 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h1><p>在實作新功能時，發現這裡的程式碼都放在一起，沒有封裝或這沒有歸類，程式碼已經到 7000 行<br>這是我無法接受的，聽說原本這個檔案有10000~20000 行，這個已經是拆過的檔案，原先的已經照<br>著頁面顯示拆成一塊一塊的 component，但是經過我的觀察，還是藕合很嚴重，多語系 , media player , datacenter,<br> <span id="more"></span><br> 都是通過這個檔案去拿，然後檔案call 過來，再從另一個檔案call 回來，非常混亂，，要查 commit log 會不知道 code 改過什麼，而且明顯違反 單一原則那個檔案做了太多的事了，跟同事討論之後，便開始動手</p>
<p><strong>針對下面幾點作重構</strong>:</p>
<ul>
<li>大功能的可以拆成單例 <a href="https://levelup.gitconnected.com/javascript-design-patterns-aa4adb7b85e6">Javascript Design Patterns</a>  LanguageHelper DataCenter</li>
<li>將類似的功能拆出來成另一個 js 檔 (播放H265 H264 MJPEG )</li>
<li>增加可讀性</li>
<li>多使用 js 原生 API 棄用 jquery 和 自寫的排序演算法</li>
<li>一個function 做的事盡量單一，而且不要去read, write 全域變數，參數盡量用帶的</li>
<li>盡量不要用callback，使用 Promise</li>
<li>盡可能簡單…..</li>
<li>eslintrc.json</li>
</ul>
<p><strong>終</strong>:<br>    程式碼從 7000行 降至 3250行 ，雖然將程式拆出去，但檔案隨之變多，需要用資料夾做分類，<br>    中間還有遇到相依問題，參考: <a href="https://juejin.cn/post/6970882760810430472">RequireJS的使用步骤</a>require.config(shim: {})，<br>    有時候會無法理解前人的寫法，但是也只能詢問其他同或者慢慢揣磨了，可能有時候求快，或者懶吧!!!!</p>
]]></content>
      <categories>
        <category>小日常</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>refactor</tag>
      </tags>
  </entry>
  <entry>
    <title>20250214小日常-WebSocket IDR Frame delay</title>
    <url>/posts/20250214102200-5e422532.html</url>
    <content><![CDATA[<p>今天在除錯時，發現有時兩路websocket LiveView 開下去，就造成卡頓，到websocket的流程一看原來裡面有一個機制，<br>是會去檢查當前拿到的Frame Number 和 encode 最新的 Frame Number ，如果差距太大（例如: 兩個fps之類的），<br>代表使用者看到的畫面是好幾秒前的，這時會再下一幀強制插 IDR  Frame ，讓使用者看到最新的，這個機制設計沒有什麼問題，<br> <span id="more"></span><br> 但今天遇到的websocket 是單線程，且如果 IDR  Frame 拿的比較慢，會造成大家都在拿 IDR  Frame，形成 hungry。</p>
<p>原本的解法是，多加一點條件限制拿 IDR  Frame 的條件</p>
<ol>
<li>如果當前是 IDR  Frame ，下一幀就不拿 IDR  Frame</li>
<li>大家在一秒內，總共只能一次 IDR  Frame，其餘的就忽略</li>
<li>拉大兩個 Frame Number 的距離 (3~4倍fps)</li>
</ol>
<p>再來就是不要 插 IDR  Frame 直接取最近的 I Frame</p>
<p>重點來了！！上面的解法都只是解決表面而已<br>感謝前輩的幫忙與教導 其實是要找到真正的根本原因 (Root Cause)</p>
<ol>
<li>是否是多線程干擾</li>
<li>打印出 Frame Number 和 拿 frame 的結果<br>最後排出多線程，並且打印打印出 Frame Number 和 拿 frame 的結果<br>發現拿 IDR  Frame 都拿超時，但這不應該，因為 IDR  Frame 速度應該都蠻快的<br>最後發現底層強制 拿 IDR  Frame的索引錯了，導致沒有人去拿 IDR  Frame，自然而然都超時，</li>
</ol>
<p>中間一度想往網路方向去解，回頭想想才兩路 websocket 根本不可以網路送不動，算一算根本還有很大的頻寬可以用。<br>下次如過要解這類問題還要是先搞懂，整體是單線程還是多線程，打印 Frame Number 和 thread Id 還有 result<br>相信會越解越快，更快找出根本原因 (Root Cause)。</p>
]]></content>
      <categories>
        <category>小日常</category>
      </categories>
      <tags>
        <tag>H265</tag>
        <tag>H264</tag>
        <tag>IDR幀</tag>
      </tags>
  </entry>
  <entry>
    <title>DMA (Direct Memory Access)</title>
    <url>/posts/20231118194800-e891e3a3.html</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p><img src="/images/20231119023846.png"><br>直接記憶體存取（Direct Memory Access，DMA） 獨立地直接讀寫系統記憶體，而不需中央處理器介入處理，減輕處理器負擔，減輕內核工作量</p>
<p>簡單來說，就是搬資料，不需要用到CPU的指令。換言之，搬資料時，CPU不用知道。要怎麼做可以確保搬的資料不會錯。</p>
<ol>
<li>要知道原始資料的位置。</li>
<li>要知道目地的位置。 <span id="more"></span></li>
<li>要知道要搬多少資料長度。</li>
</ol>
<h1 id="配置DMA-以SRAM到外部設備"><a href="#配置DMA-以SRAM到外部設備" class="headerlink" title="配置DMA(以SRAM到外部設備)"></a>配置DMA(以SRAM到外部設備)</h1><ul>
<li>從哪裡複製(要複製的地址) SRAM Address</li>
<li>複製的地址(複製目的地的地址) 外部設備 Address</li>
<li>DMA方向 從 SRAM 到 外部設備</li>
<li>傳輸資料大小</li>
<li>SRAM 地址自增 On or Off </li>
<li>外部設備 地址自增  On or Off</li>
</ul>
<h1 id="參考影片"><a href="#參考影片" class="headerlink" title="參考影片"></a>參考影片</h1><ul>
<li><a href="https://www.youtube.com/watch?v=2_X9qD12_pw">10行代码，就能让你真正理解DMA！你用的可能很少，但是在单片机中非常重要！</a></li>
</ul>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://sharing-icdesign-experience.blogspot.com/2014/05/dma.html">什麼是DMA ?</a></li>
<li><a href="https://blog.csdn.net/as480133937/article/details/104927922">【STM32】 DMA原理，步骤超细详解，一文看懂DMA</a></li>
</ul>
]]></content>
      <categories>
        <category>soc</category>
      </categories>
      <tags>
        <tag>DMA</tag>
      </tags>
  </entry>
  <entry>
    <title>H264基礎知識</title>
    <url>/posts/20240116080900-8a796e7c.html</url>
    <content><![CDATA[<h1 id="H264"><a href="#H264" class="headerlink" title="H264"></a>H264</h1><p>MPEG-4的⼀個組成部分–MPEG-4 Part 10，⼜叫Advanced Video Codec，因此常稱為MPEG-4 AVC或直接叫AVC</p>
<h1 id="I幀-B幀-P幀-IDR幀"><a href="#I幀-B幀-P幀-IDR幀" class="headerlink" title="I幀, B幀,P幀,IDR幀"></a>I幀, B幀,P幀,IDR幀</h1><p><img src="/images/20240116150548.png"></p>
<h2 id="I幀-關鍵幀"><a href="#I幀-關鍵幀" class="headerlink" title="I幀 關鍵幀"></a>I幀 關鍵幀</h2><h2 id="P幀-前向預測編碼幀"><a href="#P幀-前向預測編碼幀" class="headerlink" title="P幀 前向預測編碼幀"></a>P幀 前向預測編碼幀</h2><h2 id="B幀-雙向預測內插編碼幀"><a href="#B幀-雙向預測內插編碼幀" class="headerlink" title="B幀 雙向預測內插編碼幀"></a>B幀 雙向預測內插編碼幀</h2><h2 id="IDR幀-I-幀的一種-立即刷新"><a href="#IDR幀-I-幀的一種-立即刷新" class="headerlink" title="IDR幀  I 幀的一種 立即刷新"></a>IDR幀  I 幀的一種 立即刷新</h2><p>IDR 幀禁止後面的幀向自己前面的幀參照<br> <span id="more"></span></p>
<h2 id="GOP-兩個I幀之間的間隔"><a href="#GOP-兩個I幀之間的間隔" class="headerlink" title="GOP 兩個I幀之間的間隔"></a>GOP 兩個I幀之間的間隔</h2><p>完整編碼的幀叫 I幀，參考先前的 I 幀產生的只包含差異部分編碼的幀叫 P幀，還有一種參考前後的幀編碼的幀叫 B幀<br>H264採用的核心演算法是幀內壓縮和幀間壓縮，幀內壓縮是產生 I 幀的演算法，幀間壓縮是產生 B 幀和 P 幀的演算法</p>
<p>壓縮率 B幀 &gt; P幀 &gt; I幀<br>訊息量 I幀 &gt; P幀 &gt; B幀</p>
<p>幀特性看底下連結<br><a href="https://blog.csdn.net/qq_29350001/article/details/73770702">图像和流媒体 – I 帧,B帧,P帧,IDR帧的区别</a></p>
<h2 id="DTS-和-PTS"><a href="#DTS-和-PTS" class="headerlink" title="DTS 和 PTS"></a>DTS 和 PTS</h2><p>由于 B-帧需要未来的参考帧才能解码，于是便有了 DTS（Decode Timestamp，解码时间戳）和 PTS（Presentation Timestamp，显示时间戳）的概念。</p>
<p>编码器在编码时需要提供 DTS 和 PTS；而解码器在解码时会根据 DTS 顺序解码，再根据 PTS 顺序播放。当然，编码器是按照 DTS 顺序进行编码的，视频帧也是按照 DTS 顺序传输的。</p>
<p>以上述 GOP 结构图为例，PTS 顺序为图中的 1-9 顺序，对应的 DTS 顺序如下：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">     I B P B P B P B I</span><br><span class="line">PTS: 1 2 3 4 5 6 7 8 9</span><br><span class="line">DTS: 1 3 2 5 4 7 6 9 8</span><br></pre></td></tr></table></figure>
<p>即在解码 B-帧之前，先根据 DTS 解码它需要的所有参考帧，再根据 PTS 组帧播放。不过我们在实时通话领域通常不使用 B-帧，所以 DTS 通常等于 PTS。</p>
<h1 id="NALU-Network-Abstract-Layer-Unit"><a href="#NALU-Network-Abstract-Layer-Unit" class="headerlink" title="NALU (Network Abstract Layer Unit)"></a>NALU (Network Abstract Layer Unit)</h1><p><u><strong>H264編碼資料儲存或傳輸的基本單元</strong></u><br> 一般來說 前兩個是 SPS PPS 再來是IDR幀 再來是 P幀或B幀</p>
<ul>
<li>SPS(Sequence Parameter Sets)：序列參數集，保存了一組編碼視訊序列(Coded video sequence)的全域參數。 </li>
<li>PPS(Picture Parameter Set)：影像參數集，對應的是一個序列中某一副影像或某幾副影像的參數。 </li>
<li>SEI(Supplemental enhancement information)：附加增強訊息，包含了視訊畫面定時等信息，一般放在主編碼影像資料之前，在某些應用中，它可以被省略掉。</li>
<li>IDR(Instantaneous Decoding Refresh)：即時解碼刷新。</li>
<li>HRD(Hypothetical Reference Decoder)：假想碼流調度器<br> 。<br>如何拆解H264數據流中的NALU<br>每個NALU中，是以0x00000001 或 0x000001 當作開始標記，開始標記的後面一個字節 和 0x1f 做 &amp; 的運算得出 NALU 類型<br><img src="/images/20240116154054.png"><br>舉例: 上面有4個NALU 開頭都為 0x000001 後面一格字節就是算出NALU類型的因子<br>NALU(nal_unit_type) 類型 推導</li>
<li>0x06 &amp; 0x1f &#x3D; 6 (SEI)</li>
<li>0x67 &amp; 0x1f &#x3D; 7 (SPS)</li>
<li>0x68 &amp; 0x1f &#x3D; 8 (PPS)</li>
<li>0x65 &amp; 0x1f &#x3D; 5 (IDR)<br><img src="/images/20240116154827.png"></li>
<li><a href="https://zhuanlan.zhihu.com/p/409527359">H264之NALU解析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/71928833">视频和视频帧：H264编码格式整理</a></li>
</ul>
<h1 id="H264有兩種封裝"><a href="#H264有兩種封裝" class="headerlink" title="H264有兩種封裝"></a>H264有兩種封裝</h1><ul>
<li><h4 id="AnnexB格式"><a href="#AnnexB格式" class="headerlink" title="AnnexB格式"></a>AnnexB格式</h4>  这种格式比较常见，也就是我们熟悉的每个帧前面都有<code>0x00 00 00 01</code>或者<code>0x00 00 01</code>作为起始码。<br>  h264文件就是采用的这种格式，每个帧前面都要有个起始码。<br>  SPS PPS等也作为一类NALU存储在这个码流中，一般在码流最前面。也就是说这种格式包含VCL 和 非VCL 类型的NALU。 </li>
<li><strong>AVCC格式</strong><br>  这种模式也叫AVC1格式，没有起始码，每个帧最前面几个字节（通常4字节）是帧长度。<br>  这里的NALU一般没有SPS PPS等参数信息，参数信息属于额外数据extradata存在其他地方。<br>  比如ffmpeg中解析mp4文件后sps pps存在streams[index]-&gt;codecpar-&gt;extradata;中。<br>  也就是说这种码流通常只包含VCL类型NALU。<br>  这些extradata通常有如下格式（可以根据这个规则ffmpeg解析mp4文件的SPS和PPS）</li>
</ul>
<h1 id="H264-编码-—profile-和-level"><a href="#H264-编码-—profile-和-level" class="headerlink" title="# H264 编码 —profile 和 level"></a># H264 编码 —profile 和 level</h1><ul>
<li>baseline profile：基本画质。支持 I&#x2F;P 帧，只支持无交错（Progressive）和 CAVLC</li>
<li>extended profile：进阶画质。支持 I&#x2F;P&#x2F;B&#x2F;SP&#x2F;SI 帧，只支持无交错（Progressive）和 CAVLC；(用的少)</li>
<li>main profile：主流画质。提供 I&#x2F;P&#x2F;B 帧，支持无交错（Progressive）和交错（Interlaced），也支持 CAVLC 和 CABAC 的支持</li>
<li>high profile：高级画质。在 main profile 的基础上增加了 8x8 内部预测、自定义量化、无损视频编码和更多的 YUV 格式<br><a href="https://winddoing.github.io/post/e114a1a8.html">H264 编码 —profile 和 level</a></li>
</ul>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://blog.piasy.com/2017/09/22/I-Need-Know-About-H264/index.html">我需要知道：H.264</a></li>
</ul>
]]></content>
      <categories>
        <category>h264</category>
      </categories>
      <tags>
        <tag>I幀</tag>
        <tag>H264</tag>
        <tag>IDR幀</tag>
        <tag>B幀</tag>
        <tag>GOP</tag>
        <tag>NALU</tag>
        <tag>P幀</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World 使用Github pages 靜態網站</title>
    <url>/posts/20230505020300-526efc4a.html</url>
    <content><![CDATA[<p>建立一個新的倉庫 命名為 <strong>帳戶名稱.github.io</strong><br><img src="/images/image.png" alt="建立一個新的倉庫"></p>
<p>好了之後在自己的電腦上clone專案下來</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:eebrian123tw60/eebrian123tw60.github.io.git</span><br></pre></td></tr></table></figure>
<p>進入專案 新增一個index.html 內容是Hello World</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd eebrian123tw60.github.io</span><br><span class="line">echo &quot;Hello World&quot; &gt; index.html</span><br></pre></td></tr></table></figure>
<p>推到遠端的倉庫</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add --all</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<p>等待幾分鐘 訪問<a href="https://eebrian123tw60.github.io/">https://eebrian123tw60.github.io/</a><br><img src="/images/image2.png"><br>結果就出來拉！！</p>
<hr>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><ul>
<li><a href="https://pages.github.com/">https://pages.github.com/</a></li>
<li><a href="https://medium.com/%E9%80%B2%E6%93%8A%E7%9A%84-git-git-git/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B-%E7%94%A8github-pages-%E4%B8%8A%E5%82%B3%E9%9D%9C%E6%85%8B%E7%B6%B2%E7%AB%99-fa2ae83e6276">從零開始: 用github pages 上傳靜態網站</a></li>
</ul>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>ICE連線排序規則</title>
    <url>/posts/20241224070200-f38f09a7.html</url>
    <content><![CDATA[<h1 id="Candiates-Examples"><a href="#Candiates-Examples" class="headerlink" title="Candiates Examples"></a>Candiates Examples</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 组标识为 udpcandidate，使用 RTP 协议传输数据，基于 UDP 协议，</span><br><span class="line">// 优先级为 1076558079，地址为 172.217.27.142:31269，类型为 host；</span><br><span class="line">// host 表示客户端与该 candidate 位于同一个 LAN 或者 NAT，因此可以直连</span><br><span class="line">a=candidate:udpcandidate 1 udp 1076558079 172.217.27.142 31269 typ host</span><br><span class="line"></span><br><span class="line">// 组标识为 tcpcandidate，使用 RTP 协议传输数据，基于 TCP 协议，</span><br><span class="line">// 优先级为 1076302079，地址为 172.217.27.142:31368，类型为 host；</span><br><span class="line">// passive（被动）这个概念仅属于 TCP candidates，</span><br><span class="line">// 表示该 candidate 不会主动发起连接，只能被动等待连接</span><br><span class="line">a=candidate:tcpcandidate 1 tcp 1076302079 172.217.27.142 31368 typ host tcptype passive</span><br></pre></td></tr></table></figure>
<h1 id="候选对（Candidate-Pair）"><a href="#候选对（Candidate-Pair）" class="headerlink" title="候选对（Candidate Pair）"></a>候选对（Candidate Pair）</h1><h3 id="候选列表"><a href="#候选列表" class="headerlink" title="候选列表"></a><strong>候选列表</strong></h3><p>在 WebRTC 的 ICE 流程中，通信双方都会生成各自的 <strong>候选列表</strong>：</p>
<ol>
<li><strong>本地候选列表</strong>：由本地网络接口发现的候选（包括 Host、Server Reflexive、Relayed 等）。 <span id="more"></span></li>
<li><strong>远程候选列表</strong>：从对等方通过信令协议（如 SDP）传递过来的候选列表。</li>
</ol>
<h3 id="候选对的定义"><a href="#候选对的定义" class="headerlink" title="候选对的定义"></a><strong>候选对的定义</strong></h3><p>候选对是本地候选和远程候选的组合。<br>假设：</p>
<ul>
<li>本地候选列表有 3 个候选：<code>A1</code>, <code>A2</code>, <code>A3</code>。</li>
<li>远程候选列表有 2 个候选：<code>B1</code>, <code>B2</code>。<br>候选对的组合方式是<strong>笛卡尔积</strong>，即将每个本地候选与每个远程候选配对：</li>
<li>候选对 &#x3D; {<code>(A1, B1)</code>, <code>(A1, B2)</code>, <code>(A2, B1)</code>, <code>(A2, B2)</code>, <code>(A3, B1)</code>, <code>(A3, B2)</code>}</li>
</ul>
<h3 id="候选对的用途"><a href="#候选对的用途" class="headerlink" title="候选对的用途"></a><strong>候选对的用途</strong></h3><p>候选对是用于连接性检查的单位。ICE 通过尝试不同的候选对来找出最佳的连接路径。</p>
<ol>
<li><strong>连接测试</strong>：对于每个候选对，ICE 会发送 STUN 请求来检查它们是否能够成功建立连接。<ul>
<li>如果候选对能通过 STUN 验证，它会被标记为 “有效候选对”。</li>
<li>最终选择一个优先级最高的有效候选对作为实际的连接路径。</li>
</ul>
</li>
<li><strong>打洞（NAT Traversal）</strong>：候选对的连接性检查也会触发 NAT 打洞，帮助双方建立直接连接。</li>
</ol>
<h1 id="拉程式碼參考"><a href="#拉程式碼參考" class="headerlink" title="拉程式碼參考"></a>拉程式碼參考<a href="/posts/20230806170400-af856b41.html" title="webrtc">webrtc</a></h1><h1 id="p2p-x2F-base-x2F-basic-ice-controller-cc-–-gt-SortAndSwitchConnection"><a href="#p2p-x2F-base-x2F-basic-ice-controller-cc-–-gt-SortAndSwitchConnection" class="headerlink" title="p2p&#x2F;base&#x2F;basic_ice_controller.cc –&gt; SortAndSwitchConnection"></a>p2p&#x2F;base&#x2F;basic_ice_controller.cc –&gt; SortAndSwitchConnection</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">IceControllerInterface::SwitchResult</span></span><br><span class="line"><span class="function"><span class="title">BasicIceController::SortAndSwitchConnection</span><span class="params">(IceSwitchReason reason)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Find the best alternative connection by sorting.  It is important to note</span></span><br><span class="line">  <span class="comment">// that amongst equal preference, writable connections, this will choose the</span></span><br><span class="line">  <span class="comment">// one whose estimated latency is lowest.  So it is the only one that we</span></span><br><span class="line">  <span class="comment">// need to consider switching to.</span></span><br><span class="line">  <span class="comment">// TODO(honghaiz): Don&#x27;t sort;  Just use std::max_element in the right places.</span></span><br><span class="line">  absl::<span class="built_in">c_stable_sort</span>(</span><br><span class="line">      connections_, [<span class="keyword">this</span>](<span class="type">const</span> Connection* a, <span class="type">const</span> Connection* b) &#123;</span><br><span class="line">        <span class="type">int</span> cmp = <span class="built_in">CompareConnections</span>(a, b, std::<span class="literal">nullopt</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (cmp != <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> cmp &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Otherwise, sort based on latency estimate.</span></span><br><span class="line">        <span class="keyword">return</span> a-&gt;<span class="built_in">rtt</span>() &lt; b-&gt;<span class="built_in">rtt</span>();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">RTC_LOG</span>(LS_VERBOSE) &lt;&lt; <span class="string">&quot;Sorting &quot;</span> &lt;&lt; connections_.<span class="built_in">size</span>()</span><br><span class="line">                      &lt;&lt; <span class="string">&quot; available connections due to: &quot;</span></span><br><span class="line">                      &lt;&lt; <span class="built_in">IceSwitchReasonToString</span>(reason);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; connections_.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="built_in">RTC_LOG</span>(LS_VERBOSE) &lt;&lt; connections_[i]-&gt;<span class="built_in">ToString</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> Connection* top_connection =</span><br><span class="line">      (!connections_.<span class="built_in">empty</span>()) ? connections_[<span class="number">0</span>] : <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ShouldSwitchConnection</span>(reason, top_connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c_stable_sort 將 connections_ 做排序 ，排序完後拿出第一個 connection 在呼叫 ShouldSwitchConnection<br>c_stable_sort 裡面使用類似lambda用法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cmp = <span class="built_in">CompareConnections</span>(a, b, std::<span class="literal">nullopt</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (cmp != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> cmp &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Otherwise, sort based on latency estimate.</span></span><br><span class="line"><span class="keyword">return</span> a-&gt;<span class="built_in">rtt</span>() &lt; b-&gt;<span class="built_in">rtt</span>();</span><br></pre></td></tr></table></figure>
<p>先去 CompareConnections 排序<br>如果沒有比較出來就是用 rtt &lt;同一個封包來回時間（Round-Trip Time）&gt; 做比較</p>
<h2 id="CompareConnections"><a href="#CompareConnections" class="headerlink" title="CompareConnections"></a>CompareConnections</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BasicIceController::CompareConnections</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Connection* a,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Connection* b,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::optional&lt;<span class="type">int64_t</span>&gt; receiving_unchanged_threshold,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span>* missed_receiving_unchanged_threshold)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="built_in">RTC_CHECK</span>(a != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">RTC_CHECK</span>(b != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We prefer to switch to a writable and receiving connection over a</span></span><br><span class="line">  <span class="comment">// non-writable or non-receiving connection, even if the latter has</span></span><br><span class="line">  <span class="comment">// been nominated by the controlling side.</span></span><br><span class="line">  <span class="type">int</span> state_cmp = <span class="built_in">CompareConnectionStates</span>(a, b, receiving_unchanged_threshold,</span><br><span class="line">                                          missed_receiving_unchanged_threshold);</span><br><span class="line">  <span class="keyword">if</span> (state_cmp != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> state_cmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ice_role_func_</span>() == ICEROLE_CONTROLLED) &#123;</span><br><span class="line">    <span class="comment">// Compare the connections based on the nomination states and the last data</span></span><br><span class="line">    <span class="comment">// received time if this is on the controlled side.</span></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;<span class="built_in">remote_nomination</span>() &gt; b-&gt;<span class="built_in">remote_nomination</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> a_is_better;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;<span class="built_in">remote_nomination</span>() &lt; b-&gt;<span class="built_in">remote_nomination</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> b_is_better;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a-&gt;<span class="built_in">last_data_received</span>() &gt; b-&gt;<span class="built_in">last_data_received</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> a_is_better;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;<span class="built_in">last_data_received</span>() &lt; b-&gt;<span class="built_in">last_data_received</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> b_is_better;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Compare the network cost and priority.</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">CompareConnectionCandidates</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><a href="#CompareConnectionStates-%E6%A0%B9%E6%93%9A%E7%8B%80%E6%85%8B">CompareConnectionStates 根據狀態</a></li>
<li>remote_nomination (如是受控端)推薦值</li>
<li>last_data_received (如是受控端)上次接收數據時間戳</li>
<li><a href="#CompareConnectionCandidates-%E7%B6%B2%E8%B7%AF%E7%92%B0%E5%A2%83">CompareConnectionCandidates 網路環境</a></li>
</ol>
<h3 id="CompareConnectionStates-根據狀態"><a href="#CompareConnectionStates-根據狀態" class="headerlink" title="CompareConnectionStates 根據狀態"></a>CompareConnectionStates 根據狀態</h3><ol>
<li>是否可寫</li>
<li>是否可收</li>
<li>是否連接</li>
</ol>
<h3 id="CompareConnectionCandidates-網路環境"><a href="#CompareConnectionCandidates-網路環境" class="headerlink" title="CompareConnectionCandidates 網路環境"></a>CompareConnectionCandidates 網路環境</h3><ol>
<li><a href="#%E5%84%AA%E5%85%88%E7%B4%9A">優先級</a></li>
<li>更新代數</li>
<li>是否被修剪</li>
</ol>
<h4 id="優先級"><a href="#優先級" class="headerlink" title="優先級"></a>優先級</h4><p>WebRTC 会创建一个候选对（Candidate Pair）的检查列表，用于连接性检查。候选对的排序遵循以下规则：</p>
<h5 id="候选对优先级计算"><a href="#候选对优先级计算" class="headerlink" title="候选对优先级计算"></a>候选对优先级计算</h5><p>候选对优先级&#x3D;2^32×min(本地优先级,远程优先级)+2×max(本地优先级,远程优先级)+(本地优先级&gt;远程优先级?1:0)<br>參考p2p&#x2F;base&#x2F;connection.cc  Connection::priority()</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><h2 id="比較先後順序1-States-狀態-1-是否可寫-2-是否可收-3-是否連接2-remote-nomination-如是受控端-推薦值3-last-data-received-如是受控端-上次接收數據時間戳4-Candidates-網路環境-1-網路類型-2-優先級-3-更新代數-4-是否被修剪5-rtt-來回時間-參考-webrtc-ICE穿透连接排序算法详解-ICE-连接排序规则"><a href="#比較先後順序1-States-狀態-1-是否可寫-2-是否可收-3-是否連接2-remote-nomination-如是受控端-推薦值3-last-data-received-如是受控端-上次接收數據時間戳4-Candidates-網路環境-1-網路類型-2-優先級-3-更新代數-4-是否被修剪5-rtt-來回時間-參考-webrtc-ICE穿透连接排序算法详解-ICE-连接排序规则" class="headerlink" title="比較先後順序1. States 狀態    1. 是否可寫    2. 是否可收    3. 是否連接2. remote_nomination (如是受控端)推薦值3. last_data_received (如是受控端)上次接收數據時間戳4. Candidates 網路環境    1. 網路類型    2. 優先級    3. 更新代數    4. 是否被修剪5. rtt 來回時間# 參考- webrtc ICE穿透连接排序算法详解- ICE 连接排序规则"></a>比較先後順序<br>1. States 狀態<br>    1. 是否可寫<br>    2. 是否可收<br>    3. 是否連接<br>2. remote_nomination (如是受控端)推薦值<br>3. last_data_received (如是受控端)上次接收數據時間戳<br>4. Candidates 網路環境<br>    1. 網路類型<br>    2. 優先級<br>    3. 更新代數<br>    4. 是否被修剪<br>5. rtt 來回時間<br># 參考<br>- <a href="https://blog.csdn.net/breezeewu/article/details/142210879">webrtc ICE穿透连接排序算法详解</a><br>- <a href="https://webrtc.mthli.com/connection/ice-connection-sorting/#compareconnectionstates">ICE 连接排序规则</a></h2>]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>ICE Interactive Connectivity Establishment，交互式连接建立</title>
    <url>/posts/20241223083000-58bf8773.html</url>
    <content><![CDATA[<p><strong>ICE（Interactive Connectivity Establishment，交互式连接建立）</strong> 是一種協議框架，旨在幫助網絡應用程式在 NAT（網絡地址轉換）和防火牆環境下進行點對點（P2P）連接。ICE 綜合了多種 NAT 穿越技術，包括 STUN 和 TURN，用於建立可靠的通信通道。<br><img src="/images/20241223152120.png"><br><strong>STUN&#x2F;TURN+NAT穿越流&#x3D;ICE流程</strong><br> <span id="more"></span><br> ICE 是框架，STUN 和 TURN 是技術支持。</p>
<p>ICE用于NAT穿透，确定媒体流传输地址。这是音视频互通的第一步。包括如下四个流程</p>
<ol>
<li>收集候选地址</li>
<li>产生offer&#x2F;answer sdp，将候选地址携带在sdp中(通过Signal Server单独传输)</li>
<li>通过sdp中携带的候选者地址进行连通性测试<br>三个步骤是串行的，完成上一步骤才进行下一步</li>
</ol>
<h4 id="收集候选地址-Candiate"><a href="#收集候选地址-Candiate" class="headerlink" title="收集候选地址(Candiate)"></a>收集候选地址(Candiate)</h4><p>互通的两端所在的网络拓扑可能包括如下几种：</p>
<ol>
<li>在内网中(同一网段，或是跨网段)，通过内网地址互通</li>
<li>在NAT之后，通过本机NAT映射后的外网的IP和Port互通</li>
<li>需要通过relay服务器来互通</li>
</ol>
<p>所以收集地址时，分别对应三种类型的Candiate地址</p>
<ul>
<li>host 类型,即本机内网的 IP 和端口</li>
<li>srflx 类型,即本机 NAT 映射后的外网的 IP 和端口</li>
<li>relay 类型,即中继服务器的 IP 和端口</li>
</ul>
<p>3种类型的Candiate优先级依次是host,srflx,relay。按这种优先级进行连通测试。</p>
<h4 id="ICE流程"><a href="#ICE流程" class="headerlink" title="ICE流程"></a>ICE流程</h4><p><img src="/images/20241223152415.png"><br>1.收集candidates</p>
<ul>
<li>获取本机host address</li>
<li>从STUN服务器获取srvflx address</li>
<li>从TURN服务器获取relay address<br>2.交换candidates 发起offer的一方称为主叫方，Web A为主叫方。在A获取到candidates后，会在offer携带。被叫方Web B收到offer，开始收集candiates，收集完后，在answer消息中携带。(sdp中的<code>a=candidate</code>属性行携带本端的candidates地址)<br>3.按优先级进行连通检查</li>
</ul>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><strong>核心概念</strong></h3><ol>
<li><strong>目標：</strong><ul>
<li>促進點對點通信，即使通信雙方在不同的網絡環境（如 NAT 背後）中。</li>
</ul>
</li>
<li><strong>主要任務：</strong><ul>
<li>探測雙方的網絡可達性。</li>
<li>尋找最佳的網絡路徑。</li>
<li>處理候選連接，最終確定最有效的通信方式。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="ICE-的組成部分"><a href="#ICE-的組成部分" class="headerlink" title="ICE 的組成部分"></a><strong>ICE 的組成部分</strong></h3><ol>
<li><strong>候選（Candidates）：</strong><ul>
<li>ICE 嘗試多種方式來建立通信，並將每種方式表示為一個「候選地址」。</li>
<li><strong>候選類型：</strong><ul>
<li><strong>主機候選（Host Candidate）：</strong> 本地網絡接口的地址。</li>
<li><strong>反射候選（Server Reflexive Candidate）：</strong> 通過 STUN 服務器獲得的公共 IP 和端口。</li>
<li><strong>中繼候選（Relay Candidate）：</strong> 通過 TURN 服務器中繼流量的地址。</li>
</ul>
</li>
</ul>
</li>
<li><strong>STUN（Session Traversal Utilities for NAT）：</strong><ul>
<li>幫助獲取公共 IP 和端口。</li>
<li>用於檢測候選地址的可達性。</li>
</ul>
</li>
<li><strong>TURN（Traversal Using Relays around NAT）：</strong><ul>
<li>提供中繼服務器，以確保在嚴格 NAT 或防火牆環境中也能建立連接。</li>
</ul>
</li>
<li><strong>優先級排序：</strong><ul>
<li>每個候選地址根據特定算法分配優先級，確保選擇性能最佳的連接。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="ICE-的工作流程"><a href="#ICE-的工作流程" class="headerlink" title="ICE 的工作流程"></a><strong>ICE 的工作流程</strong></h3><ol>
<li><strong>候選地址收集（Gathering Candidates）：</strong><ul>
<li>雙方應用程序通過主機地址、STUN、TURN 等方式獲取一組候選地址。</li>
</ul>
</li>
<li><strong>候選地址交換（Exchanging Candidates）：</strong><ul>
<li>雙方通過信令（如 SIP 或 WebRTC 的 SDP）交換候選地址。</li>
</ul>
</li>
<li><strong>連接檢測（Connectivity Checks）：</strong><ul>
<li>使用 STUN 請求測試候選地址的可達性。</li>
</ul>
</li>
<li><strong>選擇最佳連接（Candidate Pair Selection）：</strong><ul>
<li>基於檢測結果和優先級，選擇一對候選地址作為最終通信通道。</li>
</ul>
</li>
<li><strong>連接建立（Establish Connection）：</strong><ul>
<li>通過選定的候選對進行數據交換。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="應用場景"><a href="#應用場景" class="headerlink" title="應用場景"></a><strong>應用場景</strong></h3><ol>
<li><p><strong>WebRTC：</strong></p>
<ul>
<li>ICE 是 WebRTC 實現點對點音視頻通信的基礎。</li>
</ul>
</li>
<li><p><strong>VoIP：</strong></p>
<ul>
<li>ICE 支持 SIP 協議進行語音通信。</li>
</ul>
</li>
<li><p><strong>點對點文件傳輸：</strong></p>
<ul>
<li>在 NAT 和防火牆環境下提供穩定的文件共享。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="ICE-與-STUN、TURN-的關係"><a href="#ICE-與-STUN、TURN-的關係" class="headerlink" title="ICE 與 STUN、TURN 的關係"></a><strong>ICE 與 STUN、TURN 的關係</strong></h3><ul>
<li><strong>ICE 是框架，STUN 和 TURN 是技術支持。</strong><ul>
<li>STUN 和 TURN 負責獲取候選地址和中繼流量。</li>
<li>ICE 組織候選地址的收集、交換和選擇，並進行連接檢測。</li>
</ul>
</li>
</ul>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://juejin.cn/post/7131010868115931143">浅述webrtc中的ICE流程</a></li>
<li></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>IIC I2C （Inter-Integrated Circuit）</title>
    <url>/posts/20231118183800-d71a458d.html</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p><img src="/images/20231119013103.png"><br>I2C(IIC)唸做I-square-C 属于两线式串行总线，由飞利浦公司开发用于微控制器(MCU)和外围设备(从设备)进行通信的一种总线，属于一主多从(一个主设备(Master)，多个从设备(Slave))的总线结构，总线上的每个设备都有一个特定的设备地址，以区分同一I2C总线上的其他设备。</p>
<p>半雙工、同步、串行傳輸，物理上只有兩根線（SDA&#x2F;SCL）；傳輸數據必須8位8位的傳輸<br> <span id="more"></span></p>
<p>物理I2C接口有<strong>两根双向线</strong>， <strong>串行时钟线（SCL）和串行数据线（SDA）</strong> 组成，可用于发送和接收数据，但是通信都是由主设备发起，从设备被动响应，实现数据的传输。</p>
<h1 id="I2C主设备与从设备的一般通信过程"><a href="#I2C主设备与从设备的一般通信过程" class="headerlink" title="I2C主设备与从设备的一般通信过程"></a>I2C主设备与从设备的一般通信过程</h1><h2 id="起始位-Start-condition-停止位-Stop-condition"><a href="#起始位-Start-condition-停止位-Stop-condition" class="headerlink" title="起始位 Start condition 停止位 Stop condition"></a>起始位 Start condition 停止位 Stop condition</h2><p><img src="/images/20231119013140.png"></p>
<ul>
<li>Start condition: SCL&#x3D; high + SDA falling (SDA由高到低跳變)</li>
<li>Stop condition: SCL&#x3D;high + SDA raising (SDA由低到高跳變)</li>
</ul>
<h2 id="邏輯數據"><a href="#邏輯數據" class="headerlink" title="邏輯數據"></a>邏輯數據</h2><p><img src="/images/20231119013159.png"><br>SCL為High採集SDA數據<br><img src="/images/20231119013218.png"><br>表示1010000  </p>
<h2 id="一-主设备给从设备发送-x2F-写入数据："><a href="#一-主设备给从设备发送-x2F-写入数据：" class="headerlink" title="一. 主设备给从设备发送&#x2F;写入数据："></a>一. 主设备给从设备发送&#x2F;写入数据：</h2><p><img src="/images/20231119013233.png"></p>
<ol>
<li>主设备发送起始（START）信号(1 bit)</li>
<li>主设备发送设备地址到从设备(7&#x2F;8bit) + 寫(1 bit)</li>
<li>等待从设备响应(ACK)(1 bit)</li>
<li>主设备发送数据到从设备，一般发送的每个字节数(8bit)据后会跟着等待接收来自从设备的响应(ACK)(1 bit)</li>
<li>数据发送完毕，主设备发送停止(STOP)信号终止传输(1 bit)</li>
</ol>
<h2 id="二-主设备从从设备接收-x2F-读取数据"><a href="#二-主设备从从设备接收-x2F-读取数据" class="headerlink" title="二. 主设备从从设备接收&#x2F;读取数据"></a>二. 主设备从从设备接收&#x2F;读取数据</h2><p><img src="/images/20231119013244.png"></p>
<ol>
<li>设备发送起始（START）信号(1 bit)</li>
<li>主设备发送设备地址到从设备(7&#x2F;8bit) + 讀(1 bit)</li>
<li>等待从设备响应(ACK)(1 bit)</li>
<li>主设备接收来自从设备的数据，一般接收的每个字节(8bit)数据后会跟着向从设备发送一个响应(ACK)(1 bit)</li>
<li>一般接收到最后一个数据后会发送一个无效响应(NACK)，然后主设备发送停止(STOP)信号终止传输(1 bit)</li>
</ol>
<h2 id="三-讀寫數據幀"><a href="#三-讀寫數據幀" class="headerlink" title="三. 讀寫數據幀"></a>三. 讀寫數據幀</h2><p><img src="/images/20231119013257.png"></p>
<h1 id="參考影片"><a href="#參考影片" class="headerlink" title="參考影片"></a>參考影片</h1><ul>
<li><a href="https://www.youtube.com/watch?v=u62_Rjd5oMY">4分钟看懂！I2C通讯协议 最简单的总线通讯！</a></li>
<li><a href="https://www.youtube.com/watch?v=oPrfi_HCtjY">I²C通訊格式介紹</a></li>
<li><a href="https://www.youtube.com/watch?v=FamlCPP2J4o">11 IIC总线原理轻松明白</a></li>
</ul>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/503219395">IIC通信协议，搞懂这篇就够了</a></li>
<li><a href="https://www.strongpilab.com/i2c-introduction/">I2C-協定用法原理簡介-晶片溝通的橋樑</a></li>
<li><a href="https://medium.com/weiting-tw/%E6%8A%80%E8%A1%93%E7%AD%86%E8%A8%98-i2c%E9%80%9A%E8%A8%8A%E5%8D%94%E5%AE%9A%E6%93%8D%E4%BD%9C-36d4dad0c9b3">[技術筆記] I2C通訊協定操作</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/575318033">《Linux驱动：I2C驱动看这一篇就够了》</a></li>
</ul>
]]></content>
      <categories>
        <category>soc</category>
      </categories>
      <tags>
        <tag>I2C</tag>
        <tag>IIC</tag>
      </tags>
  </entry>
  <entry>
    <title>LDAP</title>
    <url>/posts/20240416074500-51c3235.html</url>
    <content><![CDATA[<h1 id="LDAP"><a href="#LDAP" class="headerlink" title="LDAP"></a>LDAP</h1><p>LDAP 為身份識別伺服器與內部檔案系統伺服器<br>其他服務如(gitlab、ipcamera、Samba….) 可以做綁定，<br>透過LDAP server 做驗證，將帳號密碼做整合</p>
<p><img src="/images/20240416160514.png"><br>在驗證時，服務會向LDAP做驗證，權限控制還使由服務設定，<br>LDAP server 只會存資料而已<br><img src="/images/20240416160738.png"><br> <span id="more"></span><br> 比如在ipcamera網頁登入的是一般操作者，LDAP 指會存這個這個user的等級<br>ipcamera 拿到這個user 的等級，回應相對應的權限服務 </p>
<h1 id="系統說明"><a href="#系統說明" class="headerlink" title="系統說明"></a>系統說明</h1><p>LDAP 基本上就是個樹狀目錄系統，可以根據需求增加節點，例如公司叫「example」，下面有兩個部門人資「People」及IT「Servers」，人資下面有個員工，如下圖示意：<br><img src="/images/20240416161136.png"><br>值得注意的是，LDAP表示方式<strong>都是由小到大</strong>，下面登入的帳號，就是先說他是誰，後面才描述其他屬性。</p>
<h1 id="openldap-phpldapadmin"><a href="#openldap-phpldapadmin" class="headerlink" title="openldap + phpldapadmin"></a>openldap + phpldapadmin</h1><h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker_compose.yml"></a>docker_compose.yml</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">openldap:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">openldap</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">osixia/openldap:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8389:389&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8636:636&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/ldap/backup:/data/backup</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/ldap/data:/var/lib/openldap</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/ldap/config:/etc/openldap/slapd.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">~/ldap/certs:/assets/slapd/certs</span></span><br><span class="line">    <span class="attr">command:</span> [<span class="string">--copy-service</span>,  <span class="string">--loglevel</span>, <span class="string">debug</span>]</span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">LDAP_DOMAIN=ipcamera.com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">LDAP_BASE_DN=dc=ipcamera,dc=com</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">LDAP_ADMIN_PASSWORD=admin</span></span><br><span class="line">  <span class="attr">phpldapadmin:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">phpldapadmin</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">osixia/phpldapadmin:latest</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8081:80&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PHPLDAPADMIN_HTTPS=&quot;false&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">PHPLDAPADMIN_LDAP_HOSTS=openldap</span></span><br><span class="line">    <span class="attr">links:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">openldap</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">openldap</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="啟動服務"><a href="#啟動服務" class="headerlink" title="啟動服務"></a>啟動服務</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure>
<h2 id="查看服務log"><a href="#查看服務log" class="headerlink" title="查看服務log"></a>查看服務log</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker logs openldap -f</span><br></pre></td></tr></table></figure>
<h1 id="window-tcp-轉發"><a href="#window-tcp-轉發" class="headerlink" title="window tcp 轉發"></a><a href="https://blog.csdn.net/cw_hello1/article/details/105968359">window tcp 轉發</a></h1><p>因為在ldap server 在不同網段，所以需要轉發</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新增轉發規則</span></span><br><span class="line">netsh interface portproxy add v4tov4 listenport=389 listenaddress=192.168.57.2 connectaddress=192.168.56.111 connectport=8389</span><br><span class="line">netsh interface portproxy add v4tov4 listenport=8081 listenaddress=192.168.57.2 connectaddress=192.168.56.111 connectport=8081</span><br><span class="line"></span><br><span class="line"><span class="comment"># 顯示規則</span></span><br><span class="line">netsh interface portproxy show all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重開機需要刪除後新增</span></span><br><span class="line">netsh interface portproxy delete v4tov4 listenport=389 listenaddress=192.168.57.2</span><br></pre></td></tr></table></figure>

<h1 id="phpldapadmin"><a href="#phpldapadmin" class="headerlink" title="phpldapadmin"></a>phpldapadmin</h1><h2 id="訪問-http-192-168-56-111-8081"><a href="#訪問-http-192-168-56-111-8081" class="headerlink" title="訪問 http://192.168.56.111:8081/"></a>訪問 <a href="http://192.168.56.111:8081/">http://192.168.56.111:8081/</a></h2><p><img src="/images/20240416144938.png"></p>
<h2 id="登入"><a href="#登入" class="headerlink" title="登入"></a>登入</h2><p>docker compose預設: 帳號cn&#x3D;admin,dc&#x3D;example,dc&#x3D;org 密碼 admin<br>帳號: cn&#x3D;admin,dc&#x3D;ipcamera,dc&#x3D;com<br>密碼: admin<br><img src="/images/20240416145153.png"></p>
<h2 id="建立entry"><a href="#建立entry" class="headerlink" title="建立entry"></a>建立entry</h2><p><img src="/images/20240416145244.png"><br>新增節點非常簡單，只要在要新增節點的上一層，點擊下面的 Create a child entry，就可以新增節點。<br><img src="/images/20240416145259.png"><br>常用的是Generic 這些類別<br><img src="/images/20240416145425.png"><br>簡單的權限管理為以下樹狀結構</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">groups(ou)</span><br><span class="line">	admin(cn)</span><br><span class="line">	operator(cn)</span><br><span class="line">	user(cn)</span><br><span class="line">users(ou)</span><br><span class="line">	Brian Lu(cn)</span><br><span class="line">	Vivian Chen(cn)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>
<p><img src="/images/20240416145706.png"><br><img src="/images/20240416152235.png"></p>
<h1 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h1><h2 id="登入-server"><a href="#登入-server" class="headerlink" title="登入 server"></a>登入 server</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -ti openldap bash</span><br></pre></td></tr></table></figure>
<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查詢數據庫訊息</span></span><br><span class="line">ldapsearch -Q -LLL -Y EXTERNAL -H ldapi:/// -b cn=config dn</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用admin查詢</span></span><br><span class="line">ldapsearch -x -D <span class="string">&quot;cn=admin,dc=ipcamera,dc=com&quot;</span> -w admin -b <span class="string">&quot;dc=ipcamera,dc=com&quot;</span> <span class="string">&quot;(objectClass=*)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Brian Lu查詢</span></span><br><span class="line">ldapsearch -x -D <span class="string">&quot;cn=Brian Lu,ou=users,dc=ipcamera,dc=com&quot;</span> -w admin -b <span class="string">&quot;dc=ipcamera,dc=com&quot;</span> <span class="string">&quot;(objectClass=*)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 變更olc權限，使得Brian Lu可以查詢 docker compose預設密碼為config </span></span><br><span class="line"><span class="comment"># &#123;1&#125;mdb為使用的database使用上面查詢數據庫訊息查詢</span></span><br><span class="line">ldapmodify -x -D <span class="string">&quot;cn=admin,cn=config&quot;</span> -w config &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">dn: olcDatabase=&#123;1&#125;mdb,cn=config</span></span><br><span class="line"><span class="string">changetype: modify</span></span><br><span class="line"><span class="string">add: olcAccess</span></span><br><span class="line"><span class="string">olcAccess: &#123;2&#125;to dn.subtree=&quot;dc=ipcamera,dc=com&quot;</span></span><br><span class="line"><span class="string">  by dn=&quot;cn=Brian Lu,ou=users,dc=ipcamera,dc=com&quot; read</span></span><br><span class="line"><span class="string">  by dn=&quot;cn=Brian Lin,ou=users,dc=ipcamera,dc=com&quot; read</span></span><br><span class="line"><span class="string">  by * none</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="docker-openldap-memberOf欄位"><a href="#docker-openldap-memberOf欄位" class="headerlink" title="docker openldap memberOf欄位"></a>docker openldap memberOf欄位</h1><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><h2 id="建立-ou-x3D-users-dc-x3D-ipcamera-dc-x3D-com-和-ou-x3D-groups-dc-x3D-ipcamera-dc-x3D-comdocker-裡面-x2F-container-x2F-service-x2F-slapd-x2F-assets-x2F-config-x2F-bootstrap-x2F-ldif-x2F-03-memberOf-ldif-為-groupOfUniqueNames-add-user-ldif-add-unique-group-ldif-下指令-參考-LDAP-入門-使用-Docker-建置-LDAP-系統-OpenLDAP-添加groupOfUniqueNames属性-启用OpenLDAP的memberOf特性-LDAP添加-memberOf-模块-如何启用-OpenLDAP-的-memberOf-特性-OpenLDAP-系列7-—-memberof-amp-refint"><a href="#建立-ou-x3D-users-dc-x3D-ipcamera-dc-x3D-com-和-ou-x3D-groups-dc-x3D-ipcamera-dc-x3D-comdocker-裡面-x2F-container-x2F-service-x2F-slapd-x2F-assets-x2F-config-x2F-bootstrap-x2F-ldif-x2F-03-memberOf-ldif-為-groupOfUniqueNames-add-user-ldif-add-unique-group-ldif-下指令-參考-LDAP-入門-使用-Docker-建置-LDAP-系統-OpenLDAP-添加groupOfUniqueNames属性-启用OpenLDAP的memberOf特性-LDAP添加-memberOf-模块-如何启用-OpenLDAP-的-memberOf-特性-OpenLDAP-系列7-—-memberof-amp-refint" class="headerlink" title="建立 ou&#x3D;users,dc&#x3D;ipcamera,dc&#x3D;com 和 ou&#x3D;groups,dc&#x3D;ipcamera,dc&#x3D;comdocker 裡面 &#x2F;container&#x2F;service&#x2F;slapd&#x2F;assets&#x2F;config&#x2F;bootstrap&#x2F;ldif&#x2F;03-memberOf.ldif 為 groupOfUniqueNames## add_user.ldif##  add_unique_group.ldif## 下指令# 參考- LDAP 入門- 使用 Docker 建置 LDAP 系統- OpenLDAP 添加groupOfUniqueNames属性- 启用OpenLDAP的memberOf特性- LDAP添加 memberOf 模块- 如何启用 OpenLDAP 的 memberOf 特性- OpenLDAP 系列7 — memberof &amp; refint"></a>建立 ou&#x3D;users,dc&#x3D;ipcamera,dc&#x3D;com 和 ou&#x3D;groups,dc&#x3D;ipcamera,dc&#x3D;com<br>docker 裡面 &#x2F;container&#x2F;service&#x2F;slapd&#x2F;assets&#x2F;config&#x2F;bootstrap&#x2F;ldif&#x2F;03-memberOf.ldif 為 groupOfUniqueNames<br>## add_user.ldif<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dn: cn=Brian Lin,ou=<span class="built_in">users</span>,dc=ipcamera,dc=com</span><br><span class="line">cn: Brian Lin</span><br><span class="line">givenName: Brian</span><br><span class="line">sn: Lin</span><br><span class="line">uid: blin</span><br><span class="line">uidNumber: 5000</span><br><span class="line">gidNumber: 1000</span><br><span class="line">userPassword: &#123;SHA&#125;M6XDJwA47cNw9gm5kXV1uTQuMoY=</span><br><span class="line">homeDirectory: /home/john</span><br><span class="line">mail: john.doe@example.com</span><br><span class="line">objectClass: top</span><br><span class="line">objectClass: posixAccount</span><br><span class="line">objectClass: inetOrgPerson</span><br></pre></td></tr></table></figure><br>##  add_unique_group.ldif<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dn: cn=admin,ou=<span class="built_in">groups</span>,dc=ipcamera,dc=com</span><br><span class="line">objectClass: top</span><br><span class="line">objectClass: groupOfUniqueNames</span><br><span class="line">cn: admin</span><br><span class="line">uniqueMember: cn=Brian Lin,ou=<span class="built_in">users</span>,dc=ipcamera,dc=com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dn: cn=oprator,ou=<span class="built_in">groups</span>,dc=ipcamera,dc=com</span><br><span class="line">objectClass: top</span><br><span class="line">objectClass: groupOfUniqueNames</span><br><span class="line">cn: oprator</span><br><span class="line">uniqueMember: </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dn: cn=user,ou=<span class="built_in">groups</span>,dc=ipcamera,dc=com</span><br><span class="line">objectClass: top</span><br><span class="line">objectClass: groupOfUniqueNames</span><br><span class="line">cn: user</span><br><span class="line">uniqueMember: </span><br><span class="line"></span><br></pre></td></tr></table></figure><br>## 下指令<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 新增user和groups</span></span><br><span class="line">ldapadd -x -D cn=admin,dc=ipcamera,dc=com -W -f add_user.ldif </span><br><span class="line">ldapadd -x -D cn=admin,dc=ipcamera,dc=com -W -f add_unique_group.ldif </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢 要帶上查詢的attribute=memberOf</span></span><br><span class="line">ldapsearch -x -D <span class="string">&quot;cn=Brian Lin,ou=users,dc=ipcamera,dc=com&quot;</span> -w admin -b <span class="string">&quot;dc=ipcamera,dc=com&quot;</span> <span class="string">&quot;cn=Brian Lin&quot;</span> memberOf </span><br></pre></td></tr></table></figure><br># 參考<br>- <a href="https://linux.vbird.org/somepaper/20050817-ldap-1.pdf">LDAP 入門</a><br>- <a href="https://chrislee0728.medium.com/%E4%BD%BF%E7%94%A8-docker-%E5%BB%BA%E7%BD%AE-ldap-%E7%B3%BB%E7%B5%B1-82370c53bc9f">使用 Docker 建置 LDAP 系統</a><br>- <a href="https://chenzhonzhou.github.io/2020/11/04/openldap-tian-jia-groupofuniquenames-shu-xing/">OpenLDAP 添加groupOfUniqueNames属性</a><br>- <a href="https://www.linuxprobe.com/enable-memberof-openldap.html">启用OpenLDAP的memberOf特性</a><br>- <a href="https://blog.csdn.net/u011607971/article/details/119037796">LDAP添加 memberOf 模块</a><br>- <a href="https://mayanbin.com/posts/enable-memberof-in-openldap">如何启用 OpenLDAP 的 memberOf 特性</a><br>- <a href="https://www.cnblogs.com/eagle6688/p/16990393.html">OpenLDAP 系列7 — memberof &amp; refint</a></h2>]]></content>
      <tags>
        <tag>openldap</tag>
        <tag>phpldapadmin</tag>
      </tags>
  </entry>
  <entry>
    <title>NAT（Network Address Translation，網路位址轉換）</title>
    <url>/posts/20241223034700-7727d3af.html</url>
    <content><![CDATA[<p>NAT（Network Address Translation，網路位址轉換）是一種網路技術，用於將內部網路的私有IP地址轉換為公共IP地址，或反向轉換。這項技術的主要目的是讓多台內部設備能夠共享一個或少量公共IP地址進行外部網路通信，同時提高網路安全性。</p>
<h3 id="NAT-的主要功能："><a href="#NAT-的主要功能：" class="headerlink" title="NAT 的主要功能："></a>NAT 的主要功能：</h3><ol>
<li><strong>地址重用</strong>：通過使用私有IP地址，節省了公共IP地址的資源。</li>
<li><strong>隱藏內部網路結構</strong>：外部設備無法直接訪問內部設備，提高了安全性。 <span id="more"></span></li>
<li><strong>負載分擔</strong>（可選）：某些高級NAT設備可以實現多條外部連接的負載均衡。</li>
</ol>
<h3 id="NAT-的類型："><a href="#NAT-的類型：" class="headerlink" title="NAT 的類型："></a>NAT 的類型：</h3><ol>
<li><p><strong>靜態NAT（Static NAT）</strong>：</p>
<ul>
<li>一對一地將私有IP地址映射到公共IP地址。</li>
<li>用於需要外部設備直接訪問內部設備的情況。</li>
</ul>
</li>
<li><p><strong>動態NAT（Dynamic NAT）</strong>：</p>
<ul>
<li>使用一組公共IP地址，根據需求動態分配給內部設備。</li>
<li>不保證每個內部設備都有固定的公共IP。</li>
</ul>
</li>
<li><p><strong>PAT（Port Address Translation）</strong> 或稱「NAPT」：</p>
<ul>
<li>多對一的NAT，也叫「多工NAT」。</li>
<li>通過改變傳輸層的端口號讓多個內部設備共享一個公共IP地址。</li>
<li>是家庭路由器最常見的NAT形式。</li>
</ul>
</li>
</ol>
<h3 id="NAT-的工作原理："><a href="#NAT-的工作原理：" class="headerlink" title="NAT 的工作原理："></a>NAT 的工作原理：</h3><ol>
<li><p><strong>請求發送（內部到外部）：</strong></p>
<ul>
<li>當內部設備向外部網路發送請求時，NAT設備會將內部的私有IP地址和端口號轉換為公共IP地址和新的端口號。</li>
<li>NAT設備在內部維護一個映射表，用於跟蹤這些轉換。</li>
</ul>
</li>
<li><p><strong>響應接收（外部到內部）：</strong></p>
<ul>
<li>當外部網路的響應到達NAT設備時，NAT設備根據映射表將公共IP地址和端口號還原為內部的私有IP地址和端口號，然後將數據包轉發到內部設備。</li>
</ul>
</li>
</ol>
<h3 id="使用場景："><a href="#使用場景：" class="headerlink" title="使用場景："></a>使用場景：</h3><ul>
<li><strong>家庭或企業網路</strong>：讓多台設備共享一個ISP分配的公共IP地址。</li>
<li><strong>伺服器部署</strong>：在某些情況下，需要靜態NAT來將特定公共IP地址映射到內部伺服器。</li>
</ul>
<p>NAT 雖然能節省IP資源和提升安全性，但也可能導致某些應用（例如P2P網路或VoIP）運行效率降低，因為這些應用依賴於直接的端到端通信。</p>
<h1 id="NAT（网络地址转换）分为以下四种类型"><a href="#NAT（网络地址转换）分为以下四种类型" class="headerlink" title="NAT（网络地址转换）分为以下四种类型"></a>NAT（网络地址转换）分为以下四种类型</h1><h3 id="1-完全圆锥型-NAT（Full-Cone-NAT）"><a href="#1-完全圆锥型-NAT（Full-Cone-NAT）" class="headerlink" title="1. 完全圆锥型 NAT（Full Cone NAT）"></a>1. <strong>完全圆锥型 NAT（Full Cone NAT）</strong></h3><ul>
<li><p><strong>特性</strong>：</p>
<ul>
<li>一个内部地址和端口与一个外部地址和端口一一对应。</li>
<li>任何外部设备都可以通过已映射的外部地址和端口发送数据包到内部设备。</li>
<li>无需特定的访问限制。</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>连接容易建立，适合P2P和VoIP应用。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>安全性较低，因为任何外部主机都可以通过已映射的端口访问内部设备。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="2-受限圆锥型-NAT（Restricted-Cone-NAT）"><a href="#2-受限圆锥型-NAT（Restricted-Cone-NAT）" class="headerlink" title="2. 受限圆锥型 NAT（Restricted Cone NAT）"></a>2. <strong>受限圆锥型 NAT（Restricted Cone NAT）</strong></h3><ul>
<li><p><strong>特性</strong>：</p>
<ul>
<li>一个内部地址和端口与一个外部地址和端口一一对应。</li>
<li>只有在内部设备主动发送数据包给外部设备后，外部设备才能通过已映射的外部端口回复数据包。</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>比完全圆锥型 NAT 更安全。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>外部设备不能主动发起连接，可能对某些应用程序造成限制。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-端口受限圆锥型-NAT（Port-Restricted-Cone-NAT）"><a href="#3-端口受限圆锥型-NAT（Port-Restricted-Cone-NAT）" class="headerlink" title="3. 端口受限圆锥型 NAT（Port Restricted Cone NAT）"></a>3. <strong>端口受限圆锥型 NAT（Port Restricted Cone NAT）</strong></h3><ul>
<li><p><strong>特性</strong>：</p>
<ul>
<li>在受限圆锥型 NAT 的基础上进一步限制：<ul>
<li>外部设备只有在特定端口上收到内部设备的连接请求后，才能通过该端口回复数据包。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>比受限圆锥型 NAT 更加安全。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>连接建立较为复杂，对某些应用程序的兼容性较差。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-对称型-NAT（Symmetric-NAT）"><a href="#4-对称型-NAT（Symmetric-NAT）" class="headerlink" title="4. 对称型 NAT（Symmetric NAT）"></a>4. <strong>对称型 NAT（Symmetric NAT）</strong></h3><ul>
<li><p><strong>特性</strong>：</p>
<ul>
<li>一个内部地址和端口的映射取决于目标外部地址和端口。</li>
<li>每次连接到不同的外部目标都会生成不同的映射。</li>
<li>外部设备无法直接发起连接，即使内部设备先发送了数据包。</li>
</ul>
</li>
<li><p><strong>优点</strong>：</p>
<ul>
<li>安全性最高。</li>
</ul>
</li>
<li><p><strong>缺点</strong>：</p>
<ul>
<li>对P2P和VoIP应用支持最差，因为很难穿透NAT。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a><strong>对比总结</strong></h3><table>
<thead>
<tr>
<th>类型</th>
<th>安全性</th>
<th>穿透难度</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>完全圆锥型 NAT</td>
<td>低</td>
<td>最低</td>
<td>所有人可访问映射的端口</td>
</tr>
<tr>
<td>受限圆锥型 NAT</td>
<td>中</td>
<td>中低</td>
<td>外部设备需先接收到内部请求</td>
</tr>
<tr>
<td>端口受限圆锥型 NAT</td>
<td>高</td>
<td>中高</td>
<td>需要特定端口匹配</td>
</tr>
<tr>
<td>对称型 NAT</td>
<td>最高</td>
<td>最高</td>
<td>每次连接生成唯一映射</td>
</tr>
<tr>
<td>对称型 NAT &gt; 端口受限圆锥型 NAT &gt; 受限圆锥型 NAT &gt; 完全圆锥型 NAT</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="应用建议"><a href="#应用建议" class="headerlink" title="应用建议"></a><strong>应用建议</strong></h3><ul>
<li><strong>完全圆锥型 NAT</strong>：适合无严格安全需求的环境，如家庭娱乐网络。</li>
<li><strong>受限圆锥型 NAT 和端口受限圆锥型 NAT</strong>：适合需要一定安全性但仍需较高连接性能的环境。</li>
<li><strong>对称型 NAT</strong>：适合高安全需求的企业网络。</li>
</ul>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>Nessus Advanced Scan</title>
    <url>/posts/20240506075800-7abecaea.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在使用Nessus最一般的就是用 Basic Network Scan 但這會掃描非常久時間，所以可以使用<br>Advanced Scan選擇想要掃的項目，但是茫茫大海要如何選擇特定的Plugin呢</p>
<h1 id="新增掃描"><a href="#新增掃描" class="headerlink" title="新增掃描"></a>新增掃描</h1><p><img src="/images/20240506131854.png"></p>
<h1 id="這裡可以選擇要掃描的範本"><a href="#這裡可以選擇要掃描的範本" class="headerlink" title="這裡可以選擇要掃描的範本"></a>這裡可以選擇要掃描的範本</h1><p><img src="/images/20240506131950.png"></p>
<h1 id="選擇-Advanced-Scan"><a href="#選擇-Advanced-Scan" class="headerlink" title="選擇 Advanced Scan"></a>選擇 Advanced Scan</h1> <span id="more"></span>
<p> <img src="/images/20240506145217.png"></p>
<h1 id="點擊Plugins"><a href="#點擊Plugins" class="headerlink" title="點擊Plugins"></a>點擊Plugins</h1><p><img src="/images/20240506145310.png"></p>
<h1 id="可以看到左邊是Plugin-Famliy-右邊是Plugin"><a href="#可以看到左邊是Plugin-Famliy-右邊是Plugin" class="headerlink" title="可以看到左邊是Plugin Famliy 右邊是Plugin"></a>可以看到左邊是Plugin Famliy 右邊是Plugin</h1><p><img src="/images/20240506145241.png"></p>
<h1 id="選擇-Disable-All-先取消所有"><a href="#選擇-Disable-All-先取消所有" class="headerlink" title="選擇 Disable All 先取消所有"></a>選擇 Disable All 先取消所有</h1><p><img src="/images/20240506145519.png"></p>
<h1 id="假設要找的Plugin是ICMP-Domain-Name-Request"><a href="#假設要找的Plugin是ICMP-Domain-Name-Request" class="headerlink" title="假設要找的Plugin是ICMP Domain Name Request"></a>假設要找的Plugin是<a href="https://www.tenable.com/plugins/nessus/20887">ICMP Domain Name Request</a></h1><p><img src="/images/20240506145655.png"></p>
<h1 id="看到Family為General"><a href="#看到Family為General" class="headerlink" title="看到Family為General"></a>看到Family為<u>General</u></h1><p><img src="/images/20240506145749.png"></p>
<h1 id="在Advanced-Scan-Plugins-左側選擇-General-右側找到ICMP-Domain-Name-Request-再保存就完成了"><a href="#在Advanced-Scan-Plugins-左側選擇-General-右側找到ICMP-Domain-Name-Request-再保存就完成了" class="headerlink" title="在Advanced Scan Plugins 左側選擇 General 右側找到ICMP Domain Name Request 再保存就完成了"></a>在Advanced Scan Plugins 左側選擇 <u>General</u> 右側找到ICMP Domain Name Request 再保存就完成了</h1><p><img src="/images/20240506145832.png"></p>
]]></content>
      <categories>
        <category>資安</category>
      </categories>
      <tags>
        <tag>Nessus</tag>
      </tags>
  </entry>
  <entry>
    <title>Nessus scan issue- ICMP Timestamp Request Remote Date Disclosure</title>
    <url>/posts/20250218043800-8d2c5c93.html</url>
    <content><![CDATA[<p><strong>ICMP Timestamp Request Remote Date Disclosure</strong> 是一種資訊洩露漏洞，主要與 ICMP（Internet Control Message Protocol）中的 <strong>Timestamp Request（類型 13）</strong> 和 <strong>Timestamp Reply（類型 14）</strong> 相關。</p>
<h3 id="可能的問題與風險"><a href="#可能的問題與風險" class="headerlink" title="可能的問題與風險"></a><strong>可能的問題與風險</strong></h3><ol>
<li><p><strong>系統時間洩露（時間同步攻擊）</strong></p>
 <span id="more"></span>
<ul>
<li>攻擊者可以透過 ICMP Timestamp Request 回應的時間資訊，獲取目標系統的當前時間。</li>
<li>這可能有助於進行「時序攻擊」（Timing Attack），例如分析時間同步問題、推測隨機數生成器的狀態等。</li>
</ul>
</li>
<li><p><strong>協助進行網路探測（Network Reconnaissance）</strong></p>
<ul>
<li>攻擊者可以掃描大量 IP 來確定哪些系統回應 ICMP Timestamp Request，進一步縮小攻擊範圍。</li>
<li>此外，透過不同設備的回應時間，可以推測目標設備的地理位置或時區。</li>
</ul>
</li>
<li><p><strong>協助執行 NTP 攻擊（Network Time Protocol Attack）</strong></p>
<ul>
<li>若攻擊者發現目標設備的時間與標準時間不同，可能嘗試對 NTP 服務進行攻擊，例如 <strong>NTP 反射攻擊（NTP Amplification Attack）</strong> 或 <strong>時間重置攻擊（Time Shift Attack）</strong>，導致系統錯誤。</li>
</ul>
</li>
<li><p><strong>幫助識別作業系統與設備類型</strong></p>
<ul>
<li>不同作業系統（Windows、Linux、BSD 等）對 ICMP Timestamp Request 的回應方式可能不同，因此攻擊者可以利用這些資訊進行指紋識別（Fingerprinting）。</li>
<li>例如，某些設備的時鐘可能是從開機時間開始計算的，而非標準 UTC 時間。</li>
</ul>
</li>
<li><p><strong>協助分佈式攻擊（Distributed Attack）</strong></p>
<ul>
<li>在分散式攻擊中，攻擊者可以利用這些時間資訊來同步惡意行為，例如 DDoS 攻擊中的「時間協調」（Coordinated Timing Attack）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="如何修復與緩解"><a href="#如何修復與緩解" class="headerlink" title="如何修復與緩解"></a><strong>如何修復與緩解</strong></h3><ol>
<li><strong>封鎖 ICMP Timestamp Request（類型 13）</strong></li>
</ol>
<ul>
<li>在防火牆（如 <code>iptables</code> 或 <code>pf</code>）或網路設備上封鎖 ICMP 類型 13 封包：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p icmp --icmp-type timestamp-request -j DROP</span><br></pre></td></tr></table></figure></li>
<li>若使用 <code>pf</code>（如 OpenBSD &#x2F; FreeBSD）：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">block <span class="keyword">in</span> quick proto icmp icmp-type timestamp</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>在網路設備上停用 ICMP Timestamp 回應</strong><ul>
<li>部分設備（如 Cisco、Juniper）可以透過 CLI 停用 ICMP Timestamp：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">no ip icmp timestamp-reply</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>針對伺服器或終端設備進行系統加固</strong><ul>
<li>在 Linux 系統中，透過 sysctl 限制 ICMP：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.icmp_echo_ignore_all = 1&quot;</span> &gt;&gt; /etc/sysctl.conf sysctl -p</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>使用 NTP 進行時間同步，避免時鐘偏移</strong><ul>
<li>確保系統時間同步到可信任的時間伺服器（如 <code>time.google.com</code>、<code>ntp.org</code>）。</li>
<li>若設備時間偏差過大，可能會影響 TLS、Kerberos 認證等安全機制。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="結論"><a href="#結論" class="headerlink" title="結論"></a><strong>結論</strong></h3><p>ICMP Timestamp Request Remote Date Disclosure 本身不是一個直接的攻擊向量，但它會洩露系統時間資訊，可能被攻擊者利用來進一步分析和計劃攻擊。建議在不影響正常業務的情況下，封鎖 ICMP Timestamp Request，並確保系統時間正確同步，以降低潛在風險。</p>
<h3 id="以上是ChatGPT得回覆"><a href="#以上是ChatGPT得回覆" class="headerlink" title="以上是ChatGPT得回覆"></a>以上是ChatGPT得回覆</h3><h2 id="驗證法一"><a href="#驗證法一" class="headerlink" title="驗證法一"></a>驗證法一</h2><p>使用 nping(安裝wireshark完應該有) 指令測試驗證 icmp type 13 為 timestamp request  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nping --icmp --icmp-type 13 192.168.57.3 </span><br></pre></td></tr></table></figure>
<p><img src="/images/20250218113332.png"><br>看到 RCVD有收到來自192.168.57.3的回覆 這是原本的<br><img src="/images/20250218113344.png"><br>沒有收到來自192.168.57.3的回覆 這是修改後的</p>
<h2 id="驗證法二"><a href="#驗證法二" class="headerlink" title="驗證法二"></a>驗證法二</h2><p>使用Nessus的Advance Scan<br>Plugins 只選擇 General 裡面的 ICMP Timestamp Request Remote Date Disclosure<br>做掃描<br><img src="/images/20250218113509.png"><br>原本會掃描出黃色Low 的 ICMP Timestamp Request 弱點<br><img src="/images/20250218113518.png"><br>修改後 就不會出現</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Nessus</tag>
        <tag>chatgpt</tag>
      </tags>
  </entry>
  <entry>
    <title>P2P 打洞（Peer-to-Peer NAT Traversal）</title>
    <url>/posts/20241219102800-464c14bb.html</url>
    <content><![CDATA[<h1 id="兩個裝置分別在NAT後面"><a href="#兩個裝置分別在NAT後面" class="headerlink" title="兩個裝置分別在NAT後面"></a>兩個裝置分別在NAT後面</h1><p><img src="/images/20241219171958.png"></p>
<h1 id="這時需要一台Server當作溝通橋梁-傳送訊號"><a href="#這時需要一台Server當作溝通橋梁-傳送訊號" class="headerlink" title="這時需要一台Server當作溝通橋梁 傳送訊號"></a>這時需要一台Server當作溝通橋梁 傳送訊號</h1><p><img src="/images/20241219172742.png"></p>
<h1 id="裝置A向Sever註冊自己外網-IP-和-port"><a href="#裝置A向Sever註冊自己外網-IP-和-port" class="headerlink" title="裝置A向Sever註冊自己外網  IP 和 port"></a>裝置A向Sever註冊自己外網  IP 和 port</h1><p><img src="/images/20241219172424.png"><br>在 A 裝置啟一個 3000 UDP服務 並將自己的 外網 ip 和 port 向 server 註冊<br> <span id="more"></span></p>
<h1 id="裝置B向Sever註冊自己外網-IP-和-port"><a href="#裝置B向Sever註冊自己外網-IP-和-port" class="headerlink" title="裝置B向Sever註冊自己外網  IP 和 port"></a>裝置B向Sever註冊自己外網  IP 和 port</h1><p><img src="/images/20241219172021.png"><br>在 B 裝置啟一個 3000 UDP服務 並將自己的 外網 ip 和 port 向 server 註冊</p>
<h1 id="Sever-向A-B-裝置-傳送對方的-IP-和-port"><a href="#Sever-向A-B-裝置-傳送對方的-IP-和-port" class="headerlink" title="Sever 向A B 裝置 傳送對方的 IP 和 port"></a>Sever 向A B 裝置 傳送對方的 IP 和 port</h1><p><img src="/images/20241219172034.png"><br>Server向A傳送B的 ip 和 port<br>Server向B傳送A的 ip 和 port</p>
<h1 id="A-向-B-發送-UDP-封包"><a href="#A-向-B-發送-UDP-封包" class="headerlink" title="A 向 B 發送 UDP 封包"></a>A 向 B 發送 UDP 封包</h1><p><img src="/images/20241219172123.png"><br>A 向 B 發送 UDP 封包 在這個過程中 A 的源端口為 3000 並且在穿過 NAT A 時，<br>留下紀錄 192.168.1.1:3000 &lt;-&gt; 203.0.113.1:1234<br>封包到達NAT B時，因為不知如何轉發，所以將此封包拋棄</p>
<h1 id="B-向-A-發送-UDP-封包"><a href="#B-向-A-發送-UDP-封包" class="headerlink" title="B 向 A 發送 UDP 封包"></a>B 向 A 發送 UDP 封包</h1><p><img src="/images/20241219172134.png"><br>B 向 A 發送 UDP 封包 在這個過程中 B 的源端口為 3000 並且在穿過 NAT B 時，<br>留下紀錄 192.168.30.1:3000 &lt;-&gt; 192.51.100.1:1233<br>封包到達NAT A時，因為先前已有紀錄轉發，所以將此封包轉到 A</p>
<h1 id="兩邊可以通過UDP-做-P2P連線"><a href="#兩邊可以通過UDP-做-P2P連線" class="headerlink" title="兩邊可以通過UDP 做 P2P連線"></a>兩邊可以通過UDP 做 P2P連線</h1><p><img src="/images/20241219172144.png"></p>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>  上述流程為簡易的流程，如</p>
<ul>
<li>如何知道自己公網 IP 以及 <a href="/posts/20241223034700-7727d3af.html" title="NAT（Network Address Translation，網路位址轉換）">NAT（Network Address Translation，網路位址轉換）</a>#NAT（网络地址转换）分为以下四种类型 需要用 <a href="/posts/20241223035000-d4e6d128.html" title="STUN（ Session Traversal Utilities for NAT，NAT 穿越會話工具）">STUN（ Session Traversal Utilities for NAT，NAT 穿越會話工具）</a></li>
<li>如果NAT類型為 非對稱NAT  需要用 <a href="/posts/20241223040900-46d03228.html" title="TURN 協議（Traversal Using Relays around NAT）">TURN 協議（Traversal Using Relays around NAT）</a><br>  如果遇到不同的設備，成功率會不同，上述流程需要一台Server做幫忙，且NAT類型為 非對稱NAT，仰賴NAT映射關係及UDP特性</li>
</ul>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://webrtc.mthli.com/basic/p2p-hole-punching/">P2P 打洞原理</a></li>
</ul>
]]></content>
      <tags>
        <tag>WebRTC</tag>
        <tag>p2p</tag>
      </tags>
  </entry>
  <entry>
    <title>Nessus</title>
    <url>/posts/20240506024400-613b46cc.html</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p>Nessus是一個弱點掃描工具，業界廣泛使用的漏洞與系統設定評估產品</p>
<h1 id="免費版啟用代碼"><a href="#免費版啟用代碼" class="headerlink" title="免費版啟用代碼"></a>免費版啟用代碼</h1><h2 id="到官網選擇最右邊的免費版-Nessus-Essentials"><a href="#到官網選擇最右邊的免費版-Nessus-Essentials" class="headerlink" title="到官網選擇最右邊的免費版(Nessus Essentials)"></a>到<a href="https://zh-tw.tenable.com/products/nessus/activation-code">官網</a>選擇最右邊的免費版(Nessus Essentials)</h2><p><img src="/images/20240506093731.png"></p>
<h2 id="填入相關資訊"><a href="#填入相關資訊" class="headerlink" title="填入相關資訊"></a>填入相關資訊</h2><p><img src="/images/20240506093802.png"><br> <span id="more"></span></p>
<h2 id="到Email收信，裡面會有啟用碼"><a href="#到Email收信，裡面會有啟用碼" class="headerlink" title="到Email收信，裡面會有啟用碼"></a>到Email收信，裡面會有啟用碼</h2><p><img src="/images/20240506093524.png"></p>
<h1 id="用Docker容器啟動nessus"><a href="#用Docker容器啟動nessus" class="headerlink" title="用Docker容器啟動nessus"></a>用Docker容器啟動nessus</h1><h2 id="法一-docker-run"><a href="#法一-docker-run" class="headerlink" title="法一 docker run"></a>法一 docker run</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name <span class="string">&quot;Nessus&quot;</span>  -p 666:8834 -e ACTIVATION_CODE=啟動代碼 -e USERNAME=admin -e  PASSWORD=123456 tenableofficial/nessus</span><br></pre></td></tr></table></figure>

<h2 id="法二-docker-compose"><a href="#法二-docker-compose" class="headerlink" title="法二 docker compose"></a>法二 docker compose</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">services:</span><br><span class="line">  nessus:</span><br><span class="line">    container_name: Nessus</span><br><span class="line">    ports:</span><br><span class="line">      - 666:8834</span><br><span class="line">    environment:</span><br><span class="line">      - ACTIVATION_CODE=啟動代碼</span><br><span class="line">      - USERNAME=admin</span><br><span class="line">      - PASSWORD=123456</span><br><span class="line">    image: tenableofficial/nessus</span><br></pre></td></tr></table></figure>

<h2 id="啟動後需要3-5分鐘-才可以正常訪問"><a href="#啟動後需要3-5分鐘-才可以正常訪問" class="headerlink" title="啟動後需要3-5分鐘 才可以正常訪問"></a>啟動後需要3-5分鐘 才可以正常訪問</h2><p>網址打 <a href="https://192.168.56.111:666/#/">https://192.168.56.111:666/#/</a><br><img src="/images/20240506131509.png"><br>輸入docker設定的帳號(admin)密碼(123456)<br><img src="/images/20240506131731.png"><br>登入後的頁面</p>
<h1 id="掃描"><a href="#掃描" class="headerlink" title="掃描"></a>掃描</h1><h2 id="新增掃描"><a href="#新增掃描" class="headerlink" title="新增掃描"></a>新增掃描</h2><p><img src="/images/20240506131854.png"></p>
<h2 id="這裡可以選擇要掃描的範本"><a href="#這裡可以選擇要掃描的範本" class="headerlink" title="這裡可以選擇要掃描的範本"></a>這裡可以選擇要掃描的範本</h2><p><img src="/images/20240506131950.png"></p>
<h2 id="選擇-Basic-Network-Scan"><a href="#選擇-Basic-Network-Scan" class="headerlink" title="選擇 Basic Network Scan"></a>選擇 Basic Network Scan</h2><p><img src="/images/20240506132153.png"></p>
<h2 id="Settings-裡面-Name-和-Targets-必填"><a href="#Settings-裡面-Name-和-Targets-必填" class="headerlink" title="Settings 裡面 Name 和 Targets 必填"></a>Settings 裡面 Name 和 Targets 必填</h2><p><img src="/images/20240506132304.png"></p>
<ul>
<li>Name: 隨便填</li>
<li>Targets: 要掃描機器的IP或域名</li>
</ul>
<h2 id="Plugins-裡面就可以看到要掃描的項目"><a href="#Plugins-裡面就可以看到要掃描的項目" class="headerlink" title="Plugins 裡面就可以看到要掃描的項目"></a>Plugins 裡面就可以看到要掃描的項目</h2><p><img src="/images/20240506132708.png"></p>
<h2 id="點擊-Save-保存"><a href="#點擊-Save-保存" class="headerlink" title="點擊 Save 保存"></a>點擊 Save 保存</h2><h2 id="在My-Scans-底下就會有剛剛建立起來的掃描項目"><a href="#在My-Scans-底下就會有剛剛建立起來的掃描項目" class="headerlink" title="在My Scans 底下就會有剛剛建立起來的掃描項目"></a>在My Scans 底下就會有剛剛建立起來的掃描項目</h2><p><img src="/images/20240506132844.png"></p>
<h2 id="點進來再點擊-Launch-就可以開始掃描了"><a href="#點進來再點擊-Launch-就可以開始掃描了" class="headerlink" title="點進來再點擊 Launch 就可以開始掃描了"></a>點進來再點擊 Launch 就可以開始掃描了</h2><p><img src="/images/20240506132911.png"></p>
<h2 id="掃描中…"><a href="#掃描中…" class="headerlink" title="掃描中…"></a>掃描中…</h2><p><img src="/images/20240506133234.png"></p>
<h2 id="掃描過程中可以看到有哪些弱點-vulnerability"><a href="#掃描過程中可以看到有哪些弱點-vulnerability" class="headerlink" title="掃描過程中可以看到有哪些弱點(vulnerability)"></a>掃描過程中可以看到有哪些弱點(vulnerability)</h2><p><img src="/images/20240506133326.png"><br>Basic Network Scan 掃描要花非常久的時間，建議用Advanced Scan可以選擇想要掃的項目</p>
<h1 id="問題"><a href="#問題" class="headerlink" title="問題"></a>問題</h1><h2 id="New-Scan-無法點擊"><a href="#New-Scan-無法點擊" class="headerlink" title="New Scan 無法點擊"></a>New Scan 無法點擊</h2><p>需要等待Plugins編譯完或者參考<a href="https://www.cnblogs.com/netsa/p/15597136.html">nessus 启动后 Compiling plugins…卡在这里故障处理</a></p>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10268209">系統弱點掃描工具-Tenable Nessus(上)</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1927126">Docker搭建Nessus漏洞扫描器</a></li>
<li><a href="https://www.cnblogs.com/netsa/p/15597136.html">nessus 启动后 Compiling plugins…卡在这里故障处理</a></li>
<li><a href="https://blog.csdn.net/SwTesting/article/details/133899949">Nessus已激活，New Scan按钮不可点击</a></li>
</ul>
]]></content>
      <categories>
        <category>資安</category>
      </categories>
      <tags>
        <tag>Nessus</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>PWM(Pulse-width modulation)</title>
    <url>/posts/20231118194600-68d2e719.html</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p><img src="/images/20231119023727.png"><br>是將脈波轉為類比信號的“一種技術”,利用在頻率不變的狀態下, 改變占空比大小, 使整體平均電壓值上升或下降, 藉此間歇性電壓及功率切換以節省能源及控制等效果.</p>
<h1 id="Period-週期"><a href="#Period-週期" class="headerlink" title="Period 週期"></a>Period 週期</h1><p>通常週期固定然後調整占空比</p>
<h1 id="Duty-Circle-占空比"><a href="#Duty-Circle-占空比" class="headerlink" title="Duty Circle(占空比)"></a>Duty Circle(占空比)</h1><p>100%代表有1個clock有百分之100是高電平 平均電壓為 5V<em>1 &#x3D; 5V<br> <span id="more"></span><br> 75%代表有1個clock有百分之75是高電平 平均電壓為 5V</em>0.75 &#x3D; 3.75V<br>25%代表有1個clock有百分之25是高電平 平均電壓為 3V<em>0.25 &#x3D; 2.25V<br>0%代表有1個clock有百分之0是高電平 平均電壓為 3V</em>0 &#x3D; 0V<br>藉由控制占空比可以控制平均電壓 控制功率 可以控制燈的亮度 馬達轉速</p>
<h1 id="範例-WS2812B"><a href="#範例-WS2812B" class="headerlink" title="範例 WS2812B"></a>範例 WS2812B</h1><h2 id="WS2812B-PWM-如果是單純用PWM用IO的方法控制duty-cycle無法控制到每個bit"><a href="#WS2812B-PWM-如果是單純用PWM用IO的方法控制duty-cycle無法控制到每個bit" class="headerlink" title="WS2812B PWM 如果是單純用PWM用IO的方法控制duty_cycle無法控制到每個bit"></a>WS2812B PWM 如果是單純用PWM用IO的方法控制duty_cycle無法控制到每個bit</h2><p>period &#x3D; 800Khz 1&#x2F;800000 &#x3D; 1250 ns<br>duty cycle 33% <code>1250*0.333 = 412.5</code> 0 碼<br>duty cycle 67% <code>1250*0.666 = 825</code> 1 碼<br>ws2812 复位信号为一个 不低于 50us</p>
<h3 id="注册该pwm通道"><a href="#注册该pwm通道" class="headerlink" title="注册该pwm通道"></a>注册该pwm通道</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /sys/class/pwm/pwmchip0/npwm</span><br><span class="line">echo 0 &gt; /sys/class/pwm/pwmchip0/export</span><br></pre></td></tr></table></figure>
<h3 id="設定週期-ns"><a href="#設定週期-ns" class="headerlink" title="設定週期(ns)"></a>設定週期(ns)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1250 &gt; /sys/class/pwm/pwmchip0/pwm0/period</span><br></pre></td></tr></table></figure>
<h3 id="設定duty-cycle-ns"><a href="#設定duty-cycle-ns" class="headerlink" title="設定duty cycle(ns)"></a>設定duty cycle(ns)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 825 &gt; /sys/class/pwm/pwmchip0/pwm0/duty_cycle</span><br></pre></td></tr></table></figure>

<h3 id="開燈"><a href="#開燈" class="headerlink" title="開燈"></a>開燈</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 825 &gt; /sys/class/pwm/pwmchip0/pwm0/duty_cycle</span><br><span class="line">echo 1 &gt; /sys/class/pwm/pwmchip0/pwm0/enable</span><br><span class="line">echo 0 &gt; /sys/class/pwm/pwmchip0/pwm0/enable</span><br></pre></td></tr></table></figure>
<h3 id="關燈"><a href="#關燈" class="headerlink" title="關燈"></a>關燈</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 412 &gt; /sys/class/pwm/pwmchip0/pwm0/duty_cycle</span><br><span class="line">echo 1 &gt; /sys/class/pwm/pwmchip0/pwm0/enable</span><br><span class="line">echo 0 &gt; /sys/class/pwm/pwmchip0/pwm0/enable</span><br></pre></td></tr></table></figure>



<h1 id="參考影片"><a href="#參考影片" class="headerlink" title="參考影片"></a>參考影片</h1><ul>
<li><a href="https://www.youtube.com/watch?v=LCejYewAgwA">2.1.1脈衝寬度(PWM)基本介紹</a></li>
<li><a href="https://www.youtube.com/watch?v=27GkMk8ct0s">[Arduino 教學課程] 什麼！用pwm就能控制LED亮度？那個像是蚯蚓符號的東西原來有其他用意？來實作看看呼吸燈ㄅ 從零開始學Arduino #11</a></li>
</ul>
]]></content>
      <categories>
        <category>soc</category>
      </categories>
      <tags>
        <tag>PWM</tag>
        <tag>WS2812B</tag>
      </tags>
  </entry>
  <entry>
    <title>PeerConnection 連線過程</title>
    <url>/posts/20241224063000-40453b0a.html</url>
    <content><![CDATA[<h1 id="上圖"><a href="#上圖" class="headerlink" title="上圖"></a>上圖</h1><p><img src="/images/20241224132201.png"></p>
<h2 id="備註"><a href="#備註" class="headerlink" title="備註"></a>備註</h2><ol>
<li>上圖不完全是API的呼叫流程，讀者仍需要參考WebRTC的文件或原始碼註解。</li>
<li>先進入房間的使用者是發起方（ClientA），後進入房間的使用者是參與者（ClientB）。伺服器可以將它們與ICE伺服器位址一起傳回給參與者。</li>
<li>add streams 不是連接流程中的關鍵步驟，也可以在ICE流程之後再執行。 <span id="more"></span></li>
<li>通話雙方均與指定的ICE伺服器連線成功後，即可開始相互推流。</li>
<li>在多人會議服務端架構中，一般由SFU伺服器同時擔當ICE伺服器的角色。</li>
</ol>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://webrtc.mthli.com/connection/peer-connection/">PeerConnection 连接流程</a></li>
<li><a href="https://juejin.cn/post/6844904079102050311">WebRTC &gt;RTCPeerConnection-建立连接的全过程</a></li>
<li><a href="https://blog.csdn.net/lym594887256/article/details/124081420">WebRTC系列-WebRTC基础(四)连接建立时序图及运行机制</a></li>
<li><a href="https://blog.csdn.net/aggresss/article/details/106832965">WebRTC PeerConnection 建立连接过程介绍</a></li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>Python mt5 on macOS(M系列)</title>
    <url>/posts/20240130041500-3099daac.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接續之前<a href="/posts/20240126041500-7fb9c93d.html" title="Python mt5 on linux">Python mt5 on linux</a>已經可以在docker順利啟動mt5．前面這篇通常是部署在Server上，但是開發的時候又是拿Mac開發，決定要嘗試看看，現在要來在Mac M1 上面啟動，因為如果按造<a href="/posts/20240126041500-7fb9c93d.html" title="Python mt5 on linux">Python mt5 on linux</a>的話，會在docker起 vnc ，但好像沒有arm的版本，所以這次就不在docker上啟動了<br> <span id="more"></span></p>
<p>如果是linux 請參考<a href="/posts/20240126041500-7fb9c93d.html" title="Python mt5 on linux">Python mt5 on linux</a></p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ul>
<li>python3.9 </li>
<li>MacOS M系列</li>
</ul>
<h1 id="開始吧"><a href="#開始吧" class="headerlink" title="開始吧"></a>開始吧</h1><h2 id="上腳本"><a href="#上腳本" class="headerlink" title="上腳本"></a>上腳本</h2><p>感謝 <a href="https://github.com/gmag11/MetaTrader5-Docker-Image/blob/main/Metatrader/start.sh">MetaTrader5-Docker-Image</a>腳本幫助</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew tap gcenx/wine</span><br><span class="line">brew install --cask --no-quarantine wine-crossover</span><br><span class="line"><span class="keyword">if</span> [ ! -e ~/.wine ]; <span class="keyword">then</span></span><br><span class="line">  wineboot --init</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Configuration variables</span></span><br><span class="line">mt5file=~/.wine/drive_c/<span class="string">&quot;Program Files/MetaTrader 5/terminal64.exe&quot;</span></span><br><span class="line">wine_executable=<span class="string">&quot;wine&quot;</span></span><br><span class="line">metatrader_version=<span class="string">&quot;5.0.36&quot;</span></span><br><span class="line">mt5server_port=<span class="string">&quot;8001&quot;</span></span><br><span class="line">mono_url=<span class="string">&quot;https://dl.winehq.org/wine/wine-mono/8.0.0/wine-mono-8.0.0-x86.msi&quot;</span></span><br><span class="line">python_url=<span class="string">&quot;https://www.python.org/ftp/python/3.9.0/python-3.9.0.exe&quot;</span></span><br><span class="line">mt5setup_url=<span class="string">&quot;https://download.mql5.com/cdn/web/metaquotes.software.corp/mt5/mt5setup.exe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Function to display a graphical message</span></span><br><span class="line"><span class="function"><span class="title">show_message</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Function to check if a dependency is installed</span></span><br><span class="line"><span class="function"><span class="title">check_dependency</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> ! <span class="built_in">command</span> -v <span class="variable">$1</span> &amp;&gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$1</span> is not installed. Please install it to continue.&quot;</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Function to check if a Python package is installed</span></span><br><span class="line"><span class="function"><span class="title">is_python_package_installed</span></span>() &#123;</span><br><span class="line">    python3 -c <span class="string">&quot;import pkg_resources; exit(not pkg_resources.require(&#x27;<span class="variable">$1</span>&#x27;))&quot;</span> 2&gt;/dev/null</span><br><span class="line">    <span class="built_in">return</span> $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Function to check if a Python package is installed in Wine</span></span><br><span class="line"><span class="function"><span class="title">is_wine_python_package_installed</span></span>() &#123;</span><br><span class="line">    <span class="variable">$wine_executable</span> python -c <span class="string">&quot;import pkg_resources; exit(not pkg_resources.require(&#x27;<span class="variable">$1</span>&#x27;))&quot;</span> 2&gt;/dev/null</span><br><span class="line">    <span class="built_in">return</span> $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check for necessary dependencies</span></span><br><span class="line">check_dependency <span class="string">&quot;curl&quot;</span></span><br><span class="line">check_dependency <span class="string">&quot;<span class="variable">$wine_executable</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install Mono if not present</span></span><br><span class="line"><span class="keyword">if</span> [ ! -e ~/.wine/drive_c/windows/mono ]; <span class="keyword">then</span></span><br><span class="line">    show_message <span class="string">&quot;[1/7] Downloading and installing Mono...&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -f ~/.wine/drive_c/mono.msi ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">      wget -O ~/.wine/drive_c/mono.msi  <span class="variable">$mono_url</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    WINEDLLOVERRIDES=mscoree=d <span class="variable">$wine_executable</span> msiexec /i ~/.wine/drive_c/mono.msi /qn</span><br><span class="line">    show_message <span class="string">&quot;[1/7] Mono installed.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    show_message <span class="string">&quot;[1/7] Mono is already installed.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="string">&quot;<span class="variable">$mt5file</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    show_message <span class="string">&quot;[2/7] File <span class="variable">$mt5file</span> already exists.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    show_message <span class="string">&quot;[2/7] File <span class="variable">$mt5file</span> is not installed. Installing...&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set Windows 10 mode in Wine and download and install MT5</span></span><br><span class="line">    <span class="variable">$wine_executable</span> reg add <span class="string">&quot;HKEY_CURRENT_USER\\Software\\Wine&quot;</span> /v Version /t REG_SZ /d <span class="string">&quot;win10&quot;</span> /f</span><br><span class="line">    show_message <span class="string">&quot;[3/7] Downloading MT5 installer...&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -e ~/.wine/drive_c/mt5setup.exe ]; <span class="keyword">then</span></span><br><span class="line">      wget -O ~/.wine/drive_c/mt5setup.exe <span class="variable">$mt5setup_url</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    show_message <span class="string">&quot;[3/7] Installing MetaTrader 5...&quot;</span></span><br><span class="line">    <span class="variable">$wine_executable</span> ~/.wine/drive_c/mt5setup.exe <span class="string">&quot;/auto&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Recheck if MetaTrader 5 is installed</span></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="string">&quot;<span class="variable">$mt5file</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    show_message <span class="string">&quot;[4/7] File <span class="variable">$mt5file</span> is installed. Running MT5...&quot;</span></span><br><span class="line">    <span class="variable">$wine_executable</span> <span class="string">&quot;<span class="variable">$mt5file</span>&quot;</span> &amp;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    show_message <span class="string">&quot;[4/7] File <span class="variable">$mt5file</span> is not installed. MT5 cannot be run.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install Python in Wine if not present</span></span><br><span class="line"><span class="keyword">if</span> ! <span class="variable">$wine_executable</span> python --version 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    show_message <span class="string">&quot;[5/7] Installing Python in Wine...&quot;</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -f ~/.wine/drive_c/python-3.9.0.exe ]; <span class="keyword">then</span></span><br><span class="line">      wget -O ~/.wine/drive_c/python-3.9.0.exe <span class="variable">$python_url</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    <span class="variable">$wine_executable</span> ~/.wine/drive_c/python-3.9.0.exe /quiet InstallAllUsers=1 PrependPath=1</span><br><span class="line"></span><br><span class="line">    show_message <span class="string">&quot;[5/7] Python installed in Wine.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    show_message <span class="string">&quot;[5/7] Python is already installed in Wine.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Upgrade pip and install required packages</span></span><br><span class="line">show_message <span class="string">&quot;[6/7] Installing Python libraries&quot;</span></span><br><span class="line"><span class="variable">$wine_executable</span> python -m pip install --upgrade --no-cache-dir pip</span><br><span class="line"><span class="comment"># Install MetaTrader5 library in Windows if not installed</span></span><br><span class="line">show_message <span class="string">&quot;[6/7] Installing MetaTrader5 library in Windows&quot;</span></span><br><span class="line"><span class="keyword">if</span> ! is_wine_python_package_installed <span class="string">&quot;MetaTrader5==<span class="variable">$metatrader_version</span>&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="variable">$wine_executable</span> python -m pip install --no-cache-dir MetaTrader5==<span class="variable">$metatrader_version</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># Install mt5linux library in Windows if not installed</span></span><br><span class="line">show_message <span class="string">&quot;[6/7] Checking and installing mt5linux library in Windows if necessary&quot;</span></span><br><span class="line"><span class="keyword">if</span> ! is_wine_python_package_installed <span class="string">&quot;mt5linux&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="variable">$wine_executable</span> python -m pip install --no-cache-dir mt5linux</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install mt5linux library in Linux if not installed</span></span><br><span class="line">show_message <span class="string">&quot;[6/7] Checking and installing mt5linux library in Linux if necessary&quot;</span></span><br><span class="line"><span class="keyword">if</span> ! is_python_package_installed <span class="string">&quot;mt5linux&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    pip install --upgrade --no-cache-dir mt5linux</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Install pyxdg library in Linux if not installed</span></span><br><span class="line">show_message <span class="string">&quot;[6/7] Checking and installing pyxdg library in Linux if necessary&quot;</span></span><br><span class="line"><span class="keyword">if</span> ! is_python_package_installed <span class="string">&quot;pyxdg&quot;</span>; <span class="keyword">then</span></span><br><span class="line">    pip install --upgrade --no-cache-dir pyxdg</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start the MT5 server on Linux</span></span><br><span class="line">show_message <span class="string">&quot;[7/7] Starting the mt5linux server...&quot;</span></span><br><span class="line">python3 -m mt5linux --host 0.0.0.0 -p <span class="variable">$mt5server_port</span> -w <span class="variable">$wine_executable</span> python.exe &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Give the server some time to start</span></span><br><span class="line"><span class="built_in">sleep</span> 5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check if the server is running</span></span><br><span class="line"><span class="keyword">if</span>  lsof -n -i:<span class="variable">$mt5server_port</span> | grep LISTEN &gt; /dev/null; <span class="keyword">then</span></span><br><span class="line">    show_message <span class="string">&quot;[7/7] The mt5linux server is running on port <span class="variable">$mt5server_port</span>.&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    show_message <span class="string">&quot;[7/7] Failed to start the mt5linux server on port <span class="variable">$mt5server_port</span>.&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>這個腳本會判斷是否已經安裝，第一次安裝會比較久一點</p>
<h2 id="建立腳本"><a href="#建立腳本" class="headerlink" title="建立腳本"></a>建立腳本</h2><p>大家可以建立一個<code>start.sh</code> 的腳本 將上面的腳本程式複製進去</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立腳本</span></span><br><span class="line"><span class="built_in">touch</span> start.sh</span><br><span class="line"><span class="comment"># 編輯腳本 把上面的整坨貼進去</span></span><br><span class="line">vim start.sh</span><br><span class="line"><span class="comment"># 給 start.sh 執行權限</span></span><br><span class="line"><span class="built_in">chmod</span> +x start.sh</span><br><span class="line"><span class="comment"># 執行腳本</span></span><br><span class="line">bash start.sh</span><br></pre></td></tr></table></figure>
<h2 id="腳本會自動安裝下面的套件-根據設備能力不同時間也有所不同第一次啟動會花比較久時間"><a href="#腳本會自動安裝下面的套件-根據設備能力不同時間也有所不同第一次啟動會花比較久時間" class="headerlink" title="腳本會自動安裝下面的套件 (根據設備能力不同時間也有所不同第一次啟動會花比較久時間 )"></a>腳本會自動安裝下面的套件 (根據設備能力不同時間也有所不同第一次啟動會花比較久時間 )</h2><ul>
<li>wine (用來模擬window的環境)</li>
<li>mone (.NET框架)</li>
<li>python (在wine裡面安裝python)</li>
<li>mt5 (在wine裡面安裝mt5)</li>
<li>python packages (所需套件)</li>
</ul>
<h2 id="安裝完後-會直接開啟-MT5"><a href="#安裝完後-會直接開啟-MT5" class="headerlink" title="安裝完後 會直接開啟 MT5"></a>安裝完後 會直接開啟 MT5</h2><p><img src="/images/20240131121021.png"></p>
<h2 id="在自己的python上面安裝-mt5linux"><a href="#在自己的python上面安裝-mt5linux" class="headerlink" title="在自己的python上面安裝 mt5linux"></a>在自己的python上面安裝 mt5linux</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m pip install mt5linux==0.1.9</span><br></pre></td></tr></table></figure>
<h2 id="測試連線"><a href="#測試連線" class="headerlink" title="測試連線"></a>測試連線</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mt5linux <span class="keyword">import</span> MetaTrader5</span><br><span class="line">mt5 = MetaTrader5(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">8001</span>)</span><br><span class="line">mt5.initialize()</span><br><span class="line"><span class="built_in">print</span>(mt5.version())</span><br></pre></td></tr></table></figure>
<h1 id="附上流程"><a href="#附上流程" class="headerlink" title="附上流程"></a>附上流程</h1><p><img src="/images/20240131120931.png"></p>
<ul>
<li>GUI 顯示 wine 裡面的 MT5</li>
<li>從自己python 經過8001port 透過 rpyc 跟 wine 的 python 溝通</li>
</ul>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>感謝<a href="https://github.com/gmag11/MetaTrader5-Docker-Image/blob/main/Metatrader/start.sh">MetaTrader5-Docker-Image</a>腳本幫助，雖然沒用docker啟動，有可能會污染環境，但是在M系列上面順利執行，這樣開發也可以順利開發了。</p>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://github.com/gmag11/MetaTrader5-Docker-Image">MetaTrader5-Docker-Image</a></li>
<li><a href="https://www.mql5.com/zh/docs/python_metatrader5">python_metatrader5</a></li>
<li><a href="https://rpyc.readthedocs.io/en/latest/">rpyc</a></li>
<li><a href="https://pypi.org/project/mt5linux/">mt5linux</a></li>
<li><a href="https://blog.csdn.net/rjc_lihui/article/details/124053424">Mac M1 安装 wine 过程</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>MT5</tag>
        <tag>mac</tag>
        <tag>python</tag>
        <tag>rpyc</tag>
        <tag>vnc</tag>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>Python mt5 on linux</title>
    <url>/posts/20240126041500-7fb9c93d.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>因為客戶有需求，所以需要用python去控制mt5，但大多伺服器大多都是linux，起一台window的費用比起一台linux貴的很多，所以想要在linux跑mt5，今天介紹一個一個 github 專案<a href="https://github.com/gmag11/MetaTrader5-Docker-Image">MetaTrader5-Docker-Image</a></p>
<p>如果是Mac M系列 請參考<a href="/posts/20240130041500-3099daac.html" title="Python mt5 on macOS(M系列)">Python mt5 on macOS(M系列)</a><br> <span id="more"></span></p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><ul>
<li>python3.9</li>
<li>intelx86&#x2F;amd64  </li>
<li>docker</li>
</ul>
<h1 id="開始吧"><a href="#開始吧" class="headerlink" title="開始吧"></a>開始吧</h1><h2 id="先把專案-clone下來"><a href="#先把專案-clone下來" class="headerlink" title="先把專案 clone下來"></a>先把專案 clone下來</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/gmag11/MetaTrader5-Docker-Image.git</span><br></pre></td></tr></table></figure>
<h2 id="進入到資料夾內"><a href="#進入到資料夾內" class="headerlink" title="進入到資料夾內"></a>進入到資料夾內</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> MetaTrader5-Docker-Image</span><br></pre></td></tr></table></figure>
<h2 id="設定環境-可以更改帳號密碼"><a href="#設定環境-可以更改帳號密碼" class="headerlink" title="設定環境 可以更改帳號密碼"></a>設定環境 可以更改帳號密碼</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> .env.example .<span class="built_in">env</span></span><br><span class="line"><span class="comment">#UID=1000</span></span><br><span class="line"><span class="comment">#GID=1000</span></span><br><span class="line"><span class="comment">#CUSTOM_USER=username</span></span><br><span class="line"><span class="comment">#PASSWORD=securepassword</span></span><br></pre></td></tr></table></figure>
<h2 id="docker-compose-啟動"><a href="#docker-compose-啟動" class="headerlink" title="docker compose 啟動"></a>docker compose 啟動</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker compose up -d</span><br></pre></td></tr></table></figure>
<h2 id="腳本會自動安裝下面的套件-根據設備能力不同時間也有所不同第一次啟動會花比較久時間"><a href="#腳本會自動安裝下面的套件-根據設備能力不同時間也有所不同第一次啟動會花比較久時間" class="headerlink" title="腳本會自動安裝下面的套件 (根據設備能力不同時間也有所不同第一次啟動會花比較久時間 )"></a>腳本會自動安裝下面的套件 (根據設備能力不同時間也有所不同第一次啟動會花比較久時間 )</h2><ul>
<li>wine (用來模擬window的環境)</li>
<li>mone (.NET框架)</li>
<li>python (在wine裡面安裝python)</li>
<li>mt5 (在wine裡面安裝mt5)</li>
<li>python packages (所需套件)</li>
</ul>
<h2 id="安裝完後-在瀏覽器輸入localhost-3000"><a href="#安裝完後-在瀏覽器輸入localhost-3000" class="headerlink" title="安裝完後 在瀏覽器輸入localhost:3000"></a>安裝完後 在瀏覽器輸入<a href="localhost:3000">localhost:3000</a></h2><p><img src="/images/20240129104101.png"></p>
<h2 id="在自己的python上面安裝-mt5linux"><a href="#在自己的python上面安裝-mt5linux" class="headerlink" title="在自己的python上面安裝 mt5linux"></a>在自己的python上面安裝 mt5linux</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m pip install mt5linux==0.1.9</span><br></pre></td></tr></table></figure>
<h2 id="測試連線"><a href="#測試連線" class="headerlink" title="測試連線"></a>測試連線</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mt5linux <span class="keyword">import</span> MetaTrader5</span><br><span class="line">mt5 = MetaTrader5(host=<span class="string">&#x27;localhost&#x27;</span>,port=<span class="number">8001</span>)</span><br><span class="line">mt5.initialize()</span><br><span class="line"><span class="built_in">print</span>(mt5.version())</span><br></pre></td></tr></table></figure>
<h1 id="附上流程"><a href="#附上流程" class="headerlink" title="附上流程"></a>附上流程</h1><p><img src="/images/20240129102552.png"></p>
<ul>
<li>從瀏覽器訪問的時候是經過3000port 開啟 vnc 連到 mt5</li>
<li>從自己python 經過8001port 透過 rpyc 跟 wine 的 python 溝通</li>
</ul>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p>使用這個專案非常地輕鬆，設定好帳號密碼後只要將docker compose 拉起來，既不用污染環境也非常的快速，真的是非常好用，但是這適用於Intelx86或amd64，如果是Mac M1晶片無法起動成功，參考<a href="/posts/20240130041500-3099daac.html" title="Python mt5 on macOS(M系列)">Python mt5 on macOS(M系列)</a>．</p>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://github.com/gmag11/MetaTrader5-Docker-Image">MetaTrader5-Docker-Image</a></li>
<li><a href="https://www.mql5.com/zh/docs/python_metatrader5">python_metatrader5</a></li>
<li><a href="https://rpyc.readthedocs.io/en/latest/">rpyc</a></li>
<li><a href="https://pypi.org/project/mt5linux/">mt5linux</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>MT5</tag>
        <tag>python</tag>
        <tag>rpyc</tag>
        <tag>vnc</tag>
        <tag>wine</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>RTCP（Real-time Transport Control Protocol）</title>
    <url>/posts/20241224031200-ad213933.html</url>
    <content><![CDATA[<h3 id="RTCP-RTP-Control-Protocol-介紹"><a href="#RTCP-RTP-Control-Protocol-介紹" class="headerlink" title="RTCP (RTP Control Protocol) 介紹"></a>RTCP (RTP Control Protocol) 介紹</h3><p>RTCP（RTP Control Protocol）是與 RTP（Real-Time Transport Protocol）一起使用的協議，用於管理和監控多媒體數據的傳輸。它主要負責提供反饋機制，讓參與者能夠監控網絡性能，並協調實時應用程序的行為。</p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a><strong>主要功能</strong></h4><ol>
<li><p><strong>提供統計資訊</strong><br> RTCP 為參與者提供傳輸統計資訊（如丟包率、延遲和抖動等），幫助檢測網絡問題並評估性能。</p>
 <span id="more"></span>
</li>
<li><p><strong>同步多媒體流</strong><br> RTCP 可以幫助同步來自不同來源的多媒體流，例如音頻和視頻流，確保它們在接收端正確對齊。</p>
</li>
<li><p><strong>標識參與者</strong><br> RTCP 包含 CNAME（Canonical Name），用於標識會話中的參與者，方便處理多個流之間的對應關係。</p>
</li>
<li><p><strong>帶寬控制</strong><br> RTCP 使用一定比例的帶寬（通常是 RTP 數據流的 5%），以確保其不會過度佔用網絡資源。</p>
</li>
</ol>
<h4 id="RTCP-包結構"><a href="#RTCP-包結構" class="headerlink" title="RTCP 包結構"></a><strong>RTCP 包結構</strong></h4><p>RTCP 使用多種類型的報告包來實現其功能，主要包括：</p>
<ol>
<li><p><strong>SR（Sender Report）</strong></p>
<ul>
<li>由主動發送數據的參與者生成。</li>
<li>包括發送的數據包數量、字節數量和時間戳等資訊。</li>
</ul>
</li>
<li><p><strong>RR（Receiver Report）</strong></p>
<ul>
<li>由接收數據的參與者生成。</li>
<li>提供接收端的反饋信息，例如丟包率、抖動、延遲等。</li>
</ul>
</li>
<li><p><strong>SDES（Source Description Items）</strong></p>
<ul>
<li>用於標識參與者的元數據，如 CNAME（Canonical Name）、姓名和電子郵件等。</li>
</ul>
</li>
<li><p><strong>BYE（Goodbye）</strong></p>
<ul>
<li>用於通知其他參與者某個來源即將離開會話。</li>
</ul>
</li>
<li><p><strong>APP（Application-Specific Messages）</strong></p>
<ul>
<li>提供應用程序自定義的控制信息。</li>
</ul>
</li>
</ol>
<h4 id="RTCP-的工作流程"><a href="#RTCP-的工作流程" class="headerlink" title="RTCP 的工作流程"></a><strong>RTCP 的工作流程</strong></h4><ol>
<li>RTP 負責傳輸實時數據流，如音頻或視頻數據。</li>
<li>RTCP 定期發送控制消息，讓參與者了解網絡狀況和其他流的情況。</li>
<li>根據 RTCP 的統計和反饋，應用可以調整編碼參數、優化網絡使用或重新同步流。</li>
</ol>
<h4 id="RTCP-的應用場景"><a href="#RTCP-的應用場景" class="headerlink" title="RTCP 的應用場景"></a><strong>RTCP 的應用場景</strong></h4><ul>
<li><strong>WebRTC</strong>：在 WebRTC 中，RTCP 為實時音視頻會話提供網絡性能監控和同步支持。</li>
<li><strong>IPTV</strong>：在互聯網視頻廣播中，RTCP 協助監控網絡質量，保證用戶體驗。</li>
<li><strong>視頻會議系統</strong>：RTCP 用於多點視頻會議中的性能反饋和同步。</li>
</ul>
<h4 id="RTCP-與-RTP-的區別"><a href="#RTCP-與-RTP-的區別" class="headerlink" title="RTCP 與 RTP 的區別"></a><strong>RTCP 與 RTP 的區別</strong></h4><table>
<thead>
<tr>
<th>特性</th>
<th>RTP</th>
<th>RTCP</th>
</tr>
</thead>
<tbody><tr>
<td>功能</td>
<td>傳輸實時多媒體數據</td>
<td>管理和監控 RTP 傳輸</td>
</tr>
<tr>
<td>包類型</td>
<td>音視頻數據包</td>
<td>控制和反饋報告包</td>
</tr>
<tr>
<td>帶寬使用</td>
<td>主要佔用網絡帶寬</td>
<td>佔用 RTP 帶寬的 5%</td>
</tr>
<tr>
<td>例子</td>
<td>音頻數據、視頻數據</td>
<td>丟包率、延遲、同步信息</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>RTP（Real-time Transport Protocol）</title>
    <url>/posts/20241223094600-fcb5500e.html</url>
    <content><![CDATA[<p>RTP（Real-time Transport Protocol）是一个用于在互联网上传输实时音频和视频的网络传输协议。它被广泛用于流媒体、VoIP（网络电话）、视频会议等实时通信领域。以下是关于 RTP 的一些核心概念和特性：</p>
<hr>
<h3 id="1-RTP-的主要功能"><a href="#1-RTP-的主要功能" class="headerlink" title="1. RTP 的主要功能"></a><strong>1. RTP 的主要功能</strong></h3><ul>
<li><strong>数据传输</strong>：RTP 提供了一种实时传输音频和视频的机制，允许多媒体数据被分割成小的数据包进行传输。</li>
<li><strong>时间同步</strong>：RTP 使用时间戳（timestamp）来帮助接收端同步数据流，例如在音视频同步中至关重要。 <span id="more"></span></li>
<li><strong>序列号</strong>：每个 RTP 数据包都有一个序列号，用于检测丢包和重新排序。</li>
<li><strong>实时传输控制</strong>：通过 RTP 的控制协议（RTCP），实现网络状态监控和服务质量反馈。</li>
</ul>
<hr>
<h3 id="2-RTP-的协议栈"><a href="#2-RTP-的协议栈" class="headerlink" title="2. RTP 的协议栈"></a><strong>2. RTP 的协议栈</strong></h3><p>RTP 工作在传输层协议（通常是 UDP）之上，但它本身不提供传输可靠性：</p>
<ul>
<li><strong>应用层</strong>：负责具体的多媒体应用（如音频、视频编解码）。</li>
<li><strong>RTP 层</strong>：处理实时传输功能。</li>
<li><strong>传输层（通常为 UDP）</strong>：提供快速、低延迟的数据传输。</li>
</ul>
<hr>
<h3 id="3-RTP-数据包结构"><a href="#3-RTP-数据包结构" class="headerlink" title="3. RTP 数据包结构"></a><strong>3. RTP 数据包结构</strong></h3><p>一个 RTP 数据包通常包含以下字段：</p>
<ol>
<li><strong>版本号（Version）</strong>：标识 RTP 的版本，目前为 2。</li>
<li><strong>填充（Padding）</strong>：用于数据填充。</li>
<li><strong>扩展（Extension）</strong>：标识是否有额外的扩展头。</li>
<li><strong>标志位（CSRC Count）</strong>：标识 CSRC 标识符的数量。</li>
<li><strong>标记（Marker）</strong>：用于特定事件的标记。</li>
<li><strong>负载类型（Payload Type）</strong>：指示负载的类型（如音频或视频编码格式）。</li>
<li><strong>序列号（Sequence Number）</strong>：检测丢包和包重排序。</li>
<li><strong>时间戳（Timestamp）</strong>：同步媒体数据流。</li>
<li><strong>同步源标识符（SSRC）</strong>：标识流的源。</li>
<li><strong>贡献源标识符（CSRC）</strong>：标识贡献流的源（通常在混音场景中使用）。</li>
</ol>
<hr>
<h3 id="4-RTP-和-RTCP"><a href="#4-RTP-和-RTCP" class="headerlink" title="4. RTP 和 RTCP"></a><strong>4. RTP 和 RTCP</strong></h3><ul>
<li><strong>RTP（Real-time Transport Protocol）</strong>：<ul>
<li>主要负责实时数据的传输。</li>
<li>示例：音频和视频的编码数据包。</li>
</ul>
</li>
<li><strong>RTCP（RTP Control Protocol）</strong>：<ul>
<li>与 RTP 配合，用于提供控制信息。</li>
<li>提供以下功能：<ul>
<li><strong>QoS 反馈</strong>：提供关于网络状况的统计信息（如丢包率、抖动等）。</li>
<li><strong>参与者标识</strong>：通过 RTCP 包传输参与者的身份信息。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-RTP-的典型应用"><a href="#5-RTP-的典型应用" class="headerlink" title="5. RTP 的典型应用"></a><strong>5. RTP 的典型应用</strong></h3><ul>
<li><strong>VoIP（网络电话）</strong>：通过 RTP 传输语音数据。</li>
<li><strong>视频会议</strong>：支持多个音视频流的传输和同步。</li>
<li><strong>流媒体</strong>：如网络直播或点播系统。</li>
<li><strong>实时游戏</strong>：传输实时游戏中的音视频数据。</li>
</ul>
<hr>
<h3 id="6-RTP-的优缺点"><a href="#6-RTP-的优缺点" class="headerlink" title="6. RTP 的优缺点"></a><strong>6. RTP 的优缺点</strong></h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ul>
<li>适合实时数据传输。</li>
<li>支持多种负载类型（灵活性强）。</li>
<li>结合 RTCP 能提供服务质量监控。</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ul>
<li>不保证传输可靠性（依赖下层协议，如 UDP）。</li>
<li>无内置加密功能，需要其他协议（如 SRTP）增强安全性。</li>
</ul>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>SDP（Session Description Protocol, 会话描述协议）</title>
    <url>/posts/20241223074500-739a46ba.html</url>
    <content><![CDATA[<p>会话描述协议（SDP，Session Description Protocol）是一种用于多媒体通信的文本格式协议。它通常用于描述多媒体会话的参数，例如会议、语音或视频通话、ICE 服务器信息、音视频编码信息，以便参与方可以协商和建立通信。</p>
<h2 id="SDP-本身并不传输媒体数据，而是作为描述协议，与其他传输协议（如-RTP、RTCP-或-SIP）结合使用，以建立和管理会话。以下是-SDP-的一些关键点："><a href="#SDP-本身并不传输媒体数据，而是作为描述协议，与其他传输协议（如-RTP、RTCP-或-SIP）结合使用，以建立和管理会话。以下是-SDP-的一些关键点：" class="headerlink" title="SDP 本身并不传输媒体数据，而是作为描述协议，与其他传输协议（如 RTP、RTCP 或 SIP）结合使用，以建立和管理会话。以下是 SDP 的一些关键点： 
 "></a>SDP 本身并不传输媒体数据，而是作为描述协议，与其他传输协议（如 RTP、RTCP 或 SIP）结合使用，以建立和管理会话。以下是 SDP 的一些关键点：<br> <span id="more"></span>
 </h2><h3 id="核心功能"><a href="#核心功能" class="headerlink" title="核心功能"></a><strong>核心功能</strong></h3><ol>
<li><strong>会话描述：</strong> 描述会话的基本信息（例如名称、时间、地点）。</li>
<li><strong>媒体信息：</strong> 指定会话中涉及的媒体类型（音频、视频等）、传输协议（如 RTP）和编码格式（如 H.264、Opus）。</li>
<li><strong>网络地址：</strong> 提供媒体传输所需的 IP 地址和端口。</li>
<li><strong>能力协商：</strong> 描述参与方的媒体能力，便于协商。</li>
</ol>
<hr>
<h3 id="SDP-的结构"><a href="#SDP-的结构" class="headerlink" title="SDP 的结构"></a><strong>SDP 的结构</strong></h3><p>SDP 的结构由多行键值对组成，每行的格式为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;键&gt;=&lt;值&gt;&lt;CR&gt;&lt;LF&gt;</span><br></pre></td></tr></table></figure>
<p>&lt;键&gt;&#x3D;&lt;值&gt;大小寫敏感 且&#x3D;之間不能有空白</p>
<ul>
<li><code>&lt;键&gt;</code> : 為單一小寫單字，代表特定屬性</li>
<li><code>&lt;值&gt;</code> : 一串與屬性有關的結構化文字描述，UTF-8編碼。</li>
</ul>
<h4 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a><strong>常见字段</strong></h4><p>整個SDP內容主要會由<code>Session description</code>、<code>Time description</code>、<code>Media description</code> 這三大類組成，<br>每個信息可能會包含多個<code>Time description</code>、<code>Media description</code>資訊。</p>
<h5 id="Session-description"><a href="#Session-description" class="headerlink" title="Session description"></a>Session description</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v=  (protocol version number, currently only 0)</span><br><span class="line">   o=  (originator and session identifier : username, id, version number, network address)</span><br><span class="line">   s=  (session name : mandatory with at least one UTF-8-encoded character)</span><br><span class="line">   i=* (session title or short information)</span><br><span class="line">   u=* (URI of description)</span><br><span class="line">   e=* (zero or more email address with optional name of contacts)</span><br><span class="line">   p=* (zero or more phone number with optional name of contacts)</span><br><span class="line">   c=* (connection information—not required if included in all media)</span><br><span class="line">   b=* (zero or more bandwidth information lines)</span><br><span class="line">   _One or more **time descriptions** (&quot;t=&quot; and &quot;r=&quot; lines; see [below](https://en.wikipedia.org/wiki/Session_Description_Protocol#Time_description))_</span><br><span class="line">   z=* (time zone adjustments)</span><br><span class="line">   k=* (encryption key)</span><br><span class="line">   a=* (zero or more session attribute lines)</span><br><span class="line">   _Zero or more **Media descriptions** (each one starting by an &quot;m=&quot; line; see [below](https://en.wikipedia.org/wiki/Session_Description_Protocol#Media_description))_</span><br></pre></td></tr></table></figure>
<h5 id="Time-description-mandatory-強制"><a href="#Time-description-mandatory-強制" class="headerlink" title="Time description(mandatory 強制)"></a>Time description(mandatory 強制)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">t=  (time the session is active)</span><br><span class="line">r=* (zero or more repeat times)</span><br></pre></td></tr></table></figure>
<h5 id="Media-description-optional"><a href="#Media-description-optional" class="headerlink" title="Media description (optional)"></a>Media description (optional)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">m=  (media name and transport address)</span><br><span class="line">i=* (media title or information field)</span><br><span class="line">c=* (connection information — optional if included at session level)</span><br><span class="line">b=* (zero or more bandwidth information lines)</span><br><span class="line">k=* (encryption key)</span><br><span class="line">a=* (zero or more media attribute lines — overriding the Session attribute lines)</span><br></pre></td></tr></table></figure>
<h4 id="示例-SDP-文件"><a href="#示例-SDP-文件" class="headerlink" title="示例 SDP 文件"></a><strong>示例 SDP 文件</strong></h4><p>以下是一个简单的 SDP 示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v=0</span><br><span class="line">o=- 2890844526 2890842807 IN IP4 192.168.1.10</span><br><span class="line">s=Example</span><br><span class="line">c=IN IP4 203.0.113.1</span><br><span class="line">t=0 0</span><br><span class="line">m=audio 49170 RTP/AVP 0</span><br><span class="line">a=rtpmap:0 PCMU/8000</span><br><span class="line">m=video 51372 RTP/AVP 96</span><br><span class="line">a=rtpmap:96 H264/90000</span><br></pre></td></tr></table></figure>
<h3 id="SDP-的用途"><a href="#SDP-的用途" class="headerlink" title="SDP 的用途"></a><strong>SDP 的用途</strong></h3><ol>
<li><strong>SIP 会话：</strong> 在 VoIP 系统中，SDP 与 SIP 配合，传递会话描述信息。</li>
<li><strong>WebRTC：</strong> 用于浏览器之间的实时通信，协商音视频参数。</li>
<li><strong>多媒体广播：</strong> 描述视频会议或流媒体会话。</li>
</ol>
<hr>
<h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a><strong>扩展</strong></h3><p>虽然 SDP 是一种标准化协议，但不同应用可能需要扩展一些属性。例如，WebRTC 定义了额外的 SDP 属性用于描述数据通道和 NAT 穿越技术。</p>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>SDP 就是規範描述多媒體通信的格式，使用key,value作為結構<br>只是單單的格式定義 不包含媒體傳輸</p>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>SparkFun Thing Plus Matter - MGM240P</title>
    <url>/posts/20231118184600-2b622287.html</url>
    <content><![CDATA[<h1 id="SparkFun-Thing-Plus-Matter-MGM240P"><a href="#SparkFun-Thing-Plus-Matter-MGM240P" class="headerlink" title="SparkFun Thing Plus Matter - MGM240P"></a><a href="https://www.sparkfun.com/products/20270">SparkFun Thing Plus Matter - MGM240P</a></h1><h1 id="安裝-Simplicity-Studio-5"><a href="#安裝-Simplicity-Studio-5" class="headerlink" title="安裝 Simplicity Studio 5"></a>安裝 Simplicity Studio 5</h1><p>先下載<a href="https://www.silabs.com/developers/simplicity-studio">simplicity-studio</a>並安裝(防毒軟體先關掉)</p>
<p><img src="/images/rJPmOAx7T.png"><br> <span id="more"></span><br> <img src="/images/rkeBu0em6.png"><br><img src="/images/rJMUOAgmT.png"><br><img src="/images/H19PO0x7a.png"><br>一直下一步，安裝到預設路徑即可 安裝完會自動打開<br><img src="/images/H1kFFAxXp.png"><br>同意並繼續<br><img src="/images/r1NhtAxQ6.png"><br>登入silabs的帳戶，免費辦一個<br>登入後會安裝驅動 輸入Admin帳號密碼安裝<br><img src="/images/HkqDc0xX6.png"><br>點擊Intall 點擊Intall by Connecting devices<br><img src="/images/Hy4oqAlQ6.png"><br>現在沒有裝置 接入USB<br><img src="/images/B1vJiAlXa.png"><br>接入USB 會需要安裝驅動板子套件按下Yes<br><img src="/images/HyS8sRxm6.png"><br>選擇板子 Next<br><img src="/images/BJROsCxmp.png"><br>選擇Auto Next<br><img src="/images/H1T3oCeQ6.png"><br>同意安裝套件 Next<br><img src="/images/ByHS2Aema.png"><br>會裝一些無線套件(geoko sdk)之類的(大約跑30分鐘)<br><img src="/images/HJYMgkbmp.png"><br>重開 Simplicity Studio<br><img src="/images/Byv9xyZmp.png"></p>
<blockquote>
<p>** 系統會提示更新 Adapter FW<br>不要更新保持這個1v4p9b113版本<br>(1.4.12.18刷進去會失敗，辯識會有問題，會變磚)**</p>
</blockquote>
<h1 id="更新版子-Adapter-Firmware-跳過"><a href="#更新版子-Adapter-Firmware-跳過" class="headerlink" title="更新版子 Adapter Firmware (跳過)"></a>更新版子 Adapter Firmware (跳過)</h1><p>更新版子參考 <a href="https://community.silabs.com/s/article/how-to-update-the-firmware-on-your-starter-kit-board">How to update the Firmware on your Starter Kit board</a><br>更新版子變磚參考 <a href="https://community.silabs.com/s/article/recover-efm32-or-efm8-kit-that-was-bricked-during-firmware-upgrade">Recover EFM32 or EFM8 kit that was bricked during firmware upgrade</a></p>
<blockquote>
<p> SparkFun Thing Plus Matter 曾經升到1.4.12.18，但失敗變磚，要退版本但是進入boot mode 的方法上面試不出來，最後是不知道怎麼又可以辨識出來(有可能是用手壓住後面的腳位接入USB，陰錯陽差進到 boot mode)，然後降版</p>
</blockquote>
<h1 id="簡單的範例-Blink-Example"><a href="#簡單的範例-Blink-Example" class="headerlink" title="簡單的範例 Blink Example"></a>簡單的範例 <a href="https://learn.sparkfun.com/tutorials/sparkfun-thing-plus-matter---mgm240p-hookup-guide/all#blink-example">Blink Example</a></h1><p>這個範例是一個會閃的燈<br><img src="/images/SJeZ176.png"><br>File &gt;&gt; New &gt;&gt; Silicon Labs Project Wizard<br>Target Boards: Sparkfun Thing Plus MGM240P (BRD2704A Rev A00)<br>Target Device: mgm240pb32vna<br>SDK: Deoko SDK Suite<br>IDE&#x2F;Toolchain: Simplicity IDE<br>點擊 Next<br><img src="/images/Hy9YGyZXp.png"><br>搜尋 blink 點擊 Platform - Blink Bare-mental<br>點擊 Next<br><img src="/images/HkO1XyZQa.png"><br>點擊 Finish<br><img src="/images/BkGX1b7T.png"><br><img src="/images/rJHA71WQT.png"><br>編譯並寫入板子<br><img src="/images/HkiX4ybX6.png"><br>編譯無錯誤 正常寫入板子後可看到燈會不斷閃爍<br><img src="/images/SyC7ByZQa.jpg"><br><img src="/images/S1vES1bmT.jpg"><br>可以到blink.c裡面的 TOOGLE_DELAY_MS 更改閃爍時間</p>
<h2 id="參考影片"><a href="#參考影片" class="headerlink" title="參考影片"></a>參考影片</h2><ul>
<li><a href="https://www.youtube.com/watch?v=POVRRuVCr-Q">Get Started with Simplicity Studio and the Thing Plus Matter Board</a></li>
</ul>
<h1 id="NCP-模式"><a href="#NCP-模式" class="headerlink" title="NCP 模式"></a>NCP 模式</h1><p><img src="/images/S1O4zC76.png"></p>
<blockquote>
<p>這裡Demo會要創立三個專案，目的是要創建Zigbee網路</p>
</blockquote>
<h2 id="創建-Bootloader-NCP-UART-XMODEM-專案"><a href="#創建-Bootloader-NCP-UART-XMODEM-專案" class="headerlink" title="創建 Bootloader - NCP UART XMODEM 專案"></a>創建 Bootloader - NCP UART XMODEM 專案</h2><p><img src="/images/SJeZ176.png"><br>File &gt;&gt; New &gt;&gt; Silicon Labs Project Wizard<br>Target Boards: Sparkfun Thing Plus MGM240P (BRD2704A Rev A00)<br>Target Device: mgm240pb32vna<br>SDK: Deoko SDK Suite<br>IDE&#x2F;Toolchain: Simplicity IDE<br>點擊 Next<br><img src="/images/By9Mw1mp.png"><br>點擊 Bootloader - NCP UART XMODEM<br>點擊 Next<br><img src="/images/BkaUwkb7T.png"><br>點擊 Finish<br><img src="/images/rJlydyXa.png"></p>
<h2 id="創建-Zigbee-NCP-ncp-uart-hw-專案"><a href="#創建-Zigbee-NCP-ncp-uart-hw-專案" class="headerlink" title="創建 Zigbee - NCP ncp-uart-hw 專案"></a>創建 Zigbee - NCP ncp-uart-hw 專案</h2><p><img src="/images/SJeZ176.png"><br>File &gt;&gt; New &gt;&gt; Silicon Labs Project Wizard<br>Target Boards: Sparkfun Thing Plus MGM240P (BRD2704A Rev A00)<br>Target Device: mgm240pb32vna<br>SDK: Deoko SDK Suite<br>IDE&#x2F;Toolchain: Simplicity IDE<br>點擊 Next<br><img src="/images/ry3LJbX6.png"><br>點擊 Zigbee - NCP ncp-uart-hw<br>點擊 Next<br><img src="/images/Sy39kW7a.png"><br>點擊 Finish</p>
<h2 id="創建-Zigbee-Host-Gatway-專案-在Linux上執行"><a href="#創建-Zigbee-Host-Gatway-專案-在Linux上執行" class="headerlink" title="創建 Zigbee - Host Gatway 專案 (在Linux上執行)"></a>創建 Zigbee - Host Gatway 專案 (在Linux上執行)</h2><p><img src="/images/ByLntyWX6.png"><br>File &gt;&gt; New &gt;&gt; Silicon Labs Project Wizard<br>Target Boards: Custom Board (可能會有點難點)<br>Target Device: Linux 64 bit<br>SDK: Deoko SDK Suite<br>IDE&#x2F;Toolchain: Makefile IDE<br>點擊 Next<br><img src="/images/ryakcyZmT.png"><br>點擊 Zigbee - Host Gateway<br>點擊 Next<br><img src="/images/HyKZ9J7p.png"><br>點擊 Finish</p>
<h2 id="燒入-Bootloader-NCP-UART-XMODEM"><a href="#燒入-Bootloader-NCP-UART-XMODEM" class="headerlink" title="燒入 Bootloader - NCP UART XMODEM"></a>燒入 Bootloader - NCP UART XMODEM</h2><p>燒入 Bootloader - NCP UART XMODEM 和 NCP ncp-uart-hw 要刷進板子裡面<br><img src="/images/Hyxny7a.png"><br>點擊專案 點擊槌子 進行編譯<br><img src="/images/Hy8f2yZma.png"><br>編譯成功完後 Binaries 出現 檔名為bootloader-uart-xmodem 的各種image<br>進行寫入動作<br><img src="/images/ryDL31WXp.png"><br>點擊Tools<br><img src="/images/HJt3kZQ6.png"><br>點擊Simplicity Commander 點擊ok<br><img src="/images/r1Wnn1WQp.png"><br>選擇Binary File <code>v5_workspace/bootloader-uart-xmodem/GNU ARM v10.3.1 - Default/bootloader-uart-xmodem.s37</code> 點擊 Flash<br><img src="/images/BJGlkeZXp.png"><br>log 顯示 Successfully<br><img src="/images/HJhC31Q6.png"><br>在Device Info 裡面的 MemoryMap 裡的 Flash Map 可以看到 Bootloader 占用兩個綠色區塊<br><img src="/images/SJaSJxZXa.png"><br>右鍵 Debug Adapter 選擇Launch Console<br><img src="/images/SkJsJxWm6.png"><br>Seial 1 會出現 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gecko Bootloader v2.03.02</span><br><span class="line">1. upload gbl</span><br><span class="line">2. run</span><br><span class="line">3. ebl info</span><br><span class="line">BL &gt; </span><br></pre></td></tr></table></figure>
<p>代表進入 Gecko Bootloader mode </p>
<blockquote>
<p>在還沒刷入 Application 會進入到 Gecko Bootloader mode<br>如果已經刷了 Application 則此處不會顯示任何東西</p>
</blockquote>
<h2 id="燒入-NCP-ncp-uart-hw"><a href="#燒入-NCP-ncp-uart-hw" class="headerlink" title="燒入 NCP ncp-uart-hw"></a>燒入 NCP ncp-uart-hw</h2><p><img src="/images/Hy0kxCQ6.png"><br>點擊ncp-uart-hw.slcp<br><img src="/images/BkgQlCWm6.png"><br>點擊Software Components<br><img src="/images/HJsvlRXa.png"><br>找到Service &gt;&gt; IO Stream &gt;&gt; Driver &gt;&gt; IO Stream: USART &gt;&gt; vcom<br>點擊 Congiure<br><img src="/images/HJY3e0Zm6.png"><br>將 Flow Control 改成 Software Flow control<br><img src="/images/HyScEaWm6.png"><br>點擊專案 點擊槌子 進行編譯<br><img src="/images/B107BT7p.png"><br>編譯成功完後 Binaries 出現 檔名為ncp-uart-hw 的各種image<br>進行寫入動作<br><img src="/images/ryDL31WXp.png"><br>點擊Tools<br><img src="/images/HJt3kZQ6.png"><br>點擊Simplicity Commander 點擊ok<br><img src="/images/Byb5rabmT.png"><br>選擇Binary File <code>v5_workspace/ncp-uart-hw/GNU ARM v10.3.1 - Default/ncp-uart-hw.s37</code> 點擊 Flash<br><img src="/images/S1CsrTZXp.png"><br>log 顯示 Successfully<br><img src="/images/S1mLITXa.png"><br>在Device Info 裡面的 MemoryMap 裡的 Flash Map 可以看到 Bootloader + ncp-uart-hw 的分布<br>Bootloader 從0x8000000開始<br>ncp-uart-hw 從0x8006000開始<br><img src="/images/SJaSJxZXa.png"><br>右鍵 Debug Adapter 選擇Launch Console<br><img src="/images/HJCWDabQ6.png"><br>Seial 1 不會顯示任何東西<br>代表進入 Application mode </p>
<h2 id="編譯-Zigbee-Host-Gateway-要用-Linux-編譯運行在-Linux-上"><a href="#編譯-Zigbee-Host-Gateway-要用-Linux-編譯運行在-Linux-上" class="headerlink" title="編譯 Zigbee - Host Gateway(要用 Linux 編譯運行在 Linux 上)"></a>編譯 Zigbee - Host Gateway(要用 Linux 編譯運行在 Linux 上)</h2><p><img src="/images/B11Aupb76.png"><br>cd 到專案底下<br><img src="/images/SJSjdpWXa.png"><br><code>gcc -v</code><br><img src="/images/r11lFaZmT.png"><br><code>make -f Z3Gateway.Makefile</code><br><img src="/images/HyhsKTZmT.png"><br>編譯完成<br><img src="/images/SyIW9pbXa.png"></p>
<h2 id="透過-Host-Gateway-控制-MCU-建立Zigbee-網路"><a href="#透過-Host-Gateway-控制-MCU-建立Zigbee-網路" class="headerlink" title="透過 Host Gateway 控制 MCU 建立Zigbee 網路"></a>透過 Host Gateway 控制 MCU 建立Zigbee 網路</h2><p><img src="/images/SJ0OqpZXp.png"><br>這裡選用Jlink OB 這也是帶有Serial Com Port 功能<br><img src="/images/H1Dhnama.png"><br>cd 到 程式所在地<br><img src="/images/HkPfpabQ6.png"><br><code>./Z3Gateway -f x -b 115200 -p  /dev/ttyACM0</code><br><img src="/images/S1aSTT76.png"><br>直接輸入info<br><img src="/images/rJXOpTWQp.png"><br>可以看到當前狀態 nodeId PanId xpan …. 接下來就是建立網路<br><img src="/images/HJPg067a.png"><br><code>network leave</code> 先離開網路<br><img src="/images/r1P5A6WQT.png"><br><code>plugin network-creator start 1</code> 成功會看到 EMBER_NETWORK_UP 0x0000 的字眼<br><img src="/images/SyBRAT7T.png"><br>再輸入info 可以看到當前狀態 nodeId PanId xpan …. 網路已經建立好了<br><img src="/images/Sy8Iy0Wma.png"><br><code>plugin network-creator-security open-network</code> 讓其他設備加入</p>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug235-09-developing-ncp-apps-with-connect.pdf">UG235.09: Developing NCP Applications with Silicon Labs Connect v2.x</a></li>
<li><a href="https://www.silabs.com/documents/public/application-notes/an1320-customized-ncp-zigbee7.pdf">Building a Customized NCP Application with Zigbee EmberZNet 7.x</a></li>
<li><a href="https://www.silabs.com/documents/public/application-notes/an706-ezsp-uart-host-interfacing-guide.pdf">EZSP-UART Host Interfacing Guide</a></li>
<li><a href="https://blog.csdn.net/lshddd/article/details/115458007">基于芯科Host-NCP解决方案的Zigbee 3.0 Gateway技术研究（-）-Z3GatewayHost应用</a></li>
<li><a href="https://blog.csdn.net/qq_42860989/article/details/125909875">在Cygwin环境下构建和使用EmberZNet PRO Zigbee Host应用程序</a></li>
<li><a href="https://github.com/SiliconLabs/managed-zigbee-gateway/blob/master/README.md">managed-zigbee-gateway&#x2F;README.md</a></li>
<li><a href="https://blog.csdn.net/qq_42992084/article/details/104761474">UART串口流控制（Flow control）</a></li>
<li><a href="https://community.silabs.com/s/question/0D51M00007xeQUSSA2/how-to-verify-the-normal-operation-of-ncp?language=zh_TW">How to Verify the Normal Operation of NCP？</a></li>
</ul>
<h2 id="參考影片-1"><a href="#參考影片-1" class="headerlink" title="參考影片"></a>參考影片</h2><ul>
<li><a href="https://www.bilibili.com/video/BV1nM4y1g755/">Day1-4-EmberZnet SDK的Bootloader和OTA配置详解</a></li>
<li><a href="https://www.bilibili.com/video/BV1fv411y7cq/">Day 1-2_EmberZnet协议栈介绍及开发工具AppBuilder介绍 (1)</a></li>
<li><a href="https://www.bilibili.com/video/BV1bT4y1w7EJ">Day 3-1 Zigbee 3.0 RTOS网关介绍</a></li>
<li><a href="https://www.youtube.com/watch?v=EP96d_ps4vg&ab_channel=CUSTCourses">10-01 何謂bootloader</a></li>
<li><a href="https://www.youtube.com/watch?v=njFxwNoPbkc">ARM Bootloader开发-1.bootloader概述1</a></li>
</ul>
<h1 id="Soc-模式-以Zigbee-Soc-Switch-為例-將裝置修改為Coordinator並且建立Zigbee網路"><a href="#Soc-模式-以Zigbee-Soc-Switch-為例-將裝置修改為Coordinator並且建立Zigbee網路" class="headerlink" title="Soc 模式 (以Zigbee - Soc Switch 為例 將裝置修改為Coordinator並且建立Zigbee網路)"></a>Soc 模式 (以Zigbee - Soc Switch 為例 將裝置修改為Coordinator並且建立Zigbee網路)</h1><h2 id="創建-Bootloader-Soc-Internal-Storage-專案"><a href="#創建-Bootloader-Soc-Internal-Storage-專案" class="headerlink" title="創建 Bootloader - Soc Internal Storage 專案"></a>創建 Bootloader - Soc Internal Storage 專案</h2><p><img src="/images/SJeZ176.png"><br>File &gt;&gt; New &gt;&gt; Silicon Labs Project Wizard<br>Target Boards: Sparkfun Thing Plus MGM240P (BRD2704A Rev A00)<br>Target Device: mgm240pb32vna<br>SDK: Deoko SDK Suite<br>IDE&#x2F;Toolchain: Simplicity IDE<br>點擊 Next<br><img src="/images/HyWccAWX6.png"><br>點擊 Bootloader - Soc Internal Storage (1536kB)<br>點擊 Next<br><img src="/images/r1xiqRbX6.png"><br>點擊 Finish</p>
<h2 id="創建-Zigbee-Soc-Switch-專案"><a href="#創建-Zigbee-Soc-Switch-專案" class="headerlink" title="創建 Zigbee - Soc Switch 專案"></a>創建 Zigbee - Soc Switch 專案</h2><p><img src="/images/SJeZ176.png"><br>File &gt;&gt; New &gt;&gt; Silicon Labs Project Wizard<br>Target Boards: Sparkfun Thing Plus MGM240P (BRD2704A Rev A00)<br>Target Device: mgm240pb32vna<br>SDK: Deoko SDK Suite<br>IDE&#x2F;Toolchain: Simplicity IDE<br>點擊 Next<br><img src="/images/HJKFCXT.png"><br>點擊 Zigbee - Soc Switch<br>點擊 Next<br><img src="/images/B1vXqRZXp.png"><br>點擊 Finish</p>
<h2 id="修改-Zigbee-Soc-Switch-專案設定-Part1"><a href="#修改-Zigbee-Soc-Switch-專案設定-Part1" class="headerlink" title="修改 Zigbee - Soc Switch 專案設定 Part1"></a>修改 Zigbee - Soc Switch 專案設定 Part1</h2><p><img src="/images/B17oiRWma.png"><br>點擊 Z3Switch.slcp<br><img src="/images/BkgQlCWm6.png"><br>點擊Software Components<br><img src="/images/r120sCZm6.png"><br>找到Platform &gt;&gt; Driver &gt;&gt; Button &gt;&gt; Simple Button &gt;&gt; bt1<br>點擊 Congiure<br><img src="/images/HyIm2C7p.png"><br>修改 SL_SIMPLE_BUTTON_BTN1 先隨便選一個</p>
<p>再修改<br>找到Service &gt;&gt; IO Stream &gt;&gt; Driver &gt;&gt; IO Stream: USART &gt;&gt; vcom<br>將 Flow Control 改成 Software Flow control</p>
<h2 id="分別燒入-Bootloader-Soc-Internal-Storage-和-Zigbee-Soc-Switch"><a href="#分別燒入-Bootloader-Soc-Internal-Storage-和-Zigbee-Soc-Switch" class="headerlink" title="分別燒入 Bootloader - Soc Internal Storage 和 Zigbee - Soc Switch"></a>分別燒入 Bootloader - Soc Internal Storage 和 Zigbee - Soc Switch</h2><p>參考上面燒入<br><img src="/images/rkD2zJMQT.png"><br>打開console seral 1  可以看到 &gt; Z3Switch 輸入info 看資訊<br>此時不能建立網路 因為現在裝置類型是End Device 而且 創建網路需要增加plugin</p>
<h2 id="修改-Zigbee-Soc-Switch-專案設定-Part2"><a href="#修改-Zigbee-Soc-Switch-專案設定-Part2" class="headerlink" title="修改 Zigbee - Soc Switch 專案設定 Part2"></a>修改 Zigbee - Soc Switch 專案設定 Part2</h2><p>修改<br>找到 Zigbee &gt;&gt; Utility &gt;&gt; Zigbee Device Config<br>將 Primary Network Device Type 改成 Coordonator or Router</p>
<p>找到 Zigbee &gt;&gt; Stack &gt;&gt; Pro Stack &gt;&gt; Pro Leaf Stack<br>將他 Uninstall</p>
<p>找到 Zigbee &gt;&gt; Stack &gt;&gt; Pro Stack &gt;&gt; Pro Stack<br>將他 install</p>
<p>找到 Zigbee &gt;&gt; Utility &gt;&gt; End Device Support<br>將他 Uninstal</p>
<p>找到 Zigbee &gt;&gt; Zigbee3.0 &gt;&gt; Network Creator<br>將他 install</p>
<h2 id="燒入-Zigbee-Soc-Switch-Part2"><a href="#燒入-Zigbee-Soc-Switch-Part2" class="headerlink" title="燒入 Zigbee - Soc Switch Part2"></a>燒入 Zigbee - Soc Switch Part2</h2><p>參考上面燒入<br><img src="/images/r1aTByf7p.png"><br><code>network leave</code><br><img src="/images/B1xGUkGma.png"><br><code>plugin network-creator start 1</code><br><img src="/images/SyBNIyfQa.png"><br><code>info</code> 可以看到當前狀態 nodeId PanId xpan …. 網路已經建立好了<br>之後再輸入<code>plugin network-creator-security open-network</code> 讓其他設備加入</p>
<h1 id="用-Bootloader-NCP-UART-XMODEM-刷-Application"><a href="#用-Bootloader-NCP-UART-XMODEM-刷-Application" class="headerlink" title="用 Bootloader - NCP UART XMODEM 刷 Application"></a>用 Bootloader - NCP UART XMODEM 刷 Application</h1><p><img src="/images/H1RwPNGXT.png"></p>
<h2 id="製作專門給-gecko-bootloader-用的-gbl檔案"><a href="#製作專門給-gecko-bootloader-用的-gbl檔案" class="headerlink" title="製作專門給 gecko bootloader 用的 gbl檔案"></a>製作專門給 gecko bootloader 用的 gbl檔案</h2><p><img src="/images/Hk5bbfM76.png"><br><code>.\commander.exe gbl create ncp-uart-hw.gbl  --app ncp-uart-hw.s37</code> </p>
<h2 id="進入-geoko-bootloader-模式"><a href="#進入-geoko-bootloader-模式" class="headerlink" title="進入 geoko bootloader 模式"></a>進入 geoko bootloader 模式</h2><p><img src="/images/B1glHMGma.jpg"><br>讓板子進入geoko bootloader 模式 預設是PC00接地，接上電源<br>如果沒有Application是直接進入到bootloader模式</p>
<p><img src="/images/Bkpk8fGQp.png"><br>用Tera Term 看 會出現 gecko bootloader v2.03.02 字眼 </p>
<h2 id="上傳-gbl-檔案"><a href="#上傳-gbl-檔案" class="headerlink" title="上傳 gbl 檔案"></a>上傳 gbl 檔案</h2><p><img src="/images/ry6nUMzXa.png"><br>此時Memory Map 裡面只有 bootloader</p>
<p><img src="/images/B14lwMGXp.png"><br>按1進入上傳模式 這裡會持續60s 如果沒有上傳檔案會恢復到Menu狀態</p>
<p><img src="/images/HkUmvzzXT.png"><br>點擊 File &gt;&gt; Transfer &gt;&gt; XMODEM &gt;&gt; Send…</p>
<p><img src="/images/Sy9owMzmT.png"><br>上傳中</p>
<p><img src="/images/Hk66PffX6.png"><br>上傳完顯示 Serial upload complete 這時還是在 bootloader 模式</p>
<p><img src="/images/SJwZMzQ6.png"><br>此時Memory Map 裡面只有 bootloader 和 Application</p>
<p><img src="/images/Hy0SdGzQT.png"><br>按下2 啟動Application 會出現一點亂碼</p>
<p><img src="/images/Syw9Mfm6.png"><br>啟動Application 後的 Memory Map 尾部會出現資料</p>
<h2 id="參考-1"><a href="#參考-1" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug489-gecko-bootloader-user-guide-gsdk-4.pdf">UG489: Silicon Labs Gecko Bootloader User’s Guide for GSDK 4.0 and Higher</a></li>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug162-simplicity-commander-reference-guide.pdf">UG162: Simplicity Commander Reference Guide</a></li>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug103-06-fundamentals-bootloading.pdf">Bootloading Fundamentals</a></li>
<li><a href="https://github.com/dsyx/emberznet-doc/blob/master/UG103.6/UG103.6.md">中文翻譯Bootloading Fundamentals</a></li>
<li><a href="https://github.com/dsyx/docs.silabs.com_zh/blob/master/docs/UG266%20Silicon%20Labs%20Gecko%20Bootloader%20User's%20Guide.md">UG266: Silicon Labs Gecko Bootloader User’s Guide (Rev. 1.5)</a></li>
</ul>
<h1 id="用-Bootloader-NCP-UART-XMODEM-更新-Bootloader"><a href="#用-Bootloader-NCP-UART-XMODEM-更新-Bootloader" class="headerlink" title="用 Bootloader - NCP UART XMODEM 更新 Bootloader"></a>用 Bootloader - NCP UART XMODEM 更新 Bootloader</h1><p><img src="/images/H1Wv54f7a.png"></p>
<blockquote>
<p>這裡更新Bootloader版本只能往上更新<br>編輯Bootloader版本設定  Bootloader Version Main Customer &gt;&gt; Bootloader Core</p>
</blockquote>
<h2 id="製作專門給-gecko-bootloader-用的-gbl檔案-1"><a href="#製作專門給-gecko-bootloader-用的-gbl檔案-1" class="headerlink" title="製作專門給 gecko bootloader 用的 gbl檔案"></a>製作專門給 gecko bootloader 用的 gbl檔案</h2><p><img src="/images/HkXtcNz7T.png"><br><code>.\commander.exe gbl create bootloader-uart-xmodem.gbl --bootloader bootloader-uart-xmodem.s37</code></p>
<h2 id="進入-geoko-bootloader-模式-1"><a href="#進入-geoko-bootloader-模式-1" class="headerlink" title="進入 geoko bootloader 模式"></a>進入 geoko bootloader 模式</h2><p><img src="/images/B1glHMGma.jpg"><br>讓板子進入geoko bootloader 模式 預設是PC00接地，接上電源<br>如果沒有Application是直接進入到bootloader模式</p>
<p><img src="/images/Bkpk8fGQp.png"><br>用Tera Term 看 會出現 gecko bootloader v2.03.02 字眼 </p>
<h2 id="上傳-gbl-檔案-1"><a href="#上傳-gbl-檔案-1" class="headerlink" title="上傳 gbl 檔案"></a>上傳 gbl 檔案</h2><p><img src="/images/B14lwMGXp.png"><br>按1進入上傳模式 這裡會持續60s 如果沒有上傳檔案會恢復到Menu狀態</p>
<p><img src="/images/HkUmvzzXT.png"><br>點擊 File &gt;&gt; Transfer &gt;&gt; XMODEM &gt;&gt; Send…</p>
<p><img src="/images/S199i4MXa.png"><br>上傳完顯示 Serial upload complete 這時還是在 bootloader 模式</p>
<p><img src="/images/rkN3sVzmp.png"><br>按 2 重新啟動 會出現 gecko bootloader v2.03.03 字眼 </p>
<h2 id="參考-2"><a href="#參考-2" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug489-gecko-bootloader-user-guide-gsdk-4.pdf">UG489: Silicon Labs Gecko Bootloader User’s Guide for GSDK 4.0 and Higher</a></li>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug162-simplicity-commander-reference-guide.pdf">UG162: Simplicity Commander Reference Guide</a></li>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug103-06-fundamentals-bootloading.pdf">Bootloading Fundamentals</a></li>
<li><a href="https://github.com/dsyx/emberznet-doc/blob/master/UG103.6/UG103.6.md">中文翻譯Bootloading Fundamentals</a></li>
<li><a href="https://github.com/dsyx/docs.silabs.com_zh/blob/master/docs/UG266%20Silicon%20Labs%20Gecko%20Bootloader%20User's%20Guide.md">UG266: Silicon Labs Gecko Bootloader User’s Guide (Rev. 1.5)</a></li>
</ul>
<h1 id="外接-UART-接法"><a href="#外接-UART-接法" class="headerlink" title="外接 UART 接法"></a>外接 UART 接法</h1><p>如果要走自己拉的 UTN401A + Ambar<br>最左邊要High 最右邊是Low 中間左到右分別是RX TX<br><code>H|_|RX|TX|_|G</code><br><img src="/images/rJpMMU7a.jpg"></p>
<ul>
<li><p>Zigbee - NCP ncp-uart-hw 專案<br>  Service &gt;&gt; IO Stream &gt;&gt; Driver &gt;&gt; IO Stream: USART &gt;&gt; vcom<br>  SL_IOSTREAM_USART_VCOM 變更 RX TX 腳位輸入輸出設定</p>
</li>
<li><p>Bootloader - NCP UART XMODEM 專案</p>
<ul>
<li>Platform &gt;&gt; Bootloader &gt;&gt; Drivers &gt;&gt; Bootloader UART Driver </li>
<li>SL_SERIAL_UART 變更 RX TX 腳位輸入輸出設定</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>zigbee</category>
      </categories>
      <tags>
        <tag>Zigbee</tag>
        <tag>MCU</tag>
        <tag>SOC</tag>
        <tag>SparkFun</tag>
        <tag>MGM240P</tag>
        <tag>simplicity-studio</tag>
        <tag>mgm240pb32vna</tag>
        <tag>silabs</tag>
      </tags>
  </entry>
  <entry>
    <title>TURN 協議（Traversal Using Relays around NAT）</title>
    <url>/posts/20241223040900-46d03228.html</url>
    <content><![CDATA[<p><strong>TURN（Traversal Using Relays around NAT）</strong> 是一種用於穿越 NAT（Network Address Translation）和防火牆的網絡協議，通常在實時通信應用中使用，例如視頻通話、即時消息和其他需要點對點連接的應用。通過<strong>中繼服務器轉發流量</strong>來解決這些問題</p>
<hr>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><strong>核心概念</strong></h3><ol>
<li><p><strong>背景：</strong></p>
<ul>
<li>NAT 和防火牆可能會阻止直接的點對點通信。</li>
</ul>
</li>
</ol>
 <span id="more"></span>
<pre><code> - &#123;% post_link  "STUN（ Session Traversal Utilities for NAT，NAT 穿越會話工具）" %&#125;有助於獲取公共 IP 和端口，但在某些情況下無法建立直接連接，例如雙重 NAT 或嚴格防火牆環境。
</code></pre>
<ol start="2">
<li><p><strong>解決方案：</strong></p>
<ul>
<li>TURN 通過<strong>中繼服務器轉發流量</strong>來解決這些問題，從而在無法建立直接連接時提供通信路徑。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h3><ol>
<li><p><strong>客戶端和 TURN 服務器交互：</strong></p>
<ul>
<li>客戶端向 TURN 服務器請求一個中繼地址（Relay Address）。</li>
<li>TURN 服務器分配一個臨時的公共 IP 和端口，充當中繼節點。</li>
</ul>
</li>
<li><p><strong>中繼通信：</strong></p>
<ul>
<li>之後的流量通過 TURN 服務器轉發。通信的一方將數據發送到 TURN 服務器，然後由 TURN 服務器轉發給另一方。</li>
</ul>
</li>
<li><p><strong>協議依賴：</strong></p>
<ul>
<li>TURN 使用 UDP 為主，但也支持 TCP 和 TLS（加密通道）。</li>
<li>TURN 協議由 RFC 5766 定義。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="應用場景"><a href="#應用場景" class="headerlink" title="應用場景"></a><strong>應用場景</strong></h3><ol>
<li><p><strong>WebRTC（Web Real-Time Communication）：</strong></p>
<ul>
<li>TURN 是 WebRTC 中必須的技術之一，與 STUN 配合使用，確保音視頻通信的可靠性。</li>
</ul>
</li>
<li><p><strong>高防火牆場景：</strong></p>
<ul>
<li>在企業網絡或高度限制的環境中，TURN 是唯一的解決方案。</li>
</ul>
</li>
<li><p><strong>NAT 穿越：</strong></p>
<ul>
<li>當 STUN 無法建立直接通信時，TURN 是備選方案。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="TURN-的限制"><a href="#TURN-的限制" class="headerlink" title="TURN 的限制"></a><strong>TURN 的限制</strong></h3><ol>
<li><p><strong>性能開銷：</strong></p>
<ul>
<li>TURN 流量經過服務器中繼，會帶來額外的延遲和服務器負載。</li>
</ul>
</li>
<li><p><strong>帶寬需求：</strong></p>
<ul>
<li>TURN 服務器需要足夠的帶寬來處理大量的數據流量。</li>
</ul>
</li>
<li><p><strong>部署成本：</strong></p>
<ul>
<li>運行和維護 TURN 服務器需要額外的基礎設施資源。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="TURN-和-STUN-的區別"><a href="#TURN-和-STUN-的區別" class="headerlink" title="TURN 和 STUN 的區別"></a><strong>TURN 和 STUN 的區別</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>STUN</th>
<th>TURN</th>
</tr>
</thead>
<tbody><tr>
<td><strong>用途</strong></td>
<td>發現公共 IP 和端口</td>
<td>提供中繼服務器轉發流量</td>
</tr>
<tr>
<td><strong>性能開銷</strong></td>
<td>較低</td>
<td>較高</td>
</tr>
<tr>
<td><strong>直連能力</strong></td>
<td>適用於大多數 NAT 環境</td>
<td>適用於無法直連的情況</td>
</tr>
</tbody></table>
<p>如果您想部署 TURN 服務器，常見的開源軟件包括 <a href="https://github.com/coturn/coturn">Coturn</a>。</p>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>UART RS232 RS484</title>
    <url>/posts/20231118193100-f5da1a51.html</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="# 介紹"></a># 介紹</h1><p>UART：<strong>全雙工、異步、串行傳輸</strong>，收發獨立，UART總線並沒有時鐘線，所以需要提前定義好對應的波特率，傳輸速度較慢，物理上4根線（VCC&#x2F;TX&#x2F;RX&#x2F;GND），雖然速度慢，但是可用於不同主機間的通信，通常用於debug調試非常方便；傳輸時數據位可以5、6、7、8位。<br><img src="/images/20231119022253.png"></p>
<h1 id="鮑率-波特率"><a href="#鮑率-波特率" class="headerlink" title="鮑率(波特率)"></a>鮑率(波特率)</h1><p>常見的鮑率 9600 19200 38400 115200<br> <span id="more"></span><br> 1 鮑率 即指每秒傳輸1個符號(bit)<br>9600代表每秒傳輸9600高低電平，如果不匹配會導致亂碼<br>每一個 bit 的時間就是 1&#x2F;9600</p>
<h1 id="數據幀"><a href="#數據幀" class="headerlink" title="數據幀"></a>數據幀</h1><p><img src="/images/20231119022310.png"></p>
<h2 id="啟始位元"><a href="#啟始位元" class="headerlink" title="啟始位元"></a>啟始位元</h2><p>表示資料封包開始， UART 的發送方會將資料傳輸線從高電壓低電壓變成低電壓</p>
<h2 id="資料位元"><a href="#資料位元" class="headerlink" title="資料位元"></a>資料位元</h2><p>可以定義為 5bit、6bit、7bit、8bit</p>
<h2 id="同位位元"><a href="#同位位元" class="headerlink" title="同位位元"></a>同位位元</h2><p>用於檢查資料正確性 同位位元有兩種模式：偶同位(even) 和 奇同位(odd)</p>
<h2 id="停止位元"><a href="#停止位元" class="headerlink" title="停止位元"></a>停止位元</h2><p>表示資料封包結束， UART 的發送方會將資料傳輸線從低電壓變成高電壓並保持1~2位元時間。</p>
<h2 id="現況"><a href="#現況" class="headerlink" title="現況"></a>現況</h2><p>現在 UART 很少使用同位位元來偵錯了。常見的「38400,8,N,1」這種設定，意思就是 38400 bps 的鮑率、8 個資料位元，N 則代表沒有同位位元，1 是 1 個停止位元的意思；現在其實已經很少看到後面不是「8,N,1」的設定，因為 同位位元已經幾乎不再使用，而 8 個資料位元和 1 個停止位元也幾乎成爲標準。</p>
<h2 id="接法"><a href="#接法" class="headerlink" title="接法"></a>接法</h2><p><img src="/images/20231119022341.png"><br>TX接RX RX接TX </p>
<h2 id="TTL電平-Transistor-Transistor-Logic"><a href="#TTL電平-Transistor-Transistor-Logic" class="headerlink" title="TTL電平 Transistor-Transistor Logic"></a>TTL電平 Transistor-Transistor Logic</h2><p><img src="/images/20231119022404.png"><br>2.4v<del>5v 為高電平 0</del>0.4 為低電平<br><img src="/images/20231119022417.png"><br>容易造成干擾 所以通訊距離大約1m內 改進RS232 和 RS485</p>
<h2 id="補充-UART串口流控制（Flow-control）"><a href="#補充-UART串口流控制（Flow-control）" class="headerlink" title="(補充) UART串口流控制（Flow control）"></a>(補充) UART串口流控制（Flow control）</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>是管理两个节点之间数据传输速率的过程，以防止出现接收端的数据缓冲区已满，而发送端依然继续发送数据，所导致数据丢失</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当接收端的数据缓冲区已满，无法处理数据来时，就发出 “不再接收” 的信号，发送端则停止发送，直到发送端收到 “可以继续发送” 的信号再发送数据。<br>计算机中常用的两种流控制分别是<strong>硬件流控制</strong>（RTS &#x2F;CTS、DTR &#x2F;DSR等）和<strong>软件流控制</strong>（XON &#x2F;XOFF）</p>
<h1 id="RS232"><a href="#RS232" class="headerlink" title="RS232"></a>RS232</h1><p>RS(Recommended Stabdard) 推薦標準<br>將TTL電平轉換成232電平 轉換電壓 抗干擾能力變強 還是傳輸原來的數據只是改變電壓 還是全雙工<br>傳輸距離到15米 2M&#x2F;s<br><img src="/images/20231119022441.png"><br>也是只用到 RxD TxD GND<br><img src="/images/20231119022454.png"><br>將TTL電平轉換成232電平<br><img src="/images/20231119022508.png"><br>進去TTL 5V 轉換成232電平 -12V (影片有錯)<br><img src="/images/20231119022520.png"><br>進去TTL 0V 轉換成232電平 +12V (影片有錯)<br><img src="/images/20231119022552.png"><br>正確的轉換<br><img src="/images/20231119022615.png"><br>232電平 高電平為3V-15V 低電平為-3V~-15V 抗干擾能力變強</p>
<h1 id="RS485"><a href="#RS485" class="headerlink" title="RS485"></a>RS485</h1><p>將TTL電平轉換成485電平 轉換差分信號 抗干擾能力變強 變成半雙工<br>傳輸距離到1200米 50M&#x2F;s<br><img src="/images/20231119022632.png"><br><img src="/images/20231119022701.png"><br>差分信號 A大於B訊號為0 B大於A訊號為1<br><img src="/images/20231119022714.png"><br>受干擾時，因為是雙絞線所以基本是是同時干擾，還是差分，干擾能力強</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p><img src="/images/20231119022730.png"><br>RS232 RS485 只有改變物理層</p>
<h1 id="參考影片"><a href="#參考影片" class="headerlink" title="參考影片"></a>參考影片</h1><ul>
<li><a href="https://www.youtube.com/watch?v=HKQaYN5Odlk">5分钟看懂!串口RS232 RS485最本质的区别！</a></li>
<li><a href="https://youtu.be/ia2x1oenic0">嵌入式系統(I)_洪崇文_單元四 通用非同步收發傳輸UART 與RS-232_Part 1 串列通訊介紹</a></li>
<li><a href="https://youtu.be/xKdV7lcvy1o">嵌入式系統(I)_洪崇文_單元四 通用非同步收發傳輸UART 與 RS-232_Part 2 UART通訊與RS232 I</a></li>
</ul>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://www.block.tw/blog/uart/">UART 串列通訊</a></li>
<li><a href="https://blog.csdn.net/qq_42992084/article/details/104761474">UART串口流控制（Flow control）</a></li>
<li><a href="https://blog.csdn.net/qq_42992084/article/details/104761474">UART串口流控制（Flow control）</a></li>
<li><a href="https://semhuang.pixnet.net/blog/post/141101276">UART 硬體流量控制 CTS及RTS</a></li>
<li><a href="https://silverwind1982.pixnet.net/blog/post/361701597-uart">UART 簡介</a></li>
</ul>
]]></content>
      <categories>
        <category>soc</category>
      </categories>
      <tags>
        <tag>RS232</tag>
        <tag>RS484</tag>
        <tag>TTL</tag>
        <tag>TXRX</tag>
        <tag>UART</tag>
      </tags>
  </entry>
  <entry>
    <title>VM安裝</title>
    <url>/posts/20231129101600-661de22d.html</url>
    <content><![CDATA[<h2 id="Install-Guest-Additions"><a href="#Install-Guest-Additions" class="headerlink" title="Install Guest Additions"></a>Install Guest Additions</h2><p><code>sudo apt-get install gcc make perl -y</code><br><img src="/images/20231129152725.png"><br>插入 Guest Additions CD 映像<br><img src="/images/20231129152840.png"><br>點擊Run<br><img src="/images/20231129152907.png"><br>輸入密碼<br> <span id="more"></span><br> <img src="/images/20231129152934.png"><br>運行中<br><img src="/images/20231129153043.png"><br>無報錯 安裝成功後 reboot 可以縮放 剪貼簿 公用資料夾</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://blog.csdn.net/bell_love/article/details/105401852">简单解决Please install the gcc make perl packages from your distribution问题</a></li>
</ul>
<h2 id="共用資料夾"><a href="#共用資料夾" class="headerlink" title="共用資料夾"></a>共用資料夾</h2><p><img src="/images/20231129154247.png"><br>點擊共用資料夾設定<br><img src="/images/20231129154432.png"><br>點擊加號<br><img src="/images/20231129154530.png"><br>輸入要掛載的資料夾 和 掛載點 點擊確認<br><img src="/images/20231129154609.png"><br>成功會出現在掛載點</p>
<h3 id="參考-1"><a href="#參考-1" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://www.jinnsblog.com/2021/05/virtualbox-shared-folder-permission-setting.html">[Linux &#x2F; Windows] VirtualBox 共用資料夾與雙向剪貼簿之權限設定</a></li>
</ul>
<h2 id="加入憑證"><a href="#加入憑證" class="headerlink" title="加入憑證"></a>加入憑證</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> my-ca-certificate.crt /usr/local/share/ca-certificates/</span><br><span class="line"><span class="built_in">cd</span> /usr/local/share/ca-certificates/</span><br><span class="line">sudo <span class="built_in">chmod</span> 644 my-ca-certificate.crt</span><br><span class="line">sudo  update-ca-certificates</span><br></pre></td></tr></table></figure>
<h3 id="參考-2"><a href="#參考-2" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://blog.kkbruce.net/2020/01/linux-windows-container-add-cert.html">如何為LINUX, WINDOWS容器加入憑證?</a></li>
</ul>
<h2 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h2><p><img src="/images/20231129163310.png"><br>新增網路介面卡2 僅限主機 介面卡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install samba -y</span><br><span class="line">smbpasswd -a root #設定root 密碼</span><br><span class="line">vim /etc/samba/smb.conf </span><br></pre></td></tr></table></figure>
<p>smb.conf 加入底下的設定 使用root 登入 &#x2F;media&#x2F;new_drive 需要存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[brian]</span><br><span class="line">   comment = new_drive</span><br><span class="line">   public = yes</span><br><span class="line">   path = /media/new_drive</span><br><span class="line">   guest ok = yes</span><br><span class="line">   read only = no</span><br><span class="line">   browseable = yes</span><br><span class="line">   create mask = 777</span><br><span class="line">   directory mask = 777</span><br><span class="line">   writable = yes</span><br><span class="line">   valid users = root</span><br></pre></td></tr></table></figure>
<p><img src="/images/20231129160349.png"><br><code>samba restart</code> or <code>/etc/init.d/smbd restart</code><br><img src="/images/20231129160659.png"><br>本機右鍵 連線網路磁碟機<br><img src="/images/20231129160740.png"><br>輸入上面資訊 <code>\\192.168.56.108\brian</code> brian 為設定檔<code>[brian]</code><br>之後 按完成 需要輸入密碼 </p>
<h3 id="參考-3"><a href="#參考-3" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://hollyqood.wordpress.com/2016/12/08/virtualbox%e8%99%9b%e6%93%ac%e6%a9%9fubuntu%e4%bd%bf%e7%94%a8samba%e5%9c%96%e6%96%87%e6%95%99%e5%ad%b8/">virtualbox虛擬機ubuntu使用samba圖文教學</a></li>
</ul>
<h2 id="SSH-Server"><a href="#SSH-Server" class="headerlink" title="SSH Server"></a>SSH Server</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install ssh -y</span><br><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>編輯這些參數</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Port 22</span><br><span class="line">PermitRootLogin yes</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile	.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>(可選)如果用root登入需要設定root密碼<br><code>sudo passwd</code><br>重啟ssh<br><code>/etc/init.d/ssh restart</code></p>
<h3 id="參考-4"><a href="#參考-4" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://www.ewdna.com/2012/06/ubuntu-ssh-server.html">Ubuntu 安裝與設定 ssh server</a></li>
<li><a href="https://askubuntu.com/questions/171521/what-is-the-password-for-ssh-rootlocalhost">What is the password for <code>ssh root@localhost</code>?</a></li>
</ul>
<h2 id="zsh-oh-my-zsh"><a href="#zsh-oh-my-zsh" class="headerlink" title="zsh + oh my zsh"></a>zsh + oh my zsh</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install zsh -y</span><br><span class="line">sudo sh -c <span class="string">&quot;echo <span class="subst">$(which zsh)</span> &gt;&gt; /etc/shells&quot;</span></span><br><span class="line">chsh -s /bin/zsh</span><br><span class="line">apt install git curl -y</span><br><span class="line"></span><br><span class="line"><span class="comment">#oh my zsh</span></span><br><span class="line">curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh | sh -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># plugin zsh-autosuggestions</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"></span><br><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="comment"># plugins=(git zsh-autosuggestions) plugin添加zsh-autosuggestions</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># plugin zsh-syntax-highlighting</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br><span class="line"></span><br><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="comment"># plugins=(git zsh-syntax-highlighting) plugin添加zsh-syntax-highlighting</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> --depth 1 -- https://github.com/marlonrichert/zsh-autocomplete.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autocomplete</span><br><span class="line">plugins=(git zsh-autocomplete) plugin添加zsh-autocomplete</span><br></pre></td></tr></table></figure>
<h3 id="參考-5"><a href="#參考-5" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://magiclen.org/zsh/">如何在Linux作業系統上使用 Z Shell (Zsh)？</a></li>
<li><a href="https://www.jianshu.com/p/43c1b6e40c69">zsh 命令自动补全插件 zsh-autosuggestions 安装和配置</a></li>
</ul>
<p><code>apt-get iputils-ping net-tools traceroute vim</code> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&#123;&quot;</span>bip<span class="string">&quot;:&quot;</span>172.15.0.1/16<span class="string">&quot;&#125;&quot;</span> &gt; /etc/docker/daemon.json</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
        <tag>samba</tag>
        <tag>ssh-server</tag>
        <tag>vm</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC 使用了哪些協定</title>
    <url>/posts/20241226090200-ee154cd8.html</url>
    <content><![CDATA[<h2 id="WebRTC-使用了哪些協定"><a href="#WebRTC-使用了哪些協定" class="headerlink" title="WebRTC 使用了哪些協定"></a>WebRTC 使用了哪些協定</h2><p>我們最熟悉的網路傳輸協定TCP與UDP，作為傳輸層，兩者都有各自的優缺點，<br>而在WebRTC中，需要能夠實現即時串流應用，在影音傳輸方面上，第一個想到可以搭配的協定，<br>肯定是UDP。</p>
<p>然而UDP雖然適合影音傳輸上的應用，但在WebRTC中還需要能夠流量控制或處理擁塞等功能，這些是UDP所沒有的功能，<br>為此在UDP上附加了許多輔助協定，如下圖：</p>
 <span id="more"></span>
<p> <img src="/images/20241227094202.png"></p>
<p>圖片擷取自<a href="https://hpbn.co/webrtc/">High Performance Browser Networking book</a></p>
<p>上圖展示了整個WebRTC所運用的協定架構，左邊(TCP)為Signal應用，右邊(UDP)為串流應用，<br>協定堆的搭配使用，補足彼此的不足，而本章主要專注在串流應用(右邊)上的協定上，為WebRTC提供了哪些功能。</p>
<h3 id="加密-DTLS"><a href="#加密-DTLS" class="headerlink" title="加密: DTLS"></a>加密: DTLS</h3><p>DTLS 與 TLS 都是為網路傳輸提供數據安全與完整性的協定，<br>TLS在TCP協定上，而DTLS在UDP協定上。</p>
<p>雖然DTLS是建構在TLS上，但兩者的加密驗證方式是不同的，有興趣可以深入研究看看～</p>
<p>DTLS主要用途：會在通信雙方連接時產生密鑰，對傳輸數據進行加密再交由UDP。</p>
<h3 id="影音數據傳輸-SRTP"><a href="#影音數據傳輸-SRTP" class="headerlink" title="影音數據傳輸: SRTP"></a>影音數據傳輸: SRTP</h3><p>SRTP(Secure Real-Time Transport Protocol): 安全即時傳輸協定。</p>
<p>是基於<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Intro_to_RTP">RTP</a>(Real-Time Transport Protocol)上的擴展，主要用途還是圍繞在核心的RTC上。</p>
<p>RTP的主要用途: 針對定義網路影音數據傳輸的標準格式，因此常用於多媒體應用上。</p>
<p>但在多媒體應用上，RTP並不能保證服務質量<a href="https://en.wikipedia.org/wiki/Quality_of_service">QoS(quality-of-service)</a>，也就不能有效控制串流的品質，例如：依照頻寬調整影音數據的壓縮或是限制傳輸流量的大小等，因此常會搭配<a href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">RTCP</a>(Real-time Transport Control Protocol)。</p>
<p>而SRTP從命名上就能知道，是在RTP上加上安全性(secure)加密機制，同樣與其搭檔的RTCP也有一個伴生協定SRTCP。</p>
<h3 id="資料傳輸-SCTP"><a href="#資料傳輸-SCTP" class="headerlink" title="資料傳輸: SCTP"></a>資料傳輸: SCTP</h3><p>SCTP（Stream Control Transmission Protocol）：串流控制傳輸協定。</p>
<p>它是屬於較新訂定的協定，而主要優點是，它提供了像 TCP 一樣是可靠、有序的資料傳輸，同時也將UDP的高效做結合，也因此漸漸有許多應用層漸漸在 SCTP 的特性基礎上進行構建。</p>
<p>WebRTC是應用在<code>RTCDataChannel</code>中，藉由它的特性，例如多流或是可配置的無順序性配送等，並且搭配 DTLS 來加強安全性。</p>
<p>詳細可以參考<a href="http://www.faqs.org/rfcs/rfc3286.html">RFC 3286</a>中的說明。</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>本章暸解到:</p>
<ul>
<li>WebRTC protocol stack (所用的協定堆)</li>
<li>各個層級的協定互相搭配的用意</li>
<li>DTLS,RTP&#x2F;RTCP,SCTP 的功用</li>
</ul>
<p>這邊主要明白其中的基礎概念，並沒有做深入的探討～</p>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考:"></a>參考:</h1><ul>
<li><a href="https://ithelp.ithome.com.tw/articles/10249334">WebRTC 使用了哪些協定</a></li>
</ul>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>WebRTC基礎</title>
    <url>/posts/20241223100300-345ae512.html</url>
    <content><![CDATA[<h3 id="1-理解-WebRTC-基本概念"><a href="#1-理解-WebRTC-基本概念" class="headerlink" title="1. 理解 WebRTC 基本概念"></a>1. <strong>理解 WebRTC 基本概念</strong></h3><ul>
<li><a href="/posts/20241223034700-7727d3af.html" title="NAT（Network Address Translation，網路位址轉換）">NAT（Network Address Translation，網路位址轉換）</a></li>
<li><a href="/posts/20241219102800-464c14bb.html" title="P2P 打洞（Peer-to-Peer NAT Traversal）">P2P 打洞（Peer-to-Peer NAT Traversal）</a>：WebRTC 通常基於 P2P 進行通信，因此需要處理 NAT（網絡地址轉換）問題。打洞技術幫助穿越 NAT 和防火牆，使 P2P 連接可能。
 <span id="more"></span></li>
<li><a href="/posts/20241223035000-d4e6d128.html" title="STUN（ Session Traversal Utilities for NAT，NAT 穿越會話工具）">STUN（ Session Traversal Utilities for NAT，NAT 穿越會話工具）</a>：STUN 是一個協議，用於幫助 WebRTC 客戶端發現其公共 IP 地址和端口。這對於 P2P 連接至關重要。</li>
<li><a href="/posts/20241223040900-46d03228.html" title="TURN 協議（Traversal Using Relays around NAT）">TURN 協議（Traversal Using Relays around NAT）</a>：當 P2P 連接無法建立時，TURN 服務器用作中繼來轉發數據，保證通信不會中斷。</li>
<li><a href="/posts/20241223083000-58bf8773.html" title="ICE Interactive Connectivity Establishment，交互式连接建立">ICE Interactive Connectivity Establishment，交互式连接建立</a>：ICE 是 WebRTC 中的連接建立過程，結合 STUN 和 TURN 來選擇最佳的連接路徑。</li>
<li><a href="/posts/20241223074500-739a46ba.html" title="SDP（Session Description Protocol, 会话描述协议）">SDP（Session Description Protocol, 会话描述协议）</a>]</li>
<li><a href="/posts/20241223082200-314296ad.html" title="信令服务器">信令服务器</a></li>
</ul>
<h3 id="2-了解傳輸協議"><a href="#2-了解傳輸協議" class="headerlink" title="2. 了解傳輸協議"></a>2. <strong>了解傳輸協議</strong></h3><ul>
<li><a href="/posts/20241223094600-fcb5500e.html" title="RTP（Real-time Transport Protocol）">RTP（Real-time Transport Protocol）</a>：WebRTC 使用 RTP 來傳輸語音和視頻流。它為實時應用提供了一個適合的數據包格式。</li>
<li>**<a href="/posts/20241224031200-ad213933.html" title="RTCP（Real-time Transport Control Protocol）">RTCP（Real-time Transport Control Protocol）</a>**：RTCP 是用於監控 RTP 流量質量的協議，它會定期回報傳輸情況。</li>
</ul>
<h3 id="3-學習"><a href="#3-學習" class="headerlink" title="3. 學習"></a>3. <strong>學習<a href="/posts/20241223082200-314296ad.html" title="信令服务器">信令服务器</a></strong></h3><ul>
<li>WebRTC 本身並不定義信令過程。信令服務器用來協調 P2P 連接的建立，通常包括交換候選地址（ICE candidates）、會議協議、媒體協商等。</li>
<li><a href="/posts/20241224063000-40453b0a.html" title="PeerConnection 連線過程">PeerConnection 連線過程</a></li>
<li><a href="/posts/20241224070200-f38f09a7.html" title="ICE連線排序規則">ICE連線排序規則</a></li>
<li>常見的信令方式有 WebSocket 或 HTTP 請求。需要學習如何建立一個信令服務器，來實現 WebRTC 客戶端之間的通信協議。</li>
<li><a href="/posts/20241223100200-2469950e.html" title="搭建webrtc服务器">搭建webrtc服务器</a></li>
<li><a href="/posts/20230806170400-af856b41.html" title="webrtc">webrtc</a></li>
</ul>
<h3 id="4-實作步驟"><a href="#4-實作步驟" class="headerlink" title="4. 實作步驟"></a>4. <strong>實作步驟</strong></h3><ul>
<li><strong>建立 WebRTC 連接</strong>：理解如何通過 JavaScript API（如 <code>RTCPeerConnection</code>、<code>RTCDataChannel</code>）創建 P2P 連接。</li>
<li><strong>處理 ICE 候選</strong>：學會如何使用 STUN 和 TURN 服務器來發現和協商連接。</li>
<li><strong>處理媒體流</strong>：學會如何處理音頻和視頻流的捕捉、編碼、解碼，以及如何發送和接收這些流。</li>
</ul>
<h3 id="5-工具與資源"><a href="#5-工具與資源" class="headerlink" title="5. 工具與資源"></a>5. <strong>工具與資源</strong></h3><ul>
<li><strong>WebRTC 教程</strong>：網上有許多 WebRTC 實作教程和範例，幫助你從簡單的 P2P 連接開始學習。</li>
<li><strong>WebRTC 網頁應用範例</strong>：從實際應用入手，例如開發視頻聊天應用，來了解如何將 STUN、TURN、ICE 和 RTP 整合進去。</li>
</ul>
<h3 id="6"><a href="#6" class="headerlink" title="6. "></a>6. <a href="/posts/20241226081700-efd237b7.html" title="Webrtc視訊流">Webrtc視訊流</a></h3><h3 id="7"><a href="#7" class="headerlink" title="7."></a>7.<a href="/posts/20241226090200-ee154cd8.html" title="WebRTC 使用了哪些協定">WebRTC 使用了哪些協定</a></h3><h3 id="8-多人會議"><a href="#8-多人會議" class="headerlink" title="8. 多人會議"></a>8. 多人會議</h3><h2 id="视频会议服务器SFU、MCU、Mesh三种类型的区别-參考-WebRTC-学习指南-WebRTC-Native-源码导读"><a href="#视频会议服务器SFU、MCU、Mesh三种类型的区别-參考-WebRTC-学习指南-WebRTC-Native-源码导读" class="headerlink" title="视频会议服务器SFU、MCU、Mesh三种类型的区别# 參考- WebRTC 学习指南- WebRTC Native 源码导读"></a><a href="https://blog.csdn.net/zhizhuodewo6/article/details/104797267">视频会议服务器SFU、MCU、Mesh三种类型的区别</a><br># 參考<br>- <a href="https://webrtc.mthli.com/">WebRTC 学习指南</a><br>- <a href="https://blog.piasy.com/2017/07/24/WebRTC-Android-Camera-Capture/index.html">WebRTC Native 源码导读</a></h2>]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>STUN（ Session Traversal Utilities for NAT，NAT 穿越會話工具）</title>
    <url>/posts/20241223035000-d4e6d128.html</url>
    <content><![CDATA[<p>STUN（Session Traversal Utilities for NAT，NAT 穿越會話工具）是一種網絡協議，用於協助用戶端通過 NAT（網絡地址轉換）和防火牆發現其<strong>公共 IP 地址和端口</strong>。STUN 的主要目的是幫助建立點對點連接，尤其是在使用 NAT 和防火牆的網絡環境中，例如即時通訊或視頻通話等應用。</p>
<p>NAT 自己不会告诉服务器它是什么类型的，我们需要一套交互式策略检测对应的类型<br> <span id="more"></span></p>
<p>RFC 3489<br><img src="/images/20241223104352.png"><br>此演算法在RFC 3489被提出，但在RFC 5389中被刪除。</p>
<h3 id="STUN-的主要功能"><a href="#STUN-的主要功能" class="headerlink" title="STUN 的主要功能"></a><strong>STUN 的主要功能</strong></h3><ol>
<li><strong>發現公共 IP 地址和端口</strong>： STUN 協議允許用戶端詢問 STUN 伺服器，用戶端的公共 IP 地址和伺服器看到的端口號是什麼。</li>
<li><strong>檢測 NAT 類型</strong>： STUN 能夠幫助用戶端檢測 NAT 的類型（如全錐形 NAT、限制錐形 NAT、對稱 NAT 等），以便了解網絡條件。</li>
<li><strong>協助 P2P 連接</strong>： 通過 STUN，兩個位於 NAT 後的用戶端可以交換公共地址，嘗試建立直接的點對點連接。</li>
</ol>
<h3 id="STUN-的工作原理"><a href="#STUN-的工作原理" class="headerlink" title="STUN 的工作原理"></a><strong>STUN 的工作原理</strong></h3><ol>
<li><strong>用戶端請求</strong>： 用戶端向 STUN 伺服器發送一個包含其本地 IP 和端口的請求。</li>
<li><strong>伺服器響應</strong>： STUN 伺服器收到請求後，根據其視角返回用戶端的公共 IP 地址和端口。</li>
<li><strong>NAT 類型檢測</strong>： 通過改變請求的參數，例如更換來源地址、使用不同的伺服器，STUN 可以分析 NAT 的行為，判斷是哪種類型的 NAT。</li>
</ol>
<h3 id="STUN-協議的用途"><a href="#STUN-協議的用途" class="headerlink" title="STUN 協議的用途"></a><strong>STUN 協議的用途</strong></h3><ul>
<li><strong>WebRTC 通信</strong>： 在 WebRTC 中，STUN 是一個關鍵技術，用於讓瀏覽器間建立直接連接。</li>
<li><strong>VoIP 和視頻會議</strong>： 如 Skype、Zoom 等應用會利用 STUN 來協助穿越 NAT。</li>
<li><strong>在線遊戲</strong>： 幫助遊戲客戶端在 NAT 後通信。</li>
</ul>
<h3 id="STUN-和其他-NAT-穿越技術"><a href="#STUN-和其他-NAT-穿越技術" class="headerlink" title="STUN 和其他 NAT 穿越技術"></a><strong>STUN 和其他 NAT 穿越技術</strong></h3><ol>
<li><strong>STUN</strong>： 用於發現公共地址和協助直接通信。適用於全錐形 NAT 和部分限制錐形 NAT。</li>
<li><strong>TURN（Traversal Using Relays around NAT）</strong>： 當直接連接不可行時（如對稱 NAT），TURN 允許數據通過中繼伺服器傳輸。</li>
<li><strong>ICE（Interactive Connectivity Establishment）</strong>： 綜合使用 STUN 和 TURN 的技術，幫助選擇最佳的通信路徑。</li>
</ol>
<hr>
<h3 id="STUN-的限制"><a href="#STUN-的限制" class="headerlink" title="STUN 的限制"></a><strong>STUN 的限制</strong></h3><ul>
<li><strong>對稱 NAT 支持有限</strong>： 對於對稱 NAT，用戶端通常無法直接建立連接，需要配合 TURN 使用。</li>
<li><strong>依賴 STUN 伺服器</strong>： 必須配置和維護可靠的 STUN 伺服器，才能確保其正常運行。</li>
<li><strong>安全性考量</strong>： STUN 不加密數據，可能面臨中間人攻擊或地址偽造。</li>
</ul>
<h3 id="STUN-演算法的基本概念"><a href="#STUN-演算法的基本概念" class="headerlink" title="STUN 演算法的基本概念"></a><strong>STUN 演算法的基本概念</strong></h3><ol>
<li><p><strong>NAT 類型檢測</strong>：</p>
<ul>
<li>判斷 NAT 的行為，包括地址映射和數據包過濾規則。</li>
<li>確定 NAT 是「全錐形 NAT」、「限制錐形 NAT」、「端口限制錐形 NAT」還是「對稱 NAT」。</li>
</ul>
</li>
<li><p><strong>穿越測試</strong>：</p>
<ul>
<li>利用多種測試組合檢測 NAT 穿越能力，確保應用程序可以建立有效的通信通道。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="STUN-的主要測試步驟"><a href="#STUN-的主要測試步驟" class="headerlink" title="STUN 的主要測試步驟"></a><strong>STUN 的主要測試步驟</strong></h3><p>STUN 使用以下步驟和測試模式來檢測 NAT 的類型和行為：</p>
<h4 id="步驟-1-發送基本測試-Test-I"><a href="#步驟-1-發送基本測試-Test-I" class="headerlink" title="步驟 1: 發送基本測試 (Test I)"></a><strong>步驟 1: 發送基本測試 (Test I)</strong></h4><ol>
<li><p><strong>過程</strong>：</p>
<ul>
<li>用戶端向 STUN 伺服器發送一個 Binding Request。</li>
<li>該請求從用戶端的本地地址 <code>A</code> 發出，經過 NAT 之後，伺服器會看到轉換後的公共地址 <code>A&#39;</code>。</li>
<li>伺服器返回一個 Binding Response，其中包含 <code>MAPPED-ADDRESS</code>。</li>
</ul>
</li>
<li><p><strong>結果解讀</strong>：</p>
<ul>
<li>如果返回的 <code>MAPPED-ADDRESS</code> 與請求中的來源地址一致，表示沒有 NAT 或在同一局域網中。</li>
<li>如果不同，則 NAT 存在，記錄公共地址。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="步驟-2-發送不同來源地址的測試-Test-II"><a href="#步驟-2-發送不同來源地址的測試-Test-II" class="headerlink" title="步驟 2: 發送不同來源地址的測試 (Test II)"></a><strong>步驟 2: 發送不同來源地址的測試 (Test II)</strong></h4><ol>
<li><p><strong>過程</strong>：</p>
<ul>
<li>用戶端向伺服器發送第二個請求，改變來源端口或地址。</li>
<li>這一測試用於檢測 NAT 是否會對來源地址改變的數據包進行映射更新。</li>
</ul>
</li>
<li><p><strong>結果解讀</strong>：</p>
<ul>
<li>如果伺服器返回相同的地址，則 NAT 是錐形 NAT。</li>
<li>如果伺服器返回的地址不同，則 NAT 是對稱 NAT。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="步驟-3-使用不同伺服器的測試-Test-III"><a href="#步驟-3-使用不同伺服器的測試-Test-III" class="headerlink" title="步驟 3: 使用不同伺服器的測試 (Test III)"></a><strong>步驟 3: 使用不同伺服器的測試 (Test III)</strong></h4><ol>
<li><p><strong>過程</strong>：</p>
<ul>
<li>用戶端向另一個 STUN 伺服器發送請求（伺服器 B）。</li>
<li>比較伺服器 A 和 B 返回的地址。</li>
</ul>
</li>
<li><p><strong>結果解讀</strong>：</p>
<ul>
<li>如果伺服器 A 和 B 返回相同的公共地址，表示 NAT 為全錐形 NAT。</li>
<li>如果返回的公共地址不同，表示 NAT 為對稱 NAT。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="步驟-4-開啟目標伺服器測試-Test-IV"><a href="#步驟-4-開啟目標伺服器測試-Test-IV" class="headerlink" title="步驟 4: 開啟目標伺服器測試 (Test IV)"></a><strong>步驟 4: 開啟目標伺服器測試 (Test IV)</strong></h4><ol>
<li><p><strong>過程</strong>：</p>
<ul>
<li>用戶端向伺服器發送包含目標伺服器地址的請求。</li>
<li>測試 NAT 是否允許數據包從特定外部地址進入。</li>
</ul>
</li>
<li><p><strong>結果解讀</strong>：</p>
<ul>
<li>如果伺服器能響應，表示 NAT 為限制錐形 NAT。</li>
<li>如果伺服器無法響應，則 NAT 是端口限制錐形 NAT。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="STUN-發現-NAT-類型的算法決策表"><a href="#STUN-發現-NAT-類型的算法決策表" class="headerlink" title="STUN 發現 NAT 類型的算法決策表"></a><strong>STUN 發現 NAT 類型的算法決策表</strong></h3><p>下表簡要說明了 STUN 在不同步驟中的行為和決策：</p>
<table>
<thead>
<tr>
<th><strong>測試步驟</strong></th>
<th><strong>返回地址是否一致</strong></th>
<th><strong>NAT 類型</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Test I</td>
<td>是</td>
<td>無 NAT 或防火牆</td>
</tr>
<tr>
<td></td>
<td>否</td>
<td>NAT 存在</td>
</tr>
<tr>
<td>Test II</td>
<td>是</td>
<td>錐形 NAT</td>
</tr>
<tr>
<td></td>
<td>否</td>
<td>對稱 NAT</td>
</tr>
<tr>
<td>Test III</td>
<td>是</td>
<td>全錐形 NAT</td>
</tr>
<tr>
<td></td>
<td>否</td>
<td>限制錐形或端口限制錐形 NAT</td>
</tr>
<tr>
<td>Test IV</td>
<td>是</td>
<td>限制錐形 NAT</td>
</tr>
<tr>
<td></td>
<td>否</td>
<td>端口限制錐形 NAT</td>
</tr>
</tbody></table>
<hr>
<h3 id="關於防火牆檢測"><a href="#關於防火牆檢測" class="headerlink" title="關於防火牆檢測"></a><strong>關於防火牆檢測</strong></h3><ul>
<li>防火牆的檢測基於數據包是否能到達伺服器。</li>
<li>如果所有測試數據包都無法響應，可能是防火牆完全阻止了 UDP 流量。</li>
</ul>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>Webrtc視訊流</title>
    <url>/posts/20241226081700-efd237b7.html</url>
    <content><![CDATA[<h1 id="開啟相機主要類別-以安卓為例"><a href="#開啟相機主要類別-以安卓為例" class="headerlink" title="開啟相機主要類別(以安卓為例)"></a>開啟相機主要類別(以安卓為例)</h1><p><img src="/images/20241226150748.png"></p>
<h1 id="frame的流向"><a href="#frame的流向" class="headerlink" title="frame的流向"></a>frame的流向</h1><p><img src="/images/20241226150839.png"><br>攝影機擷取的視訊幀資料會被傳遞到 VideoBroadcaster 這個類別進行處理，而擷取過程也到此為止。從 VideoBroadcaster 的名稱就不難發現，幀資料接下來會被以廣播的形式發送給各個訂閱者，也就是說後續的渲染、編碼（和發送）過程是並行處理的。<br> <span id="more"></span></p>
<h1 id="選染以及編碼和發送"><a href="#選染以及編碼和發送" class="headerlink" title="選染以及編碼和發送"></a>選染以及編碼和發送</h1><p><img src="/images/20241226150927.png"><br>本地渲染 和 編碼發送 有透過 VideoTrack.addSink(sink) 向 broadcaser 註冊 OnFrame callback 事件</p>
<ul>
<li>本地渲染 透過 SurfaceViewRenderer 收到 frame 再將帧数据渲染到了 EGL</li>
<li>編碼發送 <ol>
<li>这里的编码器是 LibvpxVp8Encoder，但换成其他继承自 <code>webrtc::VideoEncoder</code> 的子类都是可以的 </li>
<li>RtpPacket 入队之后，将由 <code>webrtc::ProcessThreadImpl::Process</code> 进行处理，严格意义上已经不算是调用栈了，但读者也可以将其理解为 RtpPacket 的处理流程。<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">webrtc::VideoStreamEncoder::OnFrame</span><br><span class="line">  → webrtc::VideoStreamEncoder::MaybeEncodeVideoFrame</span><br><span class="line">  → webrtc::VideoStreamEncoder::EncodeVideoFrame</span><br><span class="line">  → webrtc::LibvpxVp8Encoder::Encode #1</span><br><span class="line">  → webrtc::LibvpxVp8Encoder::GetEncodedPartitions</span><br><span class="line">  → webrtc::VideoStreamEncoder::OnEncodedImage</span><br><span class="line">  → webrtc::internal::VideoSendStreamImpl::OnEncodedImage</span><br><span class="line">  → webrtc::RtpVideoSender::OnEncodedImage</span><br><span class="line">  → webrtc::RTPSenderVideo::SendEncodedImage</span><br><span class="line">  → webrtc::RTPSenderVideo::SendVideo</span><br><span class="line">  → webrtc::RTPSenderVideo::LogAndSendToNetwork</span><br><span class="line">  → webrtc::RTPSender::EnqueuePackets</span><br><span class="line">  → webrtc::PacedSender::EnqueuePackets</span><br><span class="line">  → webrtc::PacingController::EnqueuePacket</span><br><span class="line">  → webrtc::PacingController::EnqueuePacketInternal</span><br><span class="line">  → webrtc::PacedSender::Process #2</span><br><span class="line">  → webrtc::PacingController::ProcessPackets</span><br><span class="line">  → webrtc::PacedSender::SendRtpPacket</span><br><span class="line">  → webrtc::ModuleRtpRtcpImpl2::TrySendPacket</span><br><span class="line">  → webrtc::RtpSenderEgress::SendPacket</span><br><span class="line">  → webrtc::RtpSenderEgress::SendPacketToNetwork</span><br><span class="line">  → cricket::WebRtcVideoChannel::SendRtp</span><br><span class="line">  → cricket::MediaChannel::SendPacket</span><br><span class="line">  → cricket::MediaChannel::DoSendPacket</span><br><span class="line">  → cricket::VideoChannel::SendPacket</span><br><span class="line">  → webrtc::DtlsSrtpTransport::SendRtpPacket #3</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<h1 id="添加濾鏡"><a href="#添加濾鏡" class="headerlink" title="添加濾鏡"></a>添加濾鏡</h1><p>由於需要即時預覽濾鏡效果，所以必須在渲染開始之前添加濾鏡。好在 WebRTC 已經提供了 VideoProcessor 這個介面類，可以對擷取到的幀資料進行預處理，呼叫 VideoSource.setVideoProcessor(processor) 即可設定：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VideoSource</span> <span class="keyword">extends</span> <span class="title class_">MediaSource</span> &#123;</span><br><span class="line">  <span class="comment">// other definitions...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">CapturerObserver</span> <span class="variable">capturerObserver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CapturerObserver</span>() &#123;</span><br><span class="line">    <span class="comment">// other definitions...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFrameCaptured</span><span class="params">(VideoFrame frame)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> VideoProcessor.<span class="type">FrameAdaptationParameters</span> <span class="variable">parameters</span> <span class="operator">=</span></span><br><span class="line">          nativeAndroidVideoTrackSource.adaptFrame(frame);</span><br><span class="line">      <span class="keyword">synchronized</span> (videoProcessorLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (videoProcessor != <span class="literal">null</span>) &#123;</span><br><span class="line">          videoProcessor.onFrameCaptured(frame, parameters);          </span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// body method...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// other definitions...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>VideoProcessor 的簡單實現</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">implements</span> <span class="title class_">VideoProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span> <span class="keyword">private</span> VideoSink mVideoSink;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCapturerStarted</span><span class="params">(<span class="type">boolean</span> success)</span> &#123;</span><br><span class="line">    <span class="comment">// DO SOMETHING IF YOU WANT.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onCapturerStopped</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// DO SOMETHING IF YOU WANT.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSink</span><span class="params">(<span class="meta">@Nullable</span> VideoSink sink)</span> &#123;</span><br><span class="line">    <span class="comment">// 需要持有 WebRTC 传入的 VideoSink 对象</span></span><br><span class="line">    mVideoSink = sink;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onFrameCaptured</span><span class="params">(<span class="meta">@NonNull</span> VideoFrame frame)</span> &#123;</span><br><span class="line">    <span class="type">VideoFrame</span> <span class="variable">newFrame</span> <span class="operator">=</span> yourVideoFilter(frame);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 会调用 NativeAndroidVideoTrackSource 将新的帧数据传递给 Native 层</span></span><br><span class="line">    <span class="keyword">if</span> (mVideoSink != <span class="literal">null</span>) mVideoSink.onFrame(frame);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://webrtc.mthli.com/media/video-outbound">视频推流过程</a></li>
<li><a href="https://blog.piasy.com/2017/07/24/WebRTC-Android-Camera-Capture/index.html">WebRTC Native 源码导读（一）：安卓相机采集实现分析</a></li>
</ul>
]]></content>
      <tags>
        <tag>WebRTC</tag>
        <tag>android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Zigbee介紹</title>
    <url>/posts/20231118195000-c8085013.html</url>
    <content><![CDATA[<ul>
<li><a href="https://blog.csdn.net/u011350258/article/details/113062464">1、ZigBee 开发教程之基础篇—ZigBee简介和学习方法</a></li>
<li><a href="https://zigbeealliance.org/wp-content/uploads/2019/12/Getting-Started-with-Zigbee-3.0-CN.pdf">手把手指南—— 开启你的 Zigbee 之旅</a> <span id="more"></span></li>
<li>Youtube <a href="https://www.youtube.com/playlist?list=PLkc2nflOpCG1jYSnd6gOWpV8XhrlEF-2J">Zigbee</a></li>
<li><a href="https://www.youtube.com/watch?v=iuhY4f_DvfI&ab_channel=TorchIoTBootCamp">Day 1-1 ZigBee基础知识</a></li>
<li><a href="https://blog.csdn.net/lexiyao/article/details/120969009">Zigbee快速入门第二节 – Zigbee基础介绍</a></li>
<li><a href="https://csa-iot.org/wp-content/uploads/2023/04/05-3474-23-csg-zigbee-specification-compressed.pdf">zigbee-specification</a></li>
</ul>
<h1 id="ZigBee基础知识"><a href="#ZigBee基础知识" class="headerlink" title="ZigBee基础知识"></a>ZigBee基础知识</h1><h2 id="What-is-ZigBee"><a href="#What-is-ZigBee" class="headerlink" title="What is ZigBee"></a>What is ZigBee</h2><h3 id="Zigbee"><a href="#Zigbee" class="headerlink" title="Zigbee"></a>Zigbee</h3><p><img src="/images/20231119024254.png"><br>右邊是覆蓋範圍大(10KM) 大多需要被管制的 由運營商主導 城市範圍的覆蓋<br>左邊是覆蓋範圍小(100m) 家庭 樓道用<br>Zigbee 短距離通訊技術 低速通訊技術 最大速度是250Kpbs<br>傳輸控制命令 和 數據採集<br>低功耗的技術 <a href="https://support.tuya.com/zh/help/_detail/K9skz5907xerr">休眠电流在uA級別</a><br>Mesh網路拓譜結構 網路輕鬆擴展 最大節點數 65535(wifi 50 BT 8)<br>2bytes&#x3D;16bits&#x3D;2^16&#x3D;65535<br>zigbee：10-100m，蓝牙：2-10m，Wi-Fi：30-100m</p>
<h3 id="Zigbee網路拓譜"><a href="#Zigbee網路拓譜" class="headerlink" title="Zigbee網路拓譜"></a>Zigbee網路拓譜</h3><p>Star(WiFi) vs Mesh(Zigbee) 主要差別在有無中心節點，中心節點壞了就不能正常工作</p>
<p>Zigbee(star mesh tree)<br><img src="/images/20231119024320.png"></p>
<h3 id="Zigbee-歷史"><a href="#Zigbee-歷史" class="headerlink" title="Zigbee 歷史"></a>Zigbee 歷史</h3><p><img src="/images/20231119024339.png"><br>2003年 Zigbee誕生<br>2016年 發布Zigbee3.0(整合統一之前的標準)</p>
<p><a href="https://www.51cto.com/article/496376.html">ZigBee 3.0版标准，强化低延迟与低功耗优势，并加入网际网路通讯协定(IP)支援能力</a></p>
<p>ZigBee完全相容Wi-Fi&#x2F;IP</p>
<p>ZigBee 3.0完全相容IP。ZigBee设备与Wi-Fi设备类似，通常透过路由器、闸道或机上盒连接到互联网，让人可在世界其他地方利用连接互联网的个人电脑、平板或智慧手机应用程式等任何其他设备实现即时控制(图3)。由于ZigBee完全相容Wi-Fi和IP，因此没必要在手机本身插入ZigBee晶片，从而发现和控制ZigBee连接的智慧家居和物联网设备。只要通过任何联网中心均可让这一切实现，这意味着，透过Wi-Fi或蜂窝网进行联网的个人电脑和智慧手机可以作为指示板，并可毫不费力发现并与其他ZigBee设备进行通讯。</p>
<p><a href="https://blog.csdn.net/mengqidluffy/article/details/116061885">小白也能读懂的 ZigBee 3.0 简介</a></p>
<h3 id="Zigbee-聯盟"><a href="#Zigbee-聯盟" class="headerlink" title="Zigbee 聯盟"></a>Zigbee 聯盟</h3><p><img src="/images/20231119024356.png"><br>推广Zigbee技术的主要力量。这是一个开放的组织。任何公司都可以加入Zigbee联盟作为成员。Silicon Labs是Zigbee联盟的董事会成员。</p>
<ul>
<li>为IoT（物联网）的无线设备端到设备端的通信制定开放的全球标准</li>
<li>通过我们的认证计划对产品进行认证，以帮助确保互操作性(產品和平台的認證)</li>
<li>在全球范围内推广我们的标准</li>
</ul>
<p><img src="/images/20231119024412.png"><br>Zigbee聯盟更名，同步推出與亞馬遜、蘋果及Google共同制定連接標準Matter</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Zigbee協議"><a href="#Zigbee協議" class="headerlink" title="Zigbee協議"></a>Zigbee協議</h3><p><img src="/images/20231119024438.png"><br>基於<a href="https://baike.baidu.hk/item/IEEE%20802.15.4/6657379">IEEE802.15.4</a>標準基礎上定義<br>MAC層和物理層沿用IEEE802.15.4標準<br>網路層 APS層(Application Support Sub Layer) 應用層 是Zigbee定義的標準</p>
<p>網路層和APS層有加密的特性:加密 驗證 重傳保護</p>
<ul>
<li>物理層 由晶片實現 無線電的收發管理 調製解調</li>
<li>MAC層 一半硬體 一辦軟體實現 數據收發 確認 重傳 掃描</li>
<li>網路層 路由 設備狀狀態維護 子節點管理</li>
<li>APS層 端到端重傳和確認 </li>
<li>應用層 ZDO(ZigBee Device Object 特殊的設備管理功能) User應用</li>
</ul>
<p>灰色部分是晶片處理<br>綠色是平台供應商實現<br>橘色是應用層開發</p>
<blockquote>
<p>IEEE 802.15.4是一種技術標準，它定義了低速率無線個域網 （LR-WPAN）的協議。 它規定了LR-WPAN的物理層和媒體訪問控制 ，並由IEEE 802.15工作組維護，該工作組在2003年定義了該標準。它是Zigbee的基礎，諸如 ISA100.11a ， WirelessHART ， MiWi ， 6LoWPAN ，<br>PAN 個人區域網路</p>
</blockquote>
<h3 id="Zigbee物理層"><a href="#Zigbee物理層" class="headerlink" title="Zigbee物理層"></a>Zigbee物理層</h3><p><img src="/images/20231119024455.png"></p>
<h4 id="工作範圍在-2-4GHz-868MHz-915MHz"><a href="#工作範圍在-2-4GHz-868MHz-915MHz" class="headerlink" title="工作範圍在 2.4GHz 868MHz 915MHz"></a>工作範圍在 2.4GHz 868MHz 915MHz</h4><ul>
<li>2.4GHz  全球通用 250kpbs 11-26通道 2400MHz~2600MHz 每5MHz一個通道</li>
<li>868MHz 英國電表 水表(Smart Engery) 20kpbs 0通道 </li>
<li>915MHz 北美Zigbee 40kpbs 1-10通道 每2MHz一個通道</li>
</ul>
<h4 id="物理層功能"><a href="#物理層功能" class="headerlink" title="物理層功能"></a>物理層功能</h4><ul>
<li>物理无线和MAC层的接口</li>
<li>無線電收發管理</li>
<li>无线电开&#x2F;关控制</li>
<li>调制与解调</li>
<li>信道选择</li>
<li>链接质量估算</li>
<li>能量检测</li>
<li>功率調節</li>
</ul>
<h4 id="Zigbee-和-WIFI-共存"><a href="#Zigbee-和-WIFI-共存" class="headerlink" title="Zigbee 和 WIFI 共存??"></a>Zigbee 和 WIFI 共存??</h4><p><img src="/images/20231119024508.png"><br>Zigbee 和 WIFI 都使工作在2.4GHz 底下 會存在相互干擾的情況<br><a href="https://www.ebyte.com/new-view-info.aspx?id=1082">怎样设置Zigbee和wifi信道避免干扰？</a><br><a href="https://bbs.16rd.com/thread-574907-1-1.html">Zigbee和Wi-Fi的干擾和共存</a><br><a href="https://www.mwrf.net/tech/rfic/2020/27496.html">在2.4GHz共存-WLAN、蓝牙、ZigBee和Thread在2.4GHz频段共存</a></p>
<h3 id="Zigbee-MAC層"><a href="#Zigbee-MAC層" class="headerlink" title="Zigbee MAC層"></a>Zigbee MAC層</h3><h4 id="MAC幀"><a href="#MAC幀" class="headerlink" title="MAC幀"></a>MAC幀</h4><p><img src="/images/20231119024520.png"><br>前面PERAMBLE SPD PHYHeader 由物理層封裝<br>Frame Control(2bytes):標示frame類型</p>
<ul>
<li>Beacon 掃描網路</li>
<li>Data 上層數據</li>
<li>ACK 確認用</li>
<li>MAC Command 入網時候使用的命令 MAC关联过程。<br>CRC(最後2bytes): 驗證資料包的完整性 (空氣中傳播 受到干擾 資料會丟掉)</li>
</ul>
<h4 id="MAC-傳送確認"><a href="#MAC-傳送確認" class="headerlink" title="MAC 傳送確認"></a>MAC 傳送確認</h4><p><img src="/images/20231119024532.png"><br>MAC层还为节点提供了一种方法，该方法可通过确认得知节点已成功接收到1跳单播传输，并且已通过验证CRC保留了所传输消息的完整性。 多跳传输应在每个跳上进行确认。节点执行CCA检查并发送消息后，它会等待MAC确认。如果未收到消息，则该节点应尝试多次重发该消息，直到其最终成功或最大的重试次数已用尽。<br><img src="/images/20231119024545.png"><br>從NodeA到NodeD發送資料通常是應用層和應用層的傳送<br>NodeA 傳到到 NodeB 確認收到回傳MAC Ack 到 NodeA<br>不是NobeB接收的資料(資料最多在網路層) 往NodeC傳直到傳到正確的接收方<br>NodeD正確的接收要回傳APS Ack確認回NodeA</p>
<p>兩種不同的確認 如果沒收到Ack就會重傳</p>
<ul>
<li>MAC Ack 是點跟點的確認</li>
<li>APS Ack 是端到端的確認</li>
</ul>
<h4 id="CSMA-x2F-CA-避免干擾"><a href="#CSMA-x2F-CA-避免干擾" class="headerlink" title="CSMA&#x2F;CA 避免干擾"></a><a href="https://zhuanlan.zhihu.com/p/51412066">CSMA&#x2F;CA 避免干擾</a></h4><p>Listen Before Talk 發送資料前聽一下<br>判斷channel是否有人在使用<br>802.15.4允许多个网络位于同一通道上。因此，需要采取某种方式来避免来自不同网络的数据包在空中碰撞而造成通信错误。MAC子层使用CSMA-CA（Carrier Sense Multiple Access&#x2F;Collision Avoidance）控制对无线电的访问。避免碰撞是通过CCA（Clear Channel Assessment）完成的。在发送之前，每个节点必须检查电波是否可以正常发送（RSSI低于CCA阈值）。如果是，则节点应继续进行并在进行少量随机退避后进行传输。如果CCA没有通过，则该节点应等待多个退避周期，然后才能再次尝试该过程。随机退避允许多个节点交错传输，因此它们总是可以在某个时间点找到干净的无线空间来作数据传输。尽管比特率很低，因为数据包比较小（128 bytes），即使在非常嘈杂的信道上每一个节点也可以成功地完成数据传输。</p>
<p><a href="https://www.youtube.com/watch?v=wXbcBSQDnFA">CSMA&#x2F;CD</a> 兩種解決碰撞問題的機制<br>CSMA(Carrier Sense Mutiple Access) 防止碰撞機制 先偵測Hub上有無通訊 無才可通訊<br>CD(Collision Detection) 偵測碰撞 當偵測碰撞到碰撞時，發出JAM訊號 清空資料 再用 後退演算法錯開<br>CA(Collision Avoidance) 避免碰撞<br><a href="https://wiki.mbalib.com/zh-tw/CSMA/CA">CSMA&#x2F;CA</a></p>
<blockquote>
<p>CSMA&#x2F;CA是先聽一下附近有沒有人講話，沒有人講話再講話<br>CSMA&#x2F;CD是不管了直接傳，發現打斷其他人講話時就回來等一下再傳</p>
</blockquote>
<p>(一)差異： </p>
<ol>
<li>CSMA&#x2F;CD主要應用在有線網路，CSMA&#x2F;CA主要應用在無線網路。</li>
<li>CSMA&#x2F;CD是使用碰撞偵測處理(Collision Detection)，在有線網路的環境中，可以檢測碰撞，但不容易去 避免。CSMA&#x2F;CA是使用避免碰撞處理(Collision Avoidance)，在無線網路的環境中，要使用CD去偵測碰 撞是困難的，所以在無線網路中採取CA的方式避免碰撞。 </li>
<li>CSMA&#x2F;CD的傳輸效率較佳，但硬體成本比較高。CSMA&#x2F;CA的傳輸效率較差，但硬體成本比較低。<br>(二)運作過程： </li>
<li>CSMA&#x2F;CD是在偵測是否有通道空閒後，在發送資料時同時進行防止Collision的檢查，如果在發送數據過 程中檢測到衝突，就立即停止發送資料，並等待一段時間，再重新發送碰撞的資料。</li>
<li>CSMA&#x2F;CA在送出資料前，先送RTS封包確認或是聆聽網路上的狀態，若沒有人使用，等待一段時間後， 如果還沒有人使用，才送出資料。</li>
</ol>
<h3 id="Zigbee-網路層"><a href="#Zigbee-網路層" class="headerlink" title="Zigbee 網路層"></a>Zigbee 網路層</h3><h4 id="裝置類型"><a href="#裝置類型" class="headerlink" title="裝置類型"></a>裝置類型</h4><p><img src="/images/20231119024603.png"></p>
<ul>
<li>Coordinator 協調員<ul>
<li>一個Zigbee網路只能有一個</li>
<li>創建網路  第一個成員 地址為0x000</li>
<li>可以路由 添加成員</li>
<li>不能睡眠</li>
</ul>
</li>
<li>Router 路由<ul>
<li>可以路由</li>
<li>不能睡眠</li>
</ul>
</li>
<li>End Device&#x2F; Sleepy End Device 終端設備<ul>
<li>必須附著在 Coordinator 或 Router 上</li>
<li>不能路由 只能接收</li>
<li>可睡眠</li>
</ul>
</li>
</ul>
<h4 id="Device-Announce-加入網路時所發送的訊息"><a href="#Device-Announce-加入網路時所發送的訊息" class="headerlink" title="Device Announce (加入網路時所發送的訊息)"></a>Device Announce (加入網路時所發送的訊息)</h4><p><img src="/images/20231119024617.png"><br>Device Type(IEEE-802.15.4定义了两种设备类型)：</p>
<ul>
<li>FFD(Full Function Device), 全功能设备，能够执行IEEE 802.15.4标准中描述的所有职责，并且可以在网络中担任任何角色。Coordinator&#x2F;Router</li>
<li>RFD(Reduced Function Device), 剪裁功能设备，功能有限。 End Device&#x2F; Sleepy End Device</li>
</ul>
<blockquote>
<p>RFD设备的处理能力和内存大小通常小于FFD设备。<br><img src="/images/20231119024634.png"><br>Alternate PAN Coordination 標示是否為 Coordinator<br><img src="/images/20231119024648.png"><br>Power Source Main 電源供電或者電池供電</p>
</blockquote>
<h4 id="網路地址-Addressing-PAN-ID-and-xPan-ID-Extended-PAN-ID"><a href="#網路地址-Addressing-PAN-ID-and-xPan-ID-Extended-PAN-ID" class="headerlink" title="網路地址 Addressing PAN ID and (xPan ID)Extended PAN ID"></a>網路地址 Addressing PAN ID and (xPan ID)Extended PAN ID</h4><p><img src="/images/20231119024701.png"></p>
<ul>
<li>PAN ID: 短的(不唯一) 16bit 由用戶或Coordinator隨機生成 用於mac層過濾用 0xFFFF 用於廣播 </li>
<li>xPan ID: 長的(唯一值) Coordinator隨機生成 只有在Beacon會傳送  用於解決PAN ID衝突</li>
</ul>
<blockquote>
<p>低速通訊技術 250kpbs 有效數據負荷占比低(mac頭部 network頭部…) 如果每次用64bit效數據負荷占比低 所以用短的網路地址</p>
</blockquote>
<blockquote>
<p>mac層收到不是自己的PAN ID 就丟掉</p>
</blockquote>
<p><img src="/images/20231119024719.png"><br>☝️Beacon的封包</p>
<h4 id="設備地址-Addressing-Node-ID-and-IEEE-Address"><a href="#設備地址-Addressing-Node-ID-and-IEEE-Address" class="headerlink" title="設備地址 Addressing Node ID and IEEE Address"></a>設備地址 Addressing Node ID and IEEE Address</h4><ul>
<li>Node ID(Short ID) 16bits加入網路時父節點分配 可能會衝突</li>
<li>IEEE Address(Long ID) 64bits (MAC Address) 出廠就設定好 解決Node ID衝突<br>再傳送的時候用NodeID傳送<br>如果出現衝突就更改NodeID</li>
</ul>
<h3 id="Zigbee-應用層"><a href="#Zigbee-應用層" class="headerlink" title="Zigbee 應用層"></a>Zigbee 應用層</h3><h4 id="EndPoint-有點像Port的概念-範圍0-255"><a href="#EndPoint-有點像Port的概念-範圍0-255" class="headerlink" title="EndPoint 有點像Port的概念 範圍0-255"></a>EndPoint 有點像Port的概念 範圍0-255</h4><p><img src="/images/20231119024733.png"></p>
<p>EndPoint 1-239 用戶開發用<br>EndPoint 0, 240-255 保留用 0(ZDO Zigbee設備管理用) 255 廣播所有EndPoint</p>
<p>Endpoints存在於每個節點中，以1~240的數字編號，<br>每個endpoint定義了一個在ZigBee節點上運行的application<br>(一個node可以有多個applications，也就是多個endpoints)</p>
<p>Endpoints的三個用途：</p>
<ul>
<li>允許不同的app profiles存在於一個節點</li>
<li>允許一個節點中的不同控制點</li>
<li>允許一個節點中有不同的devices<br><img src="/images/20231119024755.png"><br>通訊是 EndPoint to EndPoint<br>一個當 Client 一個當 Server<br>通訊內容是由<strong>Cluster</strong>格式定義<br><img src="/images/20231119024811.png"><br>Cluster: 通訊Model<br>Client&#x2F;Server model<br>每一個Cluster定義一個功能(On&#x2F;Off Cluster、Level Cluster) ZCL(Zigbee Cluster Library)<br>定義命令和屬性<br><img src="/images/20231119024826.png"><br>以控制燈開關為例 開關為Client 燈為Server<br>On&#x2F;Off Cluster:<br>Commend: OnOff、Toggle<br>Attribute: On、Off</li>
</ul>
<blockquote>
<p>Cluster大多定義好了功用的 但也可以客製化定義 但這樣就不通用</p>
</blockquote>
<h2 id="安全特性-偽造-重傳"><a href="#安全特性-偽造-重傳" class="headerlink" title="安全特性(偽造 重傳)"></a>安全特性(偽造 重傳)</h2><h3 id="應用層安全"><a href="#應用層安全" class="headerlink" title="應用層安全"></a>應用層安全</h3><p><img src="/images/20231119024856.png"><br>將Applocation層的Payload加密 中間加安全頭部 然後算出Hash值 加到最後面往下傳<br>通過檢查Hash值(APS MIC)檢查應用層有無被篡改</p>
<h3 id="網路層安全"><a href="#網路層安全" class="headerlink" title="網路層安全"></a>網路層安全</h3><p><img src="/images/20231119024909.png"><br>將Network層的Payload加密 中間加安全頭部 然後算出Hash值 加到最後面往下傳<br>通過檢查Hash值(NWK MIC)檢查應用層有無被篡改</p>
<blockquote>
<p>應用層網路層對稱加密: AES128<br><img src="/images/20231119024953.png"><br>安全頭部(APS Auxiliary HDR、NWK Auxiliary HDR)有Frame Counter防止重傳</p>
</blockquote>
<h3 id="Frame-Counter-防止重傳"><a href="#Frame-Counter-防止重傳" class="headerlink" title="Frame Counter 防止重傳"></a>Frame Counter 防止重傳</h3><p><img src="/images/20231119025007.png"><br>接收端會記錄收到的 FrameCounter 如果接收到一樣就會丟掉封包 (只會紀錄周圍節點的FrameCounter)<br>發送端每次發送封包時會將 FrameCounter++ 達到每次FrameCounter都不一樣</p>
<h3 id="安全特點-端到端-點到點"><a href="#安全特點-端到端-點到點" class="headerlink" title="安全特點 端到端 點到點"></a>安全特點 端到端 點到點</h3><p><img src="/images/20231119025021.png"><br>NodeA傳到NodeC 中間NodeB不會去解開APS層的資料 NodeB只會解開網路層的資料<br>APS層是 端到端 端跟端之間有秘鑰(Link Key)<br>網路層是 點到點 點跟點之間有秘鑰(NWK Key)</p>
<h3 id="NWK-Key"><a href="#NWK-Key" class="headerlink" title="NWK Key"></a>NWK Key</h3><p><img src="/images/20231119025033.png"></p>
<ul>
<li>整個網路用的NWK Key都是一樣</li>
<li>在創建網路時隨機生成 16-byte</li>
<li>NWK 靠應用層加密傳輸</li>
<li>Trust Center: 提供NWK Key的裝置(通常是Coordinator)</li>
<li>有兩種模式 Centralized Distrbuted</li>
</ul>
<h4 id="傳送-NWK-Key"><a href="#傳送-NWK-Key" class="headerlink" title="傳送 NWK Key"></a>傳送 NWK Key</h4><h3 id="Link-Key"><a href="#Link-Key" class="headerlink" title="Link Key"></a>Link Key</h3><ul>
<li>16-byte</li>
<li>Trust Center Link Key 新設備加入網路傳送NWK key</li>
<li>(install code[出廠設定] + 算法) 或 (<strong>ZigbeeAlliance09</strong>)</li>
</ul>
<h4 id="install-code-是透過人工完成的-更安全"><a href="#install-code-是透過人工完成的-更安全" class="headerlink" title="install code 是透過人工完成的 更安全"></a>install code 是透過人工完成的 更安全</h4><p><img src="/images/20231119025052.png"></p>
<h2 id="加入網路"><a href="#加入網路" class="headerlink" title="加入網路"></a><a href="https://blog.csdn.net/lee_jimmy/article/details/109162896">加入網路</a></h2><h3 id="通用Link-Key-ZigbeeAlliance09"><a href="#通用Link-Key-ZigbeeAlliance09" class="headerlink" title="通用Link Key(ZigbeeAlliance09)"></a>通用Link Key(ZigbeeAlliance09)</h3><p><img src="/images/20231119025110.png"></p>
<ul>
<li>Coordinator 創建網路 設定PAN ID、xPAN ID、通道、功率</li>
<li>設備可以加入網路</li>
<li>掃描網路，新設備在每個通道發起Beacon Request等待有無回應 無回應往下一個通道發Beacon Request (因為不知道所以全發)</li>
<li>Coordinator收到Beacon Request回覆 一個Beacon(包含PAN ID xPAN ID…)</li>
<li>設備可能會收到很多Beacon，選擇用rssi最強當作父節點 再發送Association Request 包含(自己設備的能力…)</li>
<li>父節點發送Association Response(分配給他沒人用 Node ID)</li>
<li>等待接收NWK Key (Trust Center 會用Link Key(ZigbeeAlliance09)加密NWK Key) 用ZigbeeAlliance09解密</li>
<li>router会发送一个device announce的报文（从目的地址为广播地址可以看出）通知全网，我入网了、我的设备信息都有哪些。</li>
<li>之後就可以通訊了</li>
</ul>
<h3 id="使用Install-Code"><a href="#使用Install-Code" class="headerlink" title="使用Install Code"></a>使用Install Code</h3><p><img src="/images/20231119025123.png"></p>
<ul>
<li>Coordinator 創建網路 設定PAN ID、xPAN ID、通道、功率</li>
<li>設備可以加入網路</li>
<li>Coordinator 掃描 新設備Install Code建立Link Key</li>
<li>掃描網路，新設備在每個通道發起Beacon Request等待有無回應 無回應往下一個通道發Beacon Request (因為不知道所以全發)</li>
<li>Coordinator收到Beacon Request回覆 一個Beacon(包含PAN ID xPAN ID…)</li>
<li>設備可能會收到很多Beacon，選擇用rssi最強當作父節點 再發送Association Request 包含(自己設備的能力…)</li>
<li>父節點發送Association Response(分配給他沒人用 Node ID)</li>
<li>等待接收NWK Key (Trust Center 會用Link Key(由掃描到的Install Code建立)加密NWK Key) 用設備上的Install Code產生Link Key解密</li>
<li>router会发送一个device announce的报文（从目的地址为广播地址可以看出）通知全网，我入网了、我的设备信息都有哪些。</li>
<li>之後就可以通訊了</li>
</ul>
<p><a href="https://blog.csdn.net/u012993936/article/details/88225371">Zigbee抓包工具</a></p>
<ul>
<li>Packet Sniffer</li>
<li>Ubiqua</li>
<li>Wireshark <ul>
<li><a href="https://segmentfault.com/a/1190000041469759">手把手教你如何通过CC2531抓取Zigbee包，并解析加密Zigbee包</a></li>
<li><a href="https://www.twblogs.net/a/5b8f25562b717718834a0ac9">使用CC2531 USB Dongle 抓取小米Zigbee智能硬件數據包</a></li>
<li><a href="https://www.ruten.com.tw/find/?q=+CC2531">露天CC2531</a></li>
<li><a href="https://www.twblogs.net/a/5c80fb1fbd9eee35fc136d05">如何用Wireshark對Zigbee進行抓包分析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/489493842">ZigBee 无线报文的抓取与分析</a></li>
<li><a href="https://item.taobao.com/item.htm?id=657969866117">USB Dongle CC2530 CC2531 ZigBee 协议栈 分析 抓包 工具 模块</a></li>
<li><a href="http://bbs.sunsili.com/thread-226165-1-1.html">利用Wireshark对Zigbee进行抓包分析</a></li>
</ul>
</li>
</ul>
<h2 id="认识Profile和Cluster"><a href="#认识Profile和Cluster" class="headerlink" title="认识Profile和Cluster"></a><a href="https://blog.csdn.net/yanwumuxi/article/details/123866005">认识Profile和Cluster</a></h2><p><a href="https://community.nxp.com/pwmxy87654/attachments/pwmxy87654/wireless-connectivity/698/1/075367r03ZB_AFG-Home_Automation_Profile_for_Public_Download.pdf">Zigbee Profile</a><br><img src="/images/20231119025145.png"></p>
<hr>
<h3 id="Silicon-Labs-GeckoSDK"><a href="#Silicon-Labs-GeckoSDK" class="headerlink" title="Silicon Labs GeckoSDK"></a>Silicon Labs GeckoSDK</h3><ul>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug491-zigbee-app-framework-dev-guide-sdk-7x.pdf">zigbee-app-framework-dev-guide-sdk-pdf</a></li>
<li><a href="https://community.silabs.com/s/question/0D58Y00008aZEGPSA4/hello-im-working-on-a-zigbee-minimals-project-with-the-efr32-xxx-and-i-would-like-to-ask-you-how-to-create-a-callback-to-do-an-action-every-5-minutes-thank-you?language=zh_TW">New Callback</a></li>
<li><a href="https://github.com/SiliconLabs/IoT-Developer-Boot-Camp/wiki/Zigbee-Boot-Camp">Zigbee-Boot-Camp</a></li>
<li><a href="https://www.silabs.com/wireless/zigbee/efr32mg24-series-2-modules/device.mgm240pa32vnn?tab=specs">MGM240PA32VNN</a></li>
<li><a href="https://blog.csdn.net/lexiyao/article/details/109153280">Zigbee应用程序框架开发指南 - 概述</a></li>
<li><a href="https://www.sekorm.com/news/30245981.html">【经验】EmberZnet CLI指令之绑定功能实现过程</a></li>
<li><a href="https://blog.csdn.net/yanwumuxi/article/details/123866005">Zigbee Profile</a></li>
<li><a href="https://community.silabs.com/s/article/zigbee-3-0-tutorial-light-and-switch-from-scratch-step-5?language=en_US">ZigBee 3.0 Tutorial - Light and Switch from Scratch</a></li>
<li><a href="https://github.com/SiliconLabs/zigbee_applications/tree/a90ebc1e6a06ac7dd1e158f435f58e910595a477">zigbee_applications example</a></li>
<li><a href="https://space.bilibili.com/641942011/channel/seriesdetail?sid=726018">bilibili</a></li>
<li><a href="https://workshop.siliconforce.com/?p=862">Silicon Labs EFM8 的 Hello World 程式</a></li>
</ul>
<hr>
<h3 id="TI-Z-Stack"><a href="#TI-Z-Stack" class="headerlink" title="TI Z-Stack"></a>TI Z-Stack</h3><ul>
<li><a href="https://www.ti.com/zh-tw/homepage.html">Texas Instruments</a></li>
<li><a href="https://software-dl.ti.com/simplelink/esd/plugins/simplelink_zigbee_sdk_plugin/1.60.01.09/exports/docs/zigbee_user_guide/html/zigbee/introduction.html">TI Z-Stack User Guide</a></li>
<li><a href="https://www.bilibili.com/video/BV1d94y117kj/">ZigBee开发-嵌入式物联网开发教程学习</a></li>
<li><a href="https://blog.csdn.net/yanwumuxi/article/details/126485087">Zigbee学习（三）Z-Stack代码框架解析</a></li>
<li><a href="https://blog.csdn.net/yanwumuxi/article/details/131128082">Zigbee学习（四）入网流程及抓包分析</a></li>
<li><a href="https://docs.wireless-tech.cn/doc/101/">Zigbee驱动安装-抓包环境搭建</a></li>
<li><a href="https://blog.csdn.net/lixiaocheng1983/article/details/123090679?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5-123090679-blog-88225371.235%5Ev38%5Epc_relevant_sort_base1&spm=1001.2101.3001.4242.4&utm_relevant_index=8">手把手教你如何通过CC2531抓取Zigbee包，并解析加密Zigbee包</a></li>
</ul>
<hr>
<h3 id="zigpy"><a href="#zigpy" class="headerlink" title="zigpy"></a>zigpy</h3><p><a href="https://github.com/zigpy/zigpy">zigpy</a><br><a href="https://github.com/zigpy/zigpy-cli">zugpy-cli</a></p>
<h3 id="ZDO"><a href="#ZDO" class="headerlink" title="ZDO"></a><a href="https://www.wpgdadatong.com/question/detail/15822">ZDO</a></h3><p>提供了所有ZigBee设备共同的特殊应用，以管理已描述的各种过程。此应用程序是ZigBee设备对象或ZDO。它位于节点的应用层，并且可以使用 ZigBee设备配置文件（ZDP）和相关 cluster通过端点0与远程节点通信。它具有以下作用：</p>
<ol>
<li>定义网络设备的类型：协调器、路由器或终端设备</li>
<li>初始化节点以允许应用程序运行。</li>
<li>执行设备发现和服务发现过程。</li>
<li>实现允许协调器创建网络以及路由器和终端设备加入和离开网络所需的过程。</li>
<li>启动并响应绑定请求。</li>
<li>启动并响应绑定请求提供允许在应用程序之间建立安全关系的安全服务。</li>
<li>允许远程节点从节点检索信息，如路由表和绑定表，并执行节点的远程管理，如指示它离开网络。</li>
</ol>
<p>ZDO使用堆栈内的服务来实现这些角色，并提供了一种允许用户应用程序访问堆栈服务的方法。</p>
<p><a href="https://blog.csdn.net/qq_35413125/article/details/116986028">ZigBeePro协议栈词汇名词解释</a></p>
<p><a href="https://blog.csdn.net/Msymbol/article/details/111194158">Thread协议介绍</a><br><a href="https://iknow.stpi.narl.org.tw/Post/Read.aspx?PostID=10327">Thread可能取代Zigbee -ZHA並衝擊智慧家庭的通訊標準</a><br><a href="https://www.kocpc.com.tw/archives/476397">無線技術 Thread 是什麼？它會是智慧家庭的未來嗎？</a><br><a href="https://turadise.com/matter-thread/">Matter智慧家庭控制標準協定,用Thread整合智能居家控制系統</a></p>
]]></content>
      <categories>
        <category>zigbee</category>
      </categories>
      <tags>
        <tag>Zigbee</tag>
        <tag>IEEE802154</tag>
      </tags>
  </entry>
  <entry>
    <title>git@github.com Permission denied (publickey)</title>
    <url>/posts/20230505084825-9174ad3f.html</url>
    <content><![CDATA[<p>git clone permission denied(publickey)<br><img src="/images/pasted-0.png"><br>原因：git clone 沒有ssh的publickey<br>解決：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>如果沒有產生過公鑰，會產下面錯誤</p>
<blockquote>
<p>cat: &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directory</p>
</blockquote>
<p>使用ssh-keygen產公鑰(遇到提示按Enter)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p>將印出來的公鑰設定去<a href="https://github.com/settings/ssh/new">SSH Add New Key</a> or (GitHub &gt;&gt; Settings &gt;&gt; SSH and GPG keys &gt;&gt; New SSH key)<br><img src="/images/pasted-2.png"></p>
]]></content>
  </entry>
  <entry>
    <title>html隱藏元素的方法</title>
    <url>/posts/20240122061800-aae208a6.html</url>
    <content><![CDATA[<ol>
<li><a href="https://api.jquery.com/hide/">用jquery hide()的方式控制style</a><br> <code>$(&quot;.target&quot;).hide();</code></li>
<li><strong>用Html的方式直接更改hidden屬性</strong><br> <code>hidden=&quot;true&quot;</code></li>
<li><strong>用css style的方式直接更改display屬性</strong><br> <code>style=&#39;display:none&#39;</code></li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>hidden</tag>
      </tags>
  </entry>
  <entry>
    <title>lru_cache 不要亂用</title>
    <url>/posts/20250219081500-6a4c0b66.html</url>
    <content><![CDATA[<p> 今天發現跑的一支python程式裡面，我的記憶體不斷上漲，<br> 使用好幾套監測套件</p>
<ul>
<li>tracemalloc</li>
<li>objgraph<br> 找來找去都找不到哪裡記憶體增加<br> 已知大概範圍，但不管如何 <code>del</code>，<code>gc</code> 也呼叫了記憶體還是蹭蹭蹭往上漲，<br> 我以為是我這邊的問題，因為我大部分都是互叫別人的套件，徹底檢查我的程式碼也沒有看到哪裡有洩漏可能，我這支程式是去Influxdb拿資料，還一步步的去追到套件的程式碼也沒看出哪裡有問題，甚至印出所有物件，看是否有循環引用的問題，分析半天也沒看出來 <span id="more"></span></li>
</ul>
<p>最後去查套件的每一行code，無意間在<a href="https://github.com/Javidjms/influxable/blob/develop/influxable/db/query.py">query.py</a>瞟到 cache ，@lru_cache(maxsize&#x3D;None)， 查了一下<a href="https://docs.python.org/zh-tw/3/library/functools.html#functools.lru_cache">官方文檔</a>這樣寫記憶體無線增長阿!<br>終於找出真正原因</p>
<p>但這個寫在裝飾器上沒辦法帶參數些改，最後好險可以透過繼承的手法覆蓋原本的方法，要不然我真的要換套件了，顆顆!!</p>
<p>我開了一個issus <a href="https://github.com/Javidjms/influxable/issues/31">Memory may grow indefinitely</a>再看開發者如何回復</p>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://medium.com/@jepersyne/python-functools-lru-cache-d5cb632df710">Python｜functools｜lru_cache</a></li>
<li><a href="https://docs.python.org/zh-tw/3/library/functools.html#functools.lru_cache">官方文檔</a></li>
</ul>
]]></content>
      <categories>
        <category>小日常</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>cache</tag>
        <tag>memory_leak</tag>
      </tags>
  </entry>
  <entry>
    <title>python進度條tqdm</title>
    <url>/posts/20240124061700-2ff23ae2.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在查網站時，無意間逛到<a href="https://stackoverflow.com/questions/276052/how-to-get-current-cpu-and-ram-usage-in-python/69511430#69511430">stackoverflow</a>，有人用python的tqdm顯示記憶體和cpu的使用量，看起來有點酷炫，就來複製貼上玩一下吧，也可以用在python需要耗時的程式上，也不用一直print log看起來非常亂。<br> <span id="more"></span></p>
<h1 id="tqdm"><a href="#tqdm" class="headerlink" title="tqdm"></a>tqdm</h1><h2 id="pip-安裝-tqdm"><a href="#pip-安裝-tqdm" class="headerlink" title="pip 安裝 tqdm"></a>pip 安裝 tqdm</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m pip install tqdm </span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">pip3 install tqdm</span><br></pre></td></tr></table></figure>
<h2 id="複製程式碼"><a href="#複製程式碼" class="headerlink" title="複製程式碼"></a>複製程式碼</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> tqdm(total=<span class="number">100</span>, desc=<span class="string">&#x27;cpu%&#x27;</span>, position=<span class="number">1</span>) <span class="keyword">as</span> cpubar, tqdm(total=<span class="number">100</span>, desc=<span class="string">&#x27;ram%&#x27;</span>, position=<span class="number">0</span>) <span class="keyword">as</span> rambar:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        rambar.n=psutil.virtual_memory().percent</span><br><span class="line">        cpubar.n=psutil.cpu_percent()</span><br><span class="line">        rambar.refresh()</span><br><span class="line">        cpubar.refresh()</span><br><span class="line">        sleep(<span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>
<h2 id="看看成果"><a href="#看看成果" class="headerlink" title="看看成果"></a>看看成果</h2><p><img src="/images/20240124113531.gif"><br>是不是非常酷炫<br><code>tqdm(total=100, desc=&#39;cpu%&#39;, position=1) as cpubar</code><br><code>tqdm(total=100, desc=&#39;ram%&#39;, position=0) as rambar</code><br>個別宣告兩個進度條 <code>position</code>是顯示在第幾條位置<br>然後用<code>.n</code>更新值，再用 <code>.refresh()</code>去刷新terminal</p>
<h2 id="再上範例1-單進程"><a href="#再上範例1-單進程" class="headerlink" title="再上範例1 單進程"></a>再上範例1 單進程</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">total = <span class="number">300</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>
<p>假設任務有300個 ++ 就算完成 每次都print 一下<br>結果如下，就會非常凌亂，不夠炫炮<br><img src="/images/20240125155025.png"></p>
<h3 id="使用-tqdm"><a href="#使用-tqdm" class="headerlink" title="使用 tqdm"></a>使用 tqdm</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line">total = <span class="number">300</span></span><br><span class="line">progress = tqdm(total=total, desc=<span class="string">&#x27;progress&#x27;</span>, position=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">    progress.set_description(<span class="string">f&#x27;Processing: <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">    progress.update()</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>這裡也假設任務有300個 ++ 就算完成 每次都去 <code>update()</code> 進度條一下<br><code>update()</code>就是去++ 進度條的值 因為 total 有設定 所以會自動算出完成度幾 percent<br><img src="/images/20240125160318.gif"><br>套用在自己耗時的程式馬上，就不會印的很凌亂，非常直覺</p>
<h2 id="再上範例2-多進程"><a href="#再上範例2-多進程" class="headerlink" title="再上範例2 多進程"></a>再上範例2 多進程</h2><p><img src="/images/20240126102505.gif"><br>莫名其妙出現兩個 <code>ForkPoolWorker-4</code> 我認為是多進程的問題</p>
<blockquote>
<p>需要考慮競爭的問題</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool, Lock</span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">job</span>(<span class="params">position</span>):</span><br><span class="line">    total = <span class="number">300</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    progress = tqdm(total=total, desc=<span class="string">&#x27;progress&#x27;</span>, position=position)</span><br><span class="line">    lock.release()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(total):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        progress.set_description(<span class="string">f&#x27;Processing- <span class="subst">&#123;multiprocessing.current_process().name&#125;</span>: <span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        progress.update()</span><br><span class="line">        lock.release()</span><br><span class="line">        sleep(<span class="number">0.1</span>)  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># start 4 worker processes</span></span><br><span class="line">    lock = Lock()</span><br><span class="line">    pool = Pool(processes=<span class="number">4</span>)</span><br><span class="line">    pool.apply_async(job, (<span class="number">0</span>,)) </span><br><span class="line">    pool.apply_async(job, (<span class="number">1</span>,)) </span><br><span class="line">    pool.apply_async(job, (<span class="number">2</span>,)) </span><br><span class="line">    pool.apply_async(job, (<span class="number">3</span>,))  </span><br><span class="line">    </span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="/images/20240126102729.gif"><br>上一個鎖之後就沒出現，上面的情況了，大家可以把所拿掉玩玩看</p>
<h1 id="PyCharm-無法正常顯示"><a href="#PyCharm-無法正常顯示" class="headerlink" title="PyCharm 無法正常顯示"></a>PyCharm 無法正常顯示</h1><p><img src="/images/20240128115759.png"><br>打開執行的腳本 Edit Configurations<br><img src="/images/20240128120322.png"><br>找到 Execution 底下 Emulate terminal in output console 打勾<br>在OK 或 Apply 就可以了</p>
<h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>tqdm 為自己的程式看上去可以更專業，裡面還有一些參數沒有說明，大家可以去看文件了嘗試一下，另外多進程也要考慮資源共搶的情況</p>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://stackoverflow.com/questions/276052/how-to-get-current-cpu-and-ram-usage-in-python/69511430#69511430">stackoverflow</a></li>
<li><a href="https://tqdm.github.io/">tqdm documentation</a></li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>裝B</tag>
        <tag>酷炫</tag>
      </tags>
  </entry>
  <entry>
    <title>share_file_descriptor(shrare fd)</title>
    <url>/posts/20240319071000-8084e2f0.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在處理影像buffer時，範例在建立buffer記憶體是用其他 library去生成，影像 buffer 是通過mmap 去取的，但是我需要其他進程也可以拿到這個 buffer ，</p>
<p>有種做法是完整複製buffer，然後開一塊share memory處理，但是這樣會造成cpu一直在copy<br>還有種作法是找到 file descriptor 參照哪個檔案，但查詢了許久，我無法得知 file descriptor 是參照哪個檔案，<br> <span id="more"></span><br> 所以目前的做法是將 mmap 參照的 file descriptor 共享給其他進程使用。</p>
<h2 id="解決思路"><a href="#解決思路" class="headerlink" title="解決思路"></a>解決思路</h2><p>網路上有找到兩種可行辦法，一個是用syscall ，一個是透過 domain socket<br>用syscall的辦法很簡單，代碼也很少，但是要linux kernel比較高的版本<br>所以目前先嘗試使用 domain socket</p>
<h2 id="server-端-share-fd-set-c"><a href="#server-端-share-fd-set-c" class="headerlink" title="server 端 (share_fd_set.c)"></a>server 端 (share_fd_set.c)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write_fd</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes, <span class="type">int</span> sendfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;file.txt&quot;</span>, O_RDWR | O_CREAT, <span class="number">0644</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open &lt;%s&gt; failed: %s\n&quot;</span>, <span class="string">&quot;file.txt&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fd: %d\n&quot;</span>, fd); </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">server_addr</span>, <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sun_family = AF_UNIX;</span><br><span class="line">    unlink(<span class="string">&quot;/tmp/socket&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(server_addr.sun_path, <span class="string">&quot;/tmp/socket&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(sockfd, <span class="number">5</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;等待連接\n&quot;</span>);</span><br><span class="line">    <span class="type">socklen_t</span> client_len =  <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">int</span> clientfd = accept(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_len);</span><br><span class="line">    <span class="keyword">if</span> (clientfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (write_fd(clientfd, buffer, <span class="number">100</span>, fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;sendmsg error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;傳輸完畢\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    close(sockfd);</span><br><span class="line">    close(clientfd);</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write_fd</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes, <span class="type">int</span> sendfd)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span>   <span class="title">msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>    <span class="title">iov</span>[1];</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span>    <span class="title">cm</span>;</span></span><br><span class="line">      <span class="type">char</span>              control[CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="type">int</span>))];</span><br><span class="line">    &#125; control_un;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span>  *<span class="title">cmptr</span>;</span></span><br><span class="line"></span><br><span class="line">    msg.msg_control = control_un.control;</span><br><span class="line">    msg.msg_controllen = <span class="keyword">sizeof</span>(control_un.control);</span><br><span class="line"></span><br><span class="line">    cmptr = CMSG_FIRSTHDR(&amp;msg);</span><br><span class="line">    cmptr-&gt;cmsg_len = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    cmptr-&gt;cmsg_level = SOL_SOCKET;</span><br><span class="line">    cmptr-&gt;cmsg_type = SCM_RIGHTS;</span><br><span class="line">    *((<span class="type">int</span> *) CMSG_DATA(cmptr)) = sendfd;</span><br><span class="line"></span><br><span class="line">    msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = ptr;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = nbytes;</span><br><span class="line">    msg.msg_iov = iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(sendmsg(fd, &amp;msg, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="client-端-share-fd-get-c"><a href="#client-端-share-fd-get-c" class="headerlink" title="client 端 (share_fd_get.c)"></a>client 端 (share_fd_get.c)</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read_fd</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes, <span class="type">int</span> *recvfd)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> sockfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">server_addr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    sockfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置服务器地址结构体</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    server_addr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strcpy</span>(server_addr.sun_path, <span class="string">&quot;/tmp/socket&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定套接字</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> targetfd;</span><br><span class="line">    <span class="type">int</span> ret = read_fd(sockfd, buffer, <span class="number">100</span>, &amp;targetfd);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;read_fd error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;receive %d %s\n&quot;</span>, <span class="number">100</span>, buffer);</span><br><span class="line"> </span><br><span class="line">    <span class="type">void</span> *address = mmap(<span class="literal">NULL</span>, <span class="number">100</span>, PROT_READ, MAP_SHARED, targetfd, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;targetfd %d ,address %p\n&quot;</span>, targetfd, address);</span><br><span class="line">    close(targetfd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sockfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        close(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read_fd</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *ptr, <span class="type">size_t</span> nbytes, <span class="type">int</span> *recvfd)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span>   <span class="title">msg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>    <span class="title">iov</span>[1];</span></span><br><span class="line">    <span class="type">ssize_t</span>         n;</span><br><span class="line">    <span class="type">int</span>             newfd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span>    <span class="title">cm</span>;</span></span><br><span class="line">      <span class="type">char</span>              control[CMSG_SPACE(<span class="keyword">sizeof</span>(<span class="type">int</span>))];</span><br><span class="line">    &#125; control_un;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span>  *<span class="title">cmptr</span>;</span></span><br><span class="line"></span><br><span class="line">    msg.msg_control = control_un.control;</span><br><span class="line">    msg.msg_controllen = <span class="keyword">sizeof</span>(control_un.control);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = ptr;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = nbytes;</span><br><span class="line">    msg.msg_iov = iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recvmsg\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( (n = recvmsg(fd, &amp;msg, <span class="number">0</span>)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>(n);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recvmsg n %ld\n&quot;</span>, n);</span><br><span class="line">    cmptr = CMSG_FIRSTHDR(&amp;msg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;cmptr %p\n&quot;</span>, cmptr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( cmptr != <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        cmptr-&gt;cmsg_len == CMSG_LEN(<span class="keyword">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cmptr-&gt;cmsg_level != SOL_SOCKET) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;control level != SOL_SOCKET\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">           </span><br><span class="line">        <span class="keyword">if</span> (cmptr-&gt;cmsg_type != SCM_RIGHTS) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;control type != SCM_RIGHTS&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        *recvfd = *((<span class="type">int</span> *) CMSG_DATA(cmptr));</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        *recvfd = <span class="number">-1</span>;       <span class="comment">/* descriptor was not passed */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="編譯"><a href="#編譯" class="headerlink" title="編譯"></a>編譯</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc  share_fd_set.c -o share_fd_set</span><br><span class="line">gcc  share_fd_get.c -o share_fd_get</span><br><span class="line"><span class="built_in">chmod</span> +x share_fd_set</span><br><span class="line"><span class="built_in">chmod</span> +x share_fd_get</span><br></pre></td></tr></table></figure>
<h2 id="執行"><a href="#執行" class="headerlink" title="執行"></a>執行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./share_fd_set</span><br><span class="line">fd: 3</span><br><span class="line">等待連接</span><br><span class="line">./share_fd_get</span><br><span class="line">recvmsg</span><br><span class="line">recvmsg n 100</span><br><span class="line">cmptr 0x7ffd7979b020</span><br><span class="line">receive 100 </span><br><span class="line">targetfd 4 ,address 0x7ffbceec2000</span><br></pre></td></tr></table></figure>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://stackoverflow.com/questions/2358684/can-i-share-a-file-descriptor-to-another-process-on-linux-or-are-they-local-to-t/2358843#2358843">stackoverflow share fd</a></li>
<li><a href="https://www.cnblogs.com/super119/archive/2012/09/11/2680006.html">Linux通过sendmsg来在进程中share FD</a></li>
</ul>
]]></content>
      <categories>
        <category>IPC</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>IPC</tag>
        <tag>fd</tag>
      </tags>
  </entry>
  <entry>
    <title>sonarqube</title>
    <url>/posts/20240905065000-5675f0f1.html</url>
    <content><![CDATA[<h1 id="Sonarqube-服務"><a href="#Sonarqube-服務" class="headerlink" title="Sonarqube 服務"></a>Sonarqube 服務</h1><h2 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --name sonarqube -p 9000:9000 -p 9092:9092 sonarqube</span><br></pre></td></tr></table></figure>
<h2 id="docker-compose-96"><a href="#docker-compose-96" class="headerlink" title="docker compose&#96;"></a>docker compose&#96;</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">sonarqube:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">sonarqube:community</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">SONAR_JDBC_URL:</span> <span class="string">jdbc:postgresql://db:5432/sonar</span></span><br><span class="line">      <span class="attr">SONAR_JDBC_USERNAME:</span> <span class="string">sonar</span></span><br><span class="line">      <span class="attr">SONAR_JDBC_PASSWORD:</span> <span class="string">sonar</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sonarqube_data:/opt/sonarqube/data</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sonarqube_extensions:/opt/sonarqube/extensions</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">sonarqube_logs:/opt/sonarqube/logs</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;9000:9000&quot;</span></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres:12</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">POSTGRES_USER:</span> <span class="string">sonar</span></span><br><span class="line">      <span class="attr">POSTGRES_PASSWORD:</span> <span class="string">sonar</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgresql:/var/lib/postgresql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">postgresql_data:/var/lib/postgresql/data</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">sonarqube_data:</span></span><br><span class="line">  <span class="attr">sonarqube_extensions:</span></span><br><span class="line">  <span class="attr">sonarqube_logs:</span></span><br><span class="line">  <span class="attr">postgresql:</span></span><br><span class="line">  <span class="attr">postgresql_data:</span></span><br></pre></td></tr></table></figure>

<h1 id="SonarScanner啟動器"><a href="#SonarScanner啟動器" class="headerlink" title="SonarScanner啟動器"></a><a href="https://docs.sonarsource.com/sonarqube/9.9/analyzing-source-code/scanners/sonarscanner/">SonarScanner</a>啟動器</h1> <span id="more"></span>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-6.1.0.4477-linux-x64.zip</span><br><span class="line">unzip sonar-scanner-cli-6.1.0.4477-linux-x64.zip</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="subst">$(pwd)</span>/sonar-scanner-6.1.0.4477-linux-x64/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="訪問-localhost-9000"><a href="#訪問-localhost-9000" class="headerlink" title="訪問 localhost:9000"></a>訪問 <a href="http://localhost:9000/">localhost:9000</a></h1><h2 id="預設帳密-admin-x2F-admin"><a href="#預設帳密-admin-x2F-admin" class="headerlink" title="預設帳密 admin&#x2F;admin"></a>預設帳密 admin&#x2F;admin</h2><p><img src="/images/20240905135340.png"></p>
<h2 id="建立專案"><a href="#建立專案" class="headerlink" title="建立專案"></a>建立專案</h2><p>點擊<a href="http://localhost:9000/tutorials?id=Test&selectedTutorial=local">create local project</a><br><img src="/images/20240905135413.png"><br>輸入專案名稱 點擊Next<br><img src="/images/20240905135503.png"><br>點擊Use the glogal setting<br><img src="/images/20240905135545.png"></p>
<h2 id="建立分析"><a href="#建立分析" class="headerlink" title="建立分析"></a>建立分析</h2><p>點擊Locally<br><img src="/images/20240905135622.png"><br>建立分析token<br><img src="/images/20240905135659.png"><br>點擊 continue<br><img src="/images/20240905135735.png"><br>複製 command<br><img src="/images/20240905143201.png"></p>
<h1 id="將資料夾內送上去服務分析"><a href="#將資料夾內送上去服務分析" class="headerlink" title="將資料夾內送上去服務分析"></a>將資料夾內送上去服務分析</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">&quot;project path&quot;</span></span><br><span class="line">sonar-scanner \</span><br><span class="line">  -Dsonar.projectKey=Test \</span><br><span class="line">  -Dsonar.sources=. \</span><br><span class="line">  -Dsonar.host.url=http://localhost:9000 \</span><br><span class="line">  -Dsonar.token=sqp_21fd7ffbfd319d6ef13a7afa8b1598b164c5c2c7</span><br></pre></td></tr></table></figure>

<p><img src="/images/20240905144822.png"><br>看到 EXECUTION SUCEESS 表示成功<br>點選 <a href="http://localhost:9000/dashboard?id=Test">http://localhost:9000/dashboard?id=Test</a> 查看分析結果</p>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://old-oomusou.goodjack.tw/sonarqube/docker/">如何使用 Docker 安裝 SonarQube？</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10294624">Day 8: 快快樂樂地用SonarQube進行檢測吧!</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>使用WebCodecs API對H264解碼</title>
    <url>/posts/20240122021600-ef8abaf3.html</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p>WebCodecs API 是可以讓開發者直接使用硬體資源，拿來處理影片或聲音，在還沒個出來之前大多的實作方法是用 webassembly 或是 原生 JavaScript 處理，這些方法需要多加載另外的資源，而且也無法使用到像是GPU的資源，使得效率低。</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><img src="/images/20240122092416.png"></p>
<ol>
<li><code>H264NALu</code> 轉成 <code>EncodedVideoChunk</code> 物件 <span id="more"></span></li>
<li>交給 <code>VideoDecoder</code> 做解碼 </li>
<li>產物為 <code>VideoFrame</code> 會後交給 <code>Canvas</code> 渲染<br>其中 <code>EncodedVideoChunk</code> <code>VideoDecoder</code> <code>VideoFrame</code> 為  WebCodecs API 內物件</li>
</ol>
<h1 id="上程式"><a href="#上程式" class="headerlink" title="上程式"></a>上程式</h1><h2 id="建立-VideoDecoder"><a href="#建立-VideoDecoder" class="headerlink" title="建立 VideoDecoder"></a>建立 VideoDecoder</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleFrame</span>(<span class="params">frame</span>) &#123;</span><br><span class="line">	<span class="comment">// render by canvas</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = &#123;</span><br><span class="line">	<span class="attr">output</span>: handleFrame,</span><br><span class="line">	<span class="attr">error</span>: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">	  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">message</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">	<span class="attr">codec</span>: <span class="string">&quot;avc1.4d401e&quot;</span>,</span><br><span class="line">	<span class="attr">codedWidth</span>: <span class="number">1920</span>,</span><br><span class="line">	<span class="attr">codedHeight</span>: <span class="number">1080</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decoder = <span class="keyword">new</span> <span class="title class_">VideoDecoder</span>(init);</span><br><span class="line">decoder.<span class="title function_">configure</span>(config);</span><br></pre></td></tr></table></figure>
<p><code>handleFrame</code>為decoder解碼完產生<code>VideoFrame</code>的callback方法，產出的每一幀都會調用這個方法，之後就是交給 <code>Canvas</code> 渲染<br><code>init</code>和<code>config</code>使用配置<code>VideoDecoder</code>的參數</p>
<blockquote>
<p>使用 <code>await VideoDecoder.isConfigSupported(config)</code><br> 檢查<code>config</code> 是否支援</p>
</blockquote>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/VideoDecoder">VideoDecoder</a></p>
<h2 id="將-H264NALU轉換成EncodedVideoChunk"><a href="#將-H264NALU轉換成EncodedVideoChunk" class="headerlink" title="將 H264NALU轉換成EncodedVideoChunk"></a>將 H264NALU轉換成<code>EncodedVideoChunk</code></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> init = &#123;</span><br><span class="line">  <span class="attr">type</span>: unit.<span class="property">type</span> === <span class="number">5</span> ? <span class="string">&#x27;key&#x27;</span> : <span class="string">&#x27;delta&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: h26XBuffer,</span><br><span class="line">  <span class="attr">timestamp</span>: timestamp,</span><br><span class="line">&#125;;</span><br><span class="line">chunk = <span class="keyword">new</span> <span class="title class_">EncodedVideoChunk</span>(init);</span><br><span class="line">decoder.<span class="title function_">decode</span>(chunk);</span><br></pre></td></tr></table></figure>
<p><code>EncodedVideoChunk</code> 初始化要分辨這一幀是 <code>key</code> 或 <code>delta</code> (使用NALu的unit_type)<br><code>key</code>:  IDR幀 關鍵幀<br><code>delta</code>: P幀 或 B幀<br>產生出來的 <code>chunk</code> 就可以餵到<code>decoder</code>去解碼了</p>
<h3 id="參考-1"><a href="#參考-1" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk/EncodedVideoChunk">EncodedVideoChunk</a></li>
<li><a href="/posts/20240116080900-8a796e7c.html" title="H264基礎知識">H264基礎知識</a></li>
</ul>
<h2 id="將Video渲染到Canva上"><a href="#將Video渲染到Canva上" class="headerlink" title="將Video渲染到Canva上"></a>將<code>Video</code>渲染到<code>Canva</code>上</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function handleFrame(frame) &#123;</span><br><span class="line">	const bitmap = await createImageBitmap(frame);</span><br><span class="line">	ctx.drawImage(bitmap, 0, 0);</span><br><span class="line">	frame.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>上述程式帶大家大致過一下WebCodecs API的流程，具體還有很多細節沒有說明，大家再小心服用，至於H265格式，可以參考<a href="/posts/20240125024300-49fdb147.html" title="使用WebCodecs API對H265解碼">使用WebCodecs API對H265解碼</a> </p>
<h1 id="參考-2"><a href="#參考-2" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://chenng.cn/posts/WebCodecs%E5%AF%B9%E9%9F%B3%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/">WebCodecs对音视频进行编码解码</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebCodecs_API">WebCodecs API</a></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>H264</tag>
        <tag>WebCodecsAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>使用WebCodecs API對H265解碼</title>
    <url>/posts/20240125024300-49fdb147.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這邊接續<a href="/posts/20240122021600-ef8abaf3.html" title="使用WebCodecs API對H264解碼">使用WebCodecs API對H264解碼</a>，現在處理H265格式，這裡的只是將程式碼有一點小改動</p>
<h1 id="差異"><a href="#差異" class="headerlink" title="差異"></a>差異</h1><h2 id="建立-VideoDecoder"><a href="#建立-VideoDecoder" class="headerlink" title="建立 VideoDecoder"></a>建立 VideoDecoder</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleFrame</span>(<span class="params">frame</span>) &#123;</span><br><span class="line">	<span class="comment">// render by canvas</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = &#123;</span><br><span class="line">	<span class="attr">output</span>: handleFrame,</span><br><span class="line">	<span class="attr">error</span>: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">	  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">message</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">	<span class="attr">codec</span>: <span class="string">&quot;hev1.1.6.L123.B0&quot;</span>,</span><br><span class="line">	<span class="attr">codedWidth</span>: <span class="number">1920</span>,</span><br><span class="line">	<span class="attr">codedHeight</span>: <span class="number">1080</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decoder = <span class="keyword">new</span> <span class="title class_">VideoDecoder</span>(init);</span><br><span class="line">decoder.<span class="title function_">configure</span>(config);</span><br></pre></td></tr></table></figure>
<p>這裡的不同的是  H264 和 H265 使用的 codec 不同</p>
<blockquote>
<p>使用 <code>await VideoDecoder.isConfigSupported(config)</code><br> <span id="more"></span><br>檢查<code>config</code> 是否支援</p>
</blockquote>
<p>H265目前在chrome上只支援硬解，可以參考底下的連結看看硬體是否支援，<br>如果硬體不行也可以下載支援H265軟硬解的 Chromium 試試看<br>附上採坑日常 <a href="/posts/20240123163300-3f5d67a6.html" title="20240123小日常">20240123小日常</a></p>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://github.com/StaZhu/enable-chromium-hevc-hardware-decoding">enable-chromium-hevc-hardware-decoding</a></li>
<li><a href="https://blog.csdn.net/Dontla/article/details/132752490?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-132752490-blog-135105844.235%5Ev40%5Epc_relevant_anti_vip&spm=1001.2101.3001.4242.2&utm_relevant_index=4">解决chrome浏览器不能播放H265….）DXVA Checker、GPU-Z</a></li>
<li><a href="https://codepen.io/danm8675123/pen/abNavqG">HEVC Video Test</a></li>
<li><a href="https://bluesky-soft.com/en/DXVAChecker.html">DXVAChecker</a></li>
</ul>
<h2 id="將-H265NALU轉換成EncodedVideoChunk"><a href="#將-H265NALU轉換成EncodedVideoChunk" class="headerlink" title="將 H265NALU轉換成EncodedVideoChunk"></a>將 H265NALU轉換成<code>EncodedVideoChunk</code></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> init = &#123;</span><br><span class="line">  <span class="attr">type</span>: unit.<span class="property">type</span> === <span class="number">19</span> ? <span class="string">&#x27;key&#x27;</span> : <span class="string">&#x27;delta&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: h26XBuffer,</span><br><span class="line">  <span class="attr">timestamp</span>: timestamp,</span><br><span class="line">&#125;;</span><br><span class="line">chunk = <span class="keyword">new</span> <span class="title class_">EncodedVideoChunk</span>(init);</span><br><span class="line">decoder.<span class="title function_">decode</span>(chunk);</span><br></pre></td></tr></table></figure>
<p><code>EncodedVideoChunk</code> 初始化要分辨這一幀是 <code>key</code> 或 <code>delta</code> (使用NALU的unit_type)<br>這裡的不同的是 NALU的 unit_type H264 和 H265 代表的不一樣，算出unit_type的方式也有所不同，<br>大家要非常的小心</p>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>H265 和 H264 使用 WebCodecs 的流程大致上沒有太大的區別，需要注意的是H265對於硬體的要求比較高，當今天硬體不支援時，該如何判斷，該如何處理，還有如何解析出H264 H265 unit_type，這也需要工程師閱讀資料得知了- 可以參考<a href="https://www.twblogs.net/a/5c6d2817bd9eee5c86dcca4a">HEVC&#x2F;H265幀類型判斷及NALU TYPE介紹</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>H265</tag>
        <tag>WebCodecsAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>信令服务器</title>
    <url>/posts/20241223082200-314296ad.html</url>
    <content><![CDATA[<p><strong>信令服务器</strong>是实时通信（如 WebRTC、VoIP 或视频会议）中的一个关键组件，用于交换必要的控制信息（信令）以建立和管理连接。信令服务器本身并不传输音视频或数据流，而是<strong>协助通信双方完成会话建立和参数协商</strong>。</p>
<hr>
<h3 id="信令服务器的核心功能"><a href="#信令服务器的核心功能" class="headerlink" title="信令服务器的核心功能"></a><strong>信令服务器的核心功能</strong></h3><ol>
<li><p><strong>身份验证与注册</strong></p>
<ul>
<li>确认用户的身份，并在需要时允许用户注册或登录到服务系统。</li>
</ul>
</li>
<li><p><strong>设备发现与配对</strong></p>
 <span id="more"></span>
<ul>
<li>在通信开始前，协助两端发现彼此，并共享必要的网络信息。</li>
</ul>
</li>
<li><p><strong>交换会话描述信息</strong></p>
<ul>
<li>使用协议（如 SDP）传递媒体会话参数（音频、视频格式、网络地址、端口等）。</li>
</ul>
</li>
<li><p><strong>网络穿越协助</strong></p>
<ul>
<li>协助处理 NAT 或防火墙问题（通常通过 STUN 和 TURN 服务器配合）。</li>
</ul>
</li>
<li><p><strong>状态同步与会话管理</strong></p>
<ul>
<li>处理连接建立、修改和终止的信令交换。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="信令服务器在-WebRTC-中的角色"><a href="#信令服务器在-WebRTC-中的角色" class="headerlink" title="信令服务器在 WebRTC 中的角色"></a><strong>信令服务器在 WebRTC 中的角色</strong></h3><p>在 WebRTC 中，信令服务器主要负责传递以下信息：</p>
<ol>
<li><p><strong>SDP（Session Description Protocol）</strong></p>
<ul>
<li>包括设备的音视频能力、编解码器信息、媒体轨道等。</li>
</ul>
</li>
<li><p><strong>ICE 候选信息</strong></p>
<ul>
<li>提供点对点通信所需的网络信息（IP 地址、端口等）。</li>
</ul>
</li>
<li><p><strong>控制消息</strong></p>
<ul>
<li>用于启动、结束或修改会话。</li>
</ul>
</li>
</ol>
<p><strong>信令协议示例：</strong></p>
<ul>
<li>WebSockets</li>
<li>HTTP(S) (通常使用 POST 或 GET)</li>
<li>XMPP (扩展消息和状态协议)</li>
<li>SIP (会话初始协议)</li>
</ul>
<hr>
<h3 id="信令服务器的实现"><a href="#信令服务器的实现" class="headerlink" title="信令服务器的实现"></a><strong>信令服务器的实现</strong></h3><h4 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a><strong>技术选型</strong></h4><p>信令服务器的实现可以基于多种技术，以下是常见选择：</p>
<ul>
<li><strong>语言</strong>：Node.js、Python、Java、Go 等。</li>
<li><strong>传输协议</strong>：WebSocket、HTTP&#x2F;HTTPS、SIP、XMPP 等。</li>
</ul>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>實作 Nginx 負載平衡 load balance</title>
    <url>/posts/20230417154300-ab2a7258.html</url>
    <content><![CDATA[<h2 id="三種-load-balancing-方法"><a href="#三種-load-balancing-方法" class="headerlink" title="三種 load balancing 方法"></a>三種 load balancing 方法</h2><ol>
<li>round-robin：預設值，會將請留輪流平均分配到每台伺服器上</li>
<li>lest-connected：會將請求分配到目前連接數最少的伺服器上</li>
<li>ip-hash：利用 hash-function 來決定使用者要被分配到的伺服器，此方法可以達到同一個使用者 (IP address) 每次連結的伺服器都是相同的</li>
</ol>
<h2 id="設定不同付載平衡模式"><a href="#設定不同付載平衡模式" class="headerlink" title="設定不同付載平衡模式"></a>設定不同付載平衡模式</h2> <span id="more"></span>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	upstream myapp &#123;</span><br><span class="line">		ip_hash; #付載平衡模式 round-robin(default 不寫), lest_conn , ip-hash</span><br><span class="line">		server srv1.example.com;</span><br><span class="line">		server srv2.example.com;</span><br><span class="line">		server srv3.example.com;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	server &#123;</span><br><span class="line">		listen 80;</span><br><span class="line"></span><br><span class="line">		location / &#123;</span><br><span class="line">			proxy_pass	 http://myapp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Round-robin-分配權重-weight"><a href="#Round-robin-分配權重-weight" class="headerlink" title="Round-robin 分配權重 weight"></a>Round-robin 分配權重 weight</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	upstream myapp &#123;</span><br><span class="line">		server srv1.example.com weight=3;</span><br><span class="line">		server srv2.example.com weight=2;</span><br><span class="line">		server srv3.example.com;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	server &#123;</span><br><span class="line">		listen 80;</span><br><span class="line"></span><br><span class="line">		location / &#123;</span><br><span class="line">			proxy_pass	 http://myapp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="備份-backup-backup-代表，所有伺服器都掛掉之後，此伺服器才會生效"><a href="#備份-backup-backup-代表，所有伺服器都掛掉之後，此伺服器才會生效" class="headerlink" title="備份 backup backup 代表，所有伺服器都掛掉之後，此伺服器才會生效"></a>備份 backup backup 代表，所有伺服器都掛掉之後，此伺服器才會生效</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	upstream myapp &#123;</span><br><span class="line">		server srv1.example.com weight=3;</span><br><span class="line">		server srv2.example.com backup;</span><br><span class="line">		server srv3.example.com;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	server &#123;</span><br><span class="line">		listen 80;</span><br><span class="line"></span><br><span class="line">		location / &#123;</span><br><span class="line">			proxy_pass	 http://myapp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="maxlist.xyz/2020/06/18/flask-nginx/">maxlist.xyz&#x2F;2020&#x2F;06&#x2F;18&#x2F;flask-nginx&#x2F;</a></li>
</ul>
]]></content>
      <tags>
        <tag>load_balance</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建webrtc服务器</title>
    <url>/posts/20241223100200-2469950e.html</url>
    <content><![CDATA[<p><a href="https://developer.aliyun.com/article/877670">如何搭建一个简单的webrtc服务器</a></p>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title>webrtc</title>
    <url>/posts/20230806170400-af856b41.html</url>
    <content><![CDATA[<h1 id="env"><a href="#env" class="headerlink" title="env"></a>env</h1><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">22.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設置非互動模式，更新包管理器並安裝必要軟體</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">    git curl python3 vim xz-utils lsb-release sudo file &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get clean &amp;&amp; <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y --no-install-recommends \</span></span><br><span class="line"><span class="language-bash">    ca-certificates &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    update-ca-certificates &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">rm</span> -rf /var/lib/apt/lists/*</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆 depot_tools 並設置 PATH</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git /opt/depot_tools</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 設置環境變數</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/opt/depot_tools:$PATH&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt</span></span><br></pre></td></tr></table></figure>
<h2 id="docker-compose-yml"><a href="#docker-compose-yml" class="headerlink" title="docker-compose.yml"></a>docker-compose.yml</h2><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webrtc-env:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">webrtc-env</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">./Dockerfile</span></span><br><span class="line">    <span class="attr">platform:</span> <span class="string">linux/amd64</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/media/hdd/webrtc:/opt/webrtc</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">always</span></span><br><span class="line">    <span class="attr">tty:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h1> <span id="more"></span>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> webrtc-checkout</span><br><span class="line"><span class="built_in">cd</span> webrtc-checkout</span><br><span class="line">fetch --nohooks webrtc</span><br><span class="line">gclient <span class="built_in">sync</span></span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./build/install-build-deps.sh</span><br><span class="line">gn gen out/Default</span><br><span class="line">ninja -C out/Default</span><br></pre></td></tr></table></figure>
<h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../</span><br><span class="line"><span class="built_in">mkdir</span> webrtc-android </span><br><span class="line"><span class="built_in">cd</span> webrtc-android </span><br><span class="line">fetch --nohooks webrtc_android</span><br><span class="line">gclient <span class="built_in">sync</span></span><br><span class="line"><span class="built_in">cd</span> src</span><br><span class="line">./build/install-build-deps.sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#產出來的檔案在/src/libwebrtc.aar</span></span><br><span class="line">./tools_webrtc/android/build_aar.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 20241225 不行使用</span></span><br><span class="line">gn gen out/Debug --args=<span class="string">&#x27;target_os=&quot;android&quot; target_cpu=&quot;arm&quot;&#x27;</span></span><br><span class="line"><span class="comment"># 參考 build_aar.py /tmp/tmp_2yg5wol/armeabi-v7a# cat args.gn</span></span><br><span class="line">gn gen out/Debug --args=<span class="string">&#x27;target_os=&quot;android&quot; target_cpu=&quot;arm&quot; enable_rust=true enable_rust_cxx=true&#x27;</span></span><br><span class="line"></span><br><span class="line">ninja -C out/Debug</span><br><span class="line"><span class="comment">#只build</span></span><br></pre></td></tr></table></figure>
<h1 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ../</span><br><span class="line"><span class="built_in">mkdir</span> webrtc-ios</span><br><span class="line"><span class="built_in">cd</span> webrtc-ios</span><br><span class="line">fetch --nohooks webrtc_ios</span><br><span class="line">gn gen out/ios_64 --args=<span class="string">&#x27;target_os=&quot;ios&quot; target_cpu=&quot;arm64&quot; target_environment=&quot;device&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li><a href="https://www.cnblogs.com/ai-tuge/p/14489588.html">webrtc全平台下载编译步骤详细说明</a></li>
<li><a href="https://webrtc.googlesource.com/src/+/main/docs/native-code/development/README.md#getting-the-code">WebRTC development</a></li>
<li><a href="https://webrtc.googlesource.com/src/+/main/docs/native-code/android/">WebRTC development android</a></li>
<li><a href="https://webrtc.googlesource.com/src/+/main/docs/native-code/ios/">WebRTC development ios</a></li>
<li><a href="https://webrtc.mthli.com/basic/webrtc-compilation/">编译源码</a></li>
<li></li>
</ul>
]]></content>
      <tags>
        <tag>WebRTC</tag>
      </tags>
  </entry>
</search>
