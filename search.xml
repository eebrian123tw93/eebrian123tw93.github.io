<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>20240123小日常</title>
    <url>/posts/20240123163300-3f5d67a6.html</url>
    <content><![CDATA[<h1 id="本文"><a href="#本文" class="headerlink" title="本文"></a>本文</h1><p>今天真是個又累又氣的一天。花了4小時找一個差異。事情是這樣子的：這陣子在做<a href="/posts/20240122021600-ef8abaf3.html" title="使用WebCodecs API對H264解碼">使用WebCodecs API對H264解碼</a>，接下來換H265。經過了幾次測試都發現我的瀏覽器無法支援H265的解碼。於是我跑去問主管該如何處理，他給我了他的經驗，他的電腦竟然可以用Chrome播放H265&#x2F;MP4的格式。我請他將檔案給我，讓我跑跑看，結果我的也不行。我以為主管的電腦有比較好，結果問之下也沒有。<br> <span id="more"></span></p>
<p>就這樣我有來來回回在網路找資源，還下載了其他瀏覽器測試，還另外下載解碼包<a href="https://www.codecguide.com/download_kl.htm">K-Lite Codec Pack</a>，結論都是無法。這樣搞了大概3個小時，結果最後我發現，在一個網站上竟然說在Intel 6代以後的CPU都支援H265解碼。我想我的是Intel® Core™ i7-10700處理器應該早就支援了。於是我就去安裝我內顯的驅動，猜怎麼著，還是不行。原來我電腦上有一張獨顯，那張獨顯完全不支援H265。用測試軟體<a href="https://bluesky-soft.com/en/DXVAChecker.html">DXVAChecker</a>跑獨顯和內顯的解碼能力，我真的要罵出髒話，獨顯的解碼能力竟然低於內顯，而且是低很多的檔次。想說這顆爛獨顯到底有何用，只是單純讓我外接的嗎？還是來考驗我的除錯能力？</p>
<p>就這樣我用內顯重開電腦之後，H265&#x2F;MP4的影片就可以播放了。真的是讓我浪費了好多時間和精力啊啊啊啊！<br><img src="/images/20240124094118.png"><br>上面這張是獨顯 <code>AMD Radeon™ HD 7470</code><br>下面這張是<code>Intel® Core™ i7-10700</code> 內顯 <code>Intel® UHD Graphics 630</code><br><img src="/images/20240124094050.png"></p>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://www.codecguide.com/download_kl.htm">Download K-Lite Codec Pack</a></li>
<li><a href="https://bluesky-soft.com/en/DXVAChecker.html">DXVAChecker</a></li>
<li><a href="https://www.cnblogs.com/lidabo/p/16742377.html">HEVC 软硬件的支持</a></li>
<li><a href="https://blog.csdn.net/Dontla/article/details/132752490">解决chrome浏览器不能播放H265视频播放问题……</a></li>
</ul>
]]></content>
      <categories>
        <category>小日常</category>
      </categories>
      <tags>
        <tag>H265</tag>
      </tags>
  </entry>
  <entry>
    <title>DMA (Direct Memory Access)</title>
    <url>/posts/20231118194800-e891e3a3.html</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p><img src="/images/20231119023846.png"><br>直接記憶體存取（Direct Memory Access，DMA） 獨立地直接讀寫系統記憶體，而不需中央處理器介入處理，減輕處理器負擔，減輕內核工作量</p>
<p>簡單來說，就是搬資料，不需要用到CPU的指令。換言之，搬資料時，CPU不用知道。要怎麼做可以確保搬的資料不會錯。</p>
<ol>
<li>要知道原始資料的位置。</li>
<li>要知道目地的位置。 <span id="more"></span></li>
<li>要知道要搬多少資料長度。</li>
</ol>
<h1 id="配置DMA-以SRAM到外部設備"><a href="#配置DMA-以SRAM到外部設備" class="headerlink" title="配置DMA(以SRAM到外部設備)"></a>配置DMA(以SRAM到外部設備)</h1><ul>
<li>從哪裡複製(要複製的地址) SRAM Address</li>
<li>複製的地址(複製目的地的地址) 外部設備 Address</li>
<li>DMA方向 從 SRAM 到 外部設備</li>
<li>傳輸資料大小</li>
<li>SRAM 地址自增 On or Off </li>
<li>外部設備 地址自增  On or Off</li>
</ul>
<h1 id="參考影片"><a href="#參考影片" class="headerlink" title="參考影片"></a>參考影片</h1><ul>
<li><a href="https://www.youtube.com/watch?v=2_X9qD12_pw">10行代码，就能让你真正理解DMA！你用的可能很少，但是在单片机中非常重要！</a></li>
</ul>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://sharing-icdesign-experience.blogspot.com/2014/05/dma.html">什麼是DMA ?</a></li>
<li><a href="https://blog.csdn.net/as480133937/article/details/104927922">【STM32】 DMA原理，步骤超细详解，一文看懂DMA</a></li>
</ul>
]]></content>
      <categories>
        <category>soc</category>
      </categories>
      <tags>
        <tag>DMA</tag>
      </tags>
  </entry>
  <entry>
    <title>H264基礎知識</title>
    <url>/posts/20240116080900-8a796e7c.html</url>
    <content><![CDATA[<h1 id="H264"><a href="#H264" class="headerlink" title="H264"></a>H264</h1><p>MPEG-4的⼀個組成部分–MPEG-4 Part 10，⼜叫Advanced Video Codec，因此常稱為MPEG-4 AVC或直接叫AVC</p>
<h1 id="I幀-B幀-P幀-IDR幀"><a href="#I幀-B幀-P幀-IDR幀" class="headerlink" title="I幀, B幀,P幀,IDR幀"></a>I幀, B幀,P幀,IDR幀</h1><p><img src="/images/20240116150548.png"></p>
<h2 id="I幀-關鍵幀"><a href="#I幀-關鍵幀" class="headerlink" title="I幀 關鍵幀"></a>I幀 關鍵幀</h2><h2 id="P幀-前向預測編碼幀"><a href="#P幀-前向預測編碼幀" class="headerlink" title="P幀 前向預測編碼幀"></a>P幀 前向預測編碼幀</h2><h2 id="B幀-雙向預測內插編碼幀"><a href="#B幀-雙向預測內插編碼幀" class="headerlink" title="B幀 雙向預測內插編碼幀"></a>B幀 雙向預測內插編碼幀</h2><h2 id="IDR幀-I-幀的一種-立即刷新"><a href="#IDR幀-I-幀的一種-立即刷新" class="headerlink" title="IDR幀  I 幀的一種 立即刷新"></a>IDR幀  I 幀的一種 立即刷新</h2><p>IDR 幀禁止後面的幀向自己前面的幀參照<br> <span id="more"></span></p>
<h2 id="GOP-兩個I幀之間的間隔"><a href="#GOP-兩個I幀之間的間隔" class="headerlink" title="GOP 兩個I幀之間的間隔"></a>GOP 兩個I幀之間的間隔</h2><p>完整編碼的幀叫 I幀，參考先前的 I 幀產生的只包含差異部分編碼的幀叫 P幀，還有一種參考前後的幀編碼的幀叫 B幀<br>H264採用的核心演算法是幀內壓縮和幀間壓縮，幀內壓縮是產生 I 幀的演算法，幀間壓縮是產生 B 幀和 P 幀的演算法</p>
<p>壓縮率 B幀 &gt; P幀 &gt; I幀<br>訊息量 I幀 &gt; P幀 &gt; B幀</p>
<p>幀特性看底下連結<br><a href="https://blog.csdn.net/qq_29350001/article/details/73770702">图像和流媒体 – I 帧,B帧,P帧,IDR帧的区别</a></p>
<h1 id="NALU-Network-Abstract-Layer-Unit"><a href="#NALU-Network-Abstract-Layer-Unit" class="headerlink" title="NALU (Network Abstract Layer Unit)"></a>NALU (Network Abstract Layer Unit)</h1><p><u><strong>H264編碼資料儲存或傳輸的基本單元</strong></u><br> 一般來說 前兩個是 SPS PPS 再來是IDR幀 再來是 P幀或B幀</p>
<ul>
<li>SPS(Sequence Parameter Sets)：序列參數集，保存了一組編碼視訊序列(Coded video sequence)的全域參數。 </li>
<li>PPS(Picture Parameter Set)：影像參數集，對應的是一個序列中某一副影像或某幾副影像的參數。 </li>
<li>SEI(Supplemental enhancement information)：附加增強訊息，包含了視訊畫面定時等信息，一般放在主編碼影像資料之前，在某些應用中，它可以被省略掉。</li>
<li>IDR(Instantaneous Decoding Refresh)：即時解碼刷新。</li>
<li>HRD(Hypothetical Reference Decoder)：假想碼流調度器<br> 。<br>如何拆解H264數據流中的NALU<br>每個NALU中，是以0x00000001 或 0x000001 當作開始標記，開始標記的後面一個字節 和 0x1f 做 &amp; 的運算得出 NALU 類型<br><img src="/images/20240116154054.png"><br>舉例: 上面有4個NALU 開頭都為 0x000001 後面一格字節就是算出NALU類型的因子<br>NALU(nal_unit_type) 類型 推導</li>
<li>0x06 &amp; 0x1f &#x3D; 6 (SEI)</li>
<li>0x67 &amp; 0x1f &#x3D; 7 (SPS)</li>
<li>0x68 &amp; 0x1f &#x3D; 8 (PPS)</li>
<li>0x65 &amp; 0x1f &#x3D; 5 (IDR)<br><img src="/images/20240116154827.png"></li>
<li><a href="https://zhuanlan.zhihu.com/p/409527359">H264之NALU解析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/71928833">视频和视频帧：H264编码格式整理</a></li>
</ul>
<h1 id="H264有兩種封裝"><a href="#H264有兩種封裝" class="headerlink" title="H264有兩種封裝"></a>H264有兩種封裝</h1><ul>
<li><h4 id="AnnexB格式"><a href="#AnnexB格式" class="headerlink" title="AnnexB格式"></a>AnnexB格式</h4>  这种格式比较常见，也就是我们熟悉的每个帧前面都有<code>0x00 00 00 01</code>或者<code>0x00 00 01</code>作为起始码。<br>  h264文件就是采用的这种格式，每个帧前面都要有个起始码。<br>  SPS PPS等也作为一类NALU存储在这个码流中，一般在码流最前面。也就是说这种格式包含VCL 和 非VCL 类型的NALU。 </li>
<li><strong>AVCC格式</strong><br>  这种模式也叫AVC1格式，没有起始码，每个帧最前面几个字节（通常4字节）是帧长度。<br>  这里的NALU一般没有SPS PPS等参数信息，参数信息属于额外数据extradata存在其他地方。<br>  比如ffmpeg中解析mp4文件后sps pps存在streams[index]-&gt;codecpar-&gt;extradata;中。<br>  也就是说这种码流通常只包含VCL类型NALU。<br>  这些extradata通常有如下格式（可以根据这个规则ffmpeg解析mp4文件的SPS和PPS）</li>
</ul>
<h1 id="H264-编码-—profile-和-level"><a href="#H264-编码-—profile-和-level" class="headerlink" title="# H264 编码 —profile 和 level"></a># H264 编码 —profile 和 level</h1><ul>
<li>baseline profile：基本画质。支持 I&#x2F;P 帧，只支持无交错（Progressive）和 CAVLC</li>
<li>extended profile：进阶画质。支持 I&#x2F;P&#x2F;B&#x2F;SP&#x2F;SI 帧，只支持无交错（Progressive）和 CAVLC；(用的少)</li>
<li>main profile：主流画质。提供 I&#x2F;P&#x2F;B 帧，支持无交错（Progressive）和交错（Interlaced），也支持 CAVLC 和 CABAC 的支持</li>
<li>high profile：高级画质。在 main profile 的基础上增加了 8x8 内部预测、自定义量化、无损视频编码和更多的 YUV 格式<br><a href="https://winddoing.github.io/post/e114a1a8.html">H264 编码 —profile 和 level</a></li>
</ul>
]]></content>
      <categories>
        <category>h264</category>
      </categories>
      <tags>
        <tag>B幀</tag>
        <tag>GOP</tag>
        <tag>H264</tag>
        <tag>IDR幀</tag>
        <tag>I幀</tag>
        <tag>NALU</tag>
        <tag>P幀</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World 使用Github pages 靜態網站</title>
    <url>/posts/20230505020300-526efc4a.html</url>
    <content><![CDATA[<p>建立一個新的倉庫 命名為 <strong>帳戶名稱.github.io</strong><br><img src="/images/image.png" alt="建立一個新的倉庫"></p>
<p>好了之後在自己的電腦上clone專案下來</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:eebrian123tw60/eebrian123tw60.github.io.git</span><br></pre></td></tr></table></figure>
<p>進入專案 新增一個index.html 內容是Hello World</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd eebrian123tw60.github.io</span><br><span class="line">echo &quot;Hello World&quot; &gt; index.html</span><br></pre></td></tr></table></figure>
<p>推到遠端的倉庫</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add --all</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure>
<p>等待幾分鐘 訪問<a href="https://eebrian123tw60.github.io/">https://eebrian123tw60.github.io/</a><br><img src="/images/image2.png"><br>結果就出來拉！！</p>
<hr>
<h2 id="參考連結"><a href="#參考連結" class="headerlink" title="參考連結"></a>參考連結</h2><ul>
<li><a href="https://pages.github.com/">https://pages.github.com/</a></li>
<li><a href="https://medium.com/%E9%80%B2%E6%93%8A%E7%9A%84-git-git-git/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B-%E7%94%A8github-pages-%E4%B8%8A%E5%82%B3%E9%9D%9C%E6%85%8B%E7%B6%B2%E7%AB%99-fa2ae83e6276">從零開始: 用github pages 上傳靜態網站</a></li>
</ul>
]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>IIC I2C （Inter-Integrated Circuit）</title>
    <url>/posts/20231118183800-d71a458d.html</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p><img src="/images/20231119013103.png"><br>I2C(IIC)唸做I-square-C 属于两线式串行总线，由飞利浦公司开发用于微控制器(MCU)和外围设备(从设备)进行通信的一种总线，属于一主多从(一个主设备(Master)，多个从设备(Slave))的总线结构，总线上的每个设备都有一个特定的设备地址，以区分同一I2C总线上的其他设备。</p>
<p>半雙工、同步、串行傳輸，物理上只有兩根線（SDA&#x2F;SCL）；傳輸數據必須8位8位的傳輸<br> <span id="more"></span></p>
<p>物理I2C接口有<strong>两根双向线</strong>， <strong>串行时钟线（SCL）和串行数据线（SDA）</strong> 组成，可用于发送和接收数据，但是通信都是由主设备发起，从设备被动响应，实现数据的传输。</p>
<h1 id="I2C主设备与从设备的一般通信过程"><a href="#I2C主设备与从设备的一般通信过程" class="headerlink" title="I2C主设备与从设备的一般通信过程"></a>I2C主设备与从设备的一般通信过程</h1><h2 id="起始位-Start-condition-停止位-Stop-condition"><a href="#起始位-Start-condition-停止位-Stop-condition" class="headerlink" title="起始位 Start condition 停止位 Stop condition"></a>起始位 Start condition 停止位 Stop condition</h2><p><img src="/images/20231119013140.png"></p>
<ul>
<li>Start condition: SCL&#x3D; high + SDA falling (SDA由高到低跳變)</li>
<li>Stop condition: SCL&#x3D;high + SDA raising (SDA由低到高跳變)</li>
</ul>
<h2 id="邏輯數據"><a href="#邏輯數據" class="headerlink" title="邏輯數據"></a>邏輯數據</h2><p><img src="/images/20231119013159.png"><br>SCL為High採集SDA數據<br><img src="/images/20231119013218.png"><br>表示1010000  </p>
<h2 id="一-主设备给从设备发送-x2F-写入数据："><a href="#一-主设备给从设备发送-x2F-写入数据：" class="headerlink" title="一. 主设备给从设备发送&#x2F;写入数据："></a>一. 主设备给从设备发送&#x2F;写入数据：</h2><p><img src="/images/20231119013233.png"></p>
<ol>
<li>主设备发送起始（START）信号(1 bit)</li>
<li>主设备发送设备地址到从设备(7&#x2F;8bit) + 寫(1 bit)</li>
<li>等待从设备响应(ACK)(1 bit)</li>
<li>主设备发送数据到从设备，一般发送的每个字节数(8bit)据后会跟着等待接收来自从设备的响应(ACK)(1 bit)</li>
<li>数据发送完毕，主设备发送停止(STOP)信号终止传输(1 bit)</li>
</ol>
<h2 id="二-主设备从从设备接收-x2F-读取数据"><a href="#二-主设备从从设备接收-x2F-读取数据" class="headerlink" title="二. 主设备从从设备接收&#x2F;读取数据"></a>二. 主设备从从设备接收&#x2F;读取数据</h2><p><img src="/images/20231119013244.png"></p>
<ol>
<li>设备发送起始（START）信号(1 bit)</li>
<li>主设备发送设备地址到从设备(7&#x2F;8bit) + 讀(1 bit)</li>
<li>等待从设备响应(ACK)(1 bit)</li>
<li>主设备接收来自从设备的数据，一般接收的每个字节(8bit)数据后会跟着向从设备发送一个响应(ACK)(1 bit)</li>
<li>一般接收到最后一个数据后会发送一个无效响应(NACK)，然后主设备发送停止(STOP)信号终止传输(1 bit)</li>
</ol>
<h2 id="三-讀寫數據幀"><a href="#三-讀寫數據幀" class="headerlink" title="三. 讀寫數據幀"></a>三. 讀寫數據幀</h2><p><img src="/images/20231119013257.png"></p>
<h1 id="參考影片"><a href="#參考影片" class="headerlink" title="參考影片"></a>參考影片</h1><ul>
<li><a href="https://www.youtube.com/watch?v=u62_Rjd5oMY">4分钟看懂！I2C通讯协议 最简单的总线通讯！</a></li>
<li><a href="https://www.youtube.com/watch?v=oPrfi_HCtjY">I²C通訊格式介紹</a></li>
<li><a href="https://www.youtube.com/watch?v=FamlCPP2J4o">11 IIC总线原理轻松明白</a></li>
</ul>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://zhuanlan.zhihu.com/p/503219395">IIC通信协议，搞懂这篇就够了</a></li>
<li><a href="https://www.strongpilab.com/i2c-introduction/">I2C-協定用法原理簡介-晶片溝通的橋樑</a></li>
<li><a href="https://medium.com/weiting-tw/%E6%8A%80%E8%A1%93%E7%AD%86%E8%A8%98-i2c%E9%80%9A%E8%A8%8A%E5%8D%94%E5%AE%9A%E6%93%8D%E4%BD%9C-36d4dad0c9b3">[技術筆記] I2C通訊協定操作</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/575318033">《Linux驱动：I2C驱动看这一篇就够了》</a></li>
</ul>
]]></content>
      <categories>
        <category>soc</category>
      </categories>
      <tags>
        <tag>I2C</tag>
        <tag>IIC</tag>
      </tags>
  </entry>
  <entry>
    <title>PWM(Pulse-width modulation)</title>
    <url>/posts/20231118194600-68d2e719.html</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p><img src="/images/20231119023727.png"><br>是將脈波轉為類比信號的“一種技術”,利用在頻率不變的狀態下, 改變占空比大小, 使整體平均電壓值上升或下降, 藉此間歇性電壓及功率切換以節省能源及控制等效果.</p>
<h1 id="Period-週期"><a href="#Period-週期" class="headerlink" title="Period 週期"></a>Period 週期</h1><p>通常週期固定然後調整占空比</p>
<h1 id="Duty-Circle-占空比"><a href="#Duty-Circle-占空比" class="headerlink" title="Duty Circle(占空比)"></a>Duty Circle(占空比)</h1><p>100%代表有1個clock有百分之100是高電平 平均電壓為 5V<em>1 &#x3D; 5V<br> <span id="more"></span><br> 75%代表有1個clock有百分之75是高電平 平均電壓為 5V</em>0.75 &#x3D; 3.75V<br>25%代表有1個clock有百分之25是高電平 平均電壓為 3V<em>0.25 &#x3D; 2.25V<br>0%代表有1個clock有百分之0是高電平 平均電壓為 3V</em>0 &#x3D; 0V<br>藉由控制占空比可以控制平均電壓 控制功率 可以控制燈的亮度 馬達轉速</p>
<h1 id="範例-WS2812B"><a href="#範例-WS2812B" class="headerlink" title="範例 WS2812B"></a>範例 WS2812B</h1><h2 id="WS2812B-PWM-如果是單純用PWM用IO的方法控制duty-cycle無法控制到每個bit"><a href="#WS2812B-PWM-如果是單純用PWM用IO的方法控制duty-cycle無法控制到每個bit" class="headerlink" title="WS2812B PWM 如果是單純用PWM用IO的方法控制duty_cycle無法控制到每個bit"></a>WS2812B PWM 如果是單純用PWM用IO的方法控制duty_cycle無法控制到每個bit</h2><p>period &#x3D; 800Khz 1&#x2F;800000 &#x3D; 1250 ns<br>duty cycle 33% <code>1250*0.333 = 412.5</code> 0 碼<br>duty cycle 67% <code>1250*0.666 = 825</code> 1 碼<br>ws2812 复位信号为一个 不低于 50us</p>
<h3 id="注册该pwm通道"><a href="#注册该pwm通道" class="headerlink" title="注册该pwm通道"></a>注册该pwm通道</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /sys/class/pwm/pwmchip0/npwm</span><br><span class="line">echo 0 &gt; /sys/class/pwm/pwmchip0/export</span><br></pre></td></tr></table></figure>
<h3 id="設定週期-ns"><a href="#設定週期-ns" class="headerlink" title="設定週期(ns)"></a>設定週期(ns)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 1250 &gt; /sys/class/pwm/pwmchip0/pwm0/period</span><br></pre></td></tr></table></figure>
<h3 id="設定duty-cycle-ns"><a href="#設定duty-cycle-ns" class="headerlink" title="設定duty cycle(ns)"></a>設定duty cycle(ns)</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 825 &gt; /sys/class/pwm/pwmchip0/pwm0/duty_cycle</span><br></pre></td></tr></table></figure>

<h3 id="開燈"><a href="#開燈" class="headerlink" title="開燈"></a>開燈</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 825 &gt; /sys/class/pwm/pwmchip0/pwm0/duty_cycle</span><br><span class="line">echo 1 &gt; /sys/class/pwm/pwmchip0/pwm0/enable</span><br><span class="line">echo 0 &gt; /sys/class/pwm/pwmchip0/pwm0/enable</span><br></pre></td></tr></table></figure>
<h3 id="關燈"><a href="#關燈" class="headerlink" title="關燈"></a>關燈</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 412 &gt; /sys/class/pwm/pwmchip0/pwm0/duty_cycle</span><br><span class="line">echo 1 &gt; /sys/class/pwm/pwmchip0/pwm0/enable</span><br><span class="line">echo 0 &gt; /sys/class/pwm/pwmchip0/pwm0/enable</span><br></pre></td></tr></table></figure>



<h1 id="參考影片"><a href="#參考影片" class="headerlink" title="參考影片"></a>參考影片</h1><ul>
<li><a href="https://www.youtube.com/watch?v=LCejYewAgwA">2.1.1脈衝寬度(PWM)基本介紹</a></li>
<li><a href="https://www.youtube.com/watch?v=27GkMk8ct0s">[Arduino 教學課程] 什麼！用pwm就能控制LED亮度？那個像是蚯蚓符號的東西原來有其他用意？來實作看看呼吸燈ㄅ 從零開始學Arduino #11</a></li>
</ul>
]]></content>
      <categories>
        <category>soc</category>
      </categories>
      <tags>
        <tag>PWM</tag>
        <tag>WS2812B</tag>
      </tags>
  </entry>
  <entry>
    <title>SparkFun Thing Plus Matter - MGM240P</title>
    <url>/posts/20231118184600-2b622287.html</url>
    <content><![CDATA[<h1 id="SparkFun-Thing-Plus-Matter-MGM240P"><a href="#SparkFun-Thing-Plus-Matter-MGM240P" class="headerlink" title="SparkFun Thing Plus Matter - MGM240P"></a><a href="https://www.sparkfun.com/products/20270">SparkFun Thing Plus Matter - MGM240P</a></h1><h1 id="安裝-Simplicity-Studio-5"><a href="#安裝-Simplicity-Studio-5" class="headerlink" title="安裝 Simplicity Studio 5"></a>安裝 Simplicity Studio 5</h1><p>先下載<a href="https://www.silabs.com/developers/simplicity-studio">simplicity-studio</a>並安裝(防毒軟體先關掉)</p>
<p><img src="/images/rJPmOAx7T.png"><br> <span id="more"></span><br> <img src="/images/rkeBu0em6.png"><br><img src="/images/rJMUOAgmT.png"><br><img src="/images/H19PO0x7a.png"><br>一直下一步，安裝到預設路徑即可 安裝完會自動打開<br><img src="/images/H1kFFAxXp.png"><br>同意並繼續<br><img src="/images/r1NhtAxQ6.png"><br>登入silabs的帳戶，免費辦一個<br>登入後會安裝驅動 輸入Admin帳號密碼安裝<br><img src="/images/HkqDc0xX6.png"><br>點擊Intall 點擊Intall by Connecting devices<br><img src="/images/Hy4oqAlQ6.png"><br>現在沒有裝置 接入USB<br><img src="/images/B1vJiAlXa.png"><br>接入USB 會需要安裝驅動板子套件按下Yes<br><img src="/images/HyS8sRxm6.png"><br>選擇板子 Next<br><img src="/images/BJROsCxmp.png"><br>選擇Auto Next<br><img src="/images/H1T3oCeQ6.png"><br>同意安裝套件 Next<br><img src="/images/ByHS2Aema.png"><br>會裝一些無線套件(geoko sdk)之類的(大約跑30分鐘)<br><img src="/images/HJYMgkbmp.png"><br>重開 Simplicity Studio<br><img src="/images/Byv9xyZmp.png"></p>
<blockquote>
<p>** 系統會提示更新 Adapter FW<br>不要更新保持這個1v4p9b113版本<br>(1.4.12.18刷進去會失敗，辯識會有問題，會變磚)**</p>
</blockquote>
<h1 id="更新版子-Adapter-Firmware-跳過"><a href="#更新版子-Adapter-Firmware-跳過" class="headerlink" title="更新版子 Adapter Firmware (跳過)"></a>更新版子 Adapter Firmware (跳過)</h1><p>更新版子參考 <a href="https://community.silabs.com/s/article/how-to-update-the-firmware-on-your-starter-kit-board">How to update the Firmware on your Starter Kit board</a><br>更新版子變磚參考 <a href="https://community.silabs.com/s/article/recover-efm32-or-efm8-kit-that-was-bricked-during-firmware-upgrade">Recover EFM32 or EFM8 kit that was bricked during firmware upgrade</a></p>
<blockquote>
<p> SparkFun Thing Plus Matter 曾經升到1.4.12.18，但失敗變磚，要退版本但是進入boot mode 的方法上面試不出來，最後是不知道怎麼又可以辨識出來(有可能是用手壓住後面的腳位接入USB，陰錯陽差進到 boot mode)，然後降版</p>
</blockquote>
<h1 id="簡單的範例-Blink-Example"><a href="#簡單的範例-Blink-Example" class="headerlink" title="簡單的範例 Blink Example"></a>簡單的範例 <a href="https://learn.sparkfun.com/tutorials/sparkfun-thing-plus-matter---mgm240p-hookup-guide/all#blink-example">Blink Example</a></h1><p>這個範例是一個會閃的燈<br><img src="/images/SJeZ176.png"><br>File &gt;&gt; New &gt;&gt; Silicon Labs Project Wizard<br>Target Boards: Sparkfun Thing Plus MGM240P (BRD2704A Rev A00)<br>Target Device: mgm240pb32vna<br>SDK: Deoko SDK Suite<br>IDE&#x2F;Toolchain: Simplicity IDE<br>點擊 Next<br><img src="/images/Hy9YGyZXp.png"><br>搜尋 blink 點擊 Platform - Blink Bare-mental<br>點擊 Next<br><img src="/images/HkO1XyZQa.png"><br>點擊 Finish<br><img src="/images/BkGX1b7T.png"><br><img src="/images/rJHA71WQT.png"><br>編譯並寫入板子<br><img src="/images/HkiX4ybX6.png"><br>編譯無錯誤 正常寫入板子後可看到燈會不斷閃爍<br><img src="/images/SyC7ByZQa.jpg"><br><img src="/images/S1vES1bmT.jpg"><br>可以到blink.c裡面的 TOOGLE_DELAY_MS 更改閃爍時間</p>
<h2 id="參考影片"><a href="#參考影片" class="headerlink" title="參考影片"></a>參考影片</h2><ul>
<li><a href="https://www.youtube.com/watch?v=POVRRuVCr-Q">Get Started with Simplicity Studio and the Thing Plus Matter Board</a></li>
</ul>
<h1 id="NCP-模式"><a href="#NCP-模式" class="headerlink" title="NCP 模式"></a>NCP 模式</h1><p><img src="/images/S1O4zC76.png"></p>
<blockquote>
<p>這裡Demo會要創立三個專案，目的是要創建Zigbee網路</p>
</blockquote>
<h2 id="創建-Bootloader-NCP-UART-XMODEM-專案"><a href="#創建-Bootloader-NCP-UART-XMODEM-專案" class="headerlink" title="創建 Bootloader - NCP UART XMODEM 專案"></a>創建 Bootloader - NCP UART XMODEM 專案</h2><p><img src="/images/SJeZ176.png"><br>File &gt;&gt; New &gt;&gt; Silicon Labs Project Wizard<br>Target Boards: Sparkfun Thing Plus MGM240P (BRD2704A Rev A00)<br>Target Device: mgm240pb32vna<br>SDK: Deoko SDK Suite<br>IDE&#x2F;Toolchain: Simplicity IDE<br>點擊 Next<br><img src="/images/By9Mw1mp.png"><br>點擊 Bootloader - NCP UART XMODEM<br>點擊 Next<br><img src="/images/BkaUwkb7T.png"><br>點擊 Finish<br><img src="/images/rJlydyXa.png"></p>
<h2 id="創建-Zigbee-NCP-ncp-uart-hw-專案"><a href="#創建-Zigbee-NCP-ncp-uart-hw-專案" class="headerlink" title="創建 Zigbee - NCP ncp-uart-hw 專案"></a>創建 Zigbee - NCP ncp-uart-hw 專案</h2><p><img src="/images/SJeZ176.png"><br>File &gt;&gt; New &gt;&gt; Silicon Labs Project Wizard<br>Target Boards: Sparkfun Thing Plus MGM240P (BRD2704A Rev A00)<br>Target Device: mgm240pb32vna<br>SDK: Deoko SDK Suite<br>IDE&#x2F;Toolchain: Simplicity IDE<br>點擊 Next<br><img src="/images/ry3LJbX6.png"><br>點擊 Zigbee - NCP ncp-uart-hw<br>點擊 Next<br><img src="/images/Sy39kW7a.png"><br>點擊 Finish</p>
<h2 id="創建-Zigbee-Host-Gatway-專案-在Linux上執行"><a href="#創建-Zigbee-Host-Gatway-專案-在Linux上執行" class="headerlink" title="創建 Zigbee - Host Gatway 專案 (在Linux上執行)"></a>創建 Zigbee - Host Gatway 專案 (在Linux上執行)</h2><p><img src="/images/ByLntyWX6.png"><br>File &gt;&gt; New &gt;&gt; Silicon Labs Project Wizard<br>Target Boards: Custom Board (可能會有點難點)<br>Target Device: Linux 64 bit<br>SDK: Deoko SDK Suite<br>IDE&#x2F;Toolchain: Makefile IDE<br>點擊 Next<br><img src="/images/ryakcyZmT.png"><br>點擊 Zigbee - Host Gateway<br>點擊 Next<br><img src="/images/HyKZ9J7p.png"><br>點擊 Finish</p>
<h2 id="燒入-Bootloader-NCP-UART-XMODEM"><a href="#燒入-Bootloader-NCP-UART-XMODEM" class="headerlink" title="燒入 Bootloader - NCP UART XMODEM"></a>燒入 Bootloader - NCP UART XMODEM</h2><p>燒入 Bootloader - NCP UART XMODEM 和 NCP ncp-uart-hw 要刷進板子裡面<br><img src="/images/Hyxny7a.png"><br>點擊專案 點擊槌子 進行編譯<br><img src="/images/Hy8f2yZma.png"><br>編譯成功完後 Binaries 出現 檔名為bootloader-uart-xmodem 的各種image<br>進行寫入動作<br><img src="/images/ryDL31WXp.png"><br>點擊Tools<br><img src="/images/HJt3kZQ6.png"><br>點擊Simplicity Commander 點擊ok<br><img src="/images/r1Wnn1WQp.png"><br>選擇Binary File <code>v5_workspace/bootloader-uart-xmodem/GNU ARM v10.3.1 - Default/bootloader-uart-xmodem.s37</code> 點擊 Flash<br><img src="/images/BJGlkeZXp.png"><br>log 顯示 Successfully<br><img src="/images/HJhC31Q6.png"><br>在Device Info 裡面的 MemoryMap 裡的 Flash Map 可以看到 Bootloader 占用兩個綠色區塊<br><img src="/images/SJaSJxZXa.png"><br>右鍵 Debug Adapter 選擇Launch Console<br><img src="/images/SkJsJxWm6.png"><br>Seial 1 會出現 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Gecko Bootloader v2.03.02</span><br><span class="line">1. upload gbl</span><br><span class="line">2. run</span><br><span class="line">3. ebl info</span><br><span class="line">BL &gt; </span><br></pre></td></tr></table></figure>
<p>代表進入 Gecko Bootloader mode </p>
<blockquote>
<p>在還沒刷入 Application 會進入到 Gecko Bootloader mode<br>如果已經刷了 Application 則此處不會顯示任何東西</p>
</blockquote>
<h2 id="燒入-NCP-ncp-uart-hw"><a href="#燒入-NCP-ncp-uart-hw" class="headerlink" title="燒入 NCP ncp-uart-hw"></a>燒入 NCP ncp-uart-hw</h2><p><img src="/images/Hy0kxCQ6.png"><br>點擊ncp-uart-hw.slcp<br><img src="/images/BkgQlCWm6.png"><br>點擊Software Components<br><img src="/images/HJsvlRXa.png"><br>找到Service &gt;&gt; IO Stream &gt;&gt; Driver &gt;&gt; IO Stream: USART &gt;&gt; vcom<br>點擊 Congiure<br><img src="/images/HJY3e0Zm6.png"><br>將 Flow Control 改成 Software Flow control<br><img src="/images/HyScEaWm6.png"><br>點擊專案 點擊槌子 進行編譯<br><img src="/images/B107BT7p.png"><br>編譯成功完後 Binaries 出現 檔名為ncp-uart-hw 的各種image<br>進行寫入動作<br><img src="/images/ryDL31WXp.png"><br>點擊Tools<br><img src="/images/HJt3kZQ6.png"><br>點擊Simplicity Commander 點擊ok<br><img src="/images/Byb5rabmT.png"><br>選擇Binary File <code>v5_workspace/ncp-uart-hw/GNU ARM v10.3.1 - Default/ncp-uart-hw.s37</code> 點擊 Flash<br><img src="/images/S1CsrTZXp.png"><br>log 顯示 Successfully<br><img src="/images/S1mLITXa.png"><br>在Device Info 裡面的 MemoryMap 裡的 Flash Map 可以看到 Bootloader + ncp-uart-hw 的分布<br>Bootloader 從0x8000000開始<br>ncp-uart-hw 從0x8006000開始<br><img src="/images/SJaSJxZXa.png"><br>右鍵 Debug Adapter 選擇Launch Console<br><img src="/images/HJCWDabQ6.png"><br>Seial 1 不會顯示任何東西<br>代表進入 Application mode </p>
<h2 id="編譯-Zigbee-Host-Gateway-要用-Linux-編譯運行在-Linux-上"><a href="#編譯-Zigbee-Host-Gateway-要用-Linux-編譯運行在-Linux-上" class="headerlink" title="編譯 Zigbee - Host Gateway(要用 Linux 編譯運行在 Linux 上)"></a>編譯 Zigbee - Host Gateway(要用 Linux 編譯運行在 Linux 上)</h2><p><img src="/images/B11Aupb76.png"><br>cd 到專案底下<br><img src="/images/SJSjdpWXa.png"><br><code>gcc -v</code><br><img src="/images/r11lFaZmT.png"><br><code>make -f Z3Gateway.Makefile</code><br><img src="/images/HyhsKTZmT.png"><br>編譯完成<br><img src="/images/SyIW9pbXa.png"></p>
<h2 id="透過-Host-Gateway-控制-MCU-建立Zigbee-網路"><a href="#透過-Host-Gateway-控制-MCU-建立Zigbee-網路" class="headerlink" title="透過 Host Gateway 控制 MCU 建立Zigbee 網路"></a>透過 Host Gateway 控制 MCU 建立Zigbee 網路</h2><p><img src="/images/SJ0OqpZXp.png"><br>這裡選用Jlink OB 這也是帶有Serial Com Port 功能<br><img src="/images/H1Dhnama.png"><br>cd 到 程式所在地<br><img src="/images/HkPfpabQ6.png"><br><code>./Z3Gateway -f x -b 115200 -p  /dev/ttyACM0</code><br><img src="/images/S1aSTT76.png"><br>直接輸入info<br><img src="/images/rJXOpTWQp.png"><br>可以看到當前狀態 nodeId PanId xpan …. 接下來就是建立網路<br><img src="/images/HJPg067a.png"><br><code>network leave</code> 先離開網路<br><img src="/images/r1P5A6WQT.png"><br><code>plugin network-creator start 1</code> 成功會看到 EMBER_NETWORK_UP 0x0000 的字眼<br><img src="/images/SyBRAT7T.png"><br>再輸入info 可以看到當前狀態 nodeId PanId xpan …. 網路已經建立好了<br><img src="/images/Sy8Iy0Wma.png"><br><code>plugin network-creator-security open-network</code> 讓其他設備加入</p>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug235-09-developing-ncp-apps-with-connect.pdf">UG235.09: Developing NCP Applications with Silicon Labs Connect v2.x</a></li>
<li><a href="https://www.silabs.com/documents/public/application-notes/an1320-customized-ncp-zigbee7.pdf">Building a Customized NCP Application with Zigbee EmberZNet 7.x</a></li>
<li><a href="https://www.silabs.com/documents/public/application-notes/an706-ezsp-uart-host-interfacing-guide.pdf">EZSP-UART Host Interfacing Guide</a></li>
<li><a href="https://blog.csdn.net/lshddd/article/details/115458007">基于芯科Host-NCP解决方案的Zigbee 3.0 Gateway技术研究（-）-Z3GatewayHost应用</a></li>
<li><a href="https://blog.csdn.net/qq_42860989/article/details/125909875">在Cygwin环境下构建和使用EmberZNet PRO Zigbee Host应用程序</a></li>
<li><a href="https://github.com/SiliconLabs/managed-zigbee-gateway/blob/master/README.md">managed-zigbee-gateway&#x2F;README.md</a></li>
<li><a href="https://blog.csdn.net/qq_42992084/article/details/104761474">UART串口流控制（Flow control）</a></li>
<li><a href="https://community.silabs.com/s/question/0D51M00007xeQUSSA2/how-to-verify-the-normal-operation-of-ncp?language=zh_TW">How to Verify the Normal Operation of NCP？</a></li>
</ul>
<h2 id="參考影片-1"><a href="#參考影片-1" class="headerlink" title="參考影片"></a>參考影片</h2><ul>
<li><a href="https://www.bilibili.com/video/BV1nM4y1g755/">Day1-4-EmberZnet SDK的Bootloader和OTA配置详解</a></li>
<li><a href="https://www.bilibili.com/video/BV1fv411y7cq/">Day 1-2_EmberZnet协议栈介绍及开发工具AppBuilder介绍 (1)</a></li>
<li><a href="https://www.bilibili.com/video/BV1bT4y1w7EJ">Day 3-1 Zigbee 3.0 RTOS网关介绍</a></li>
<li><a href="https://www.youtube.com/watch?v=EP96d_ps4vg&ab_channel=CUSTCourses">10-01 何謂bootloader</a></li>
<li><a href="https://www.youtube.com/watch?v=njFxwNoPbkc">ARM Bootloader开发-1.bootloader概述1</a></li>
</ul>
<h1 id="Soc-模式-以Zigbee-Soc-Switch-為例-將裝置修改為Coordinator並且建立Zigbee網路"><a href="#Soc-模式-以Zigbee-Soc-Switch-為例-將裝置修改為Coordinator並且建立Zigbee網路" class="headerlink" title="Soc 模式 (以Zigbee - Soc Switch 為例 將裝置修改為Coordinator並且建立Zigbee網路)"></a>Soc 模式 (以Zigbee - Soc Switch 為例 將裝置修改為Coordinator並且建立Zigbee網路)</h1><h2 id="創建-Bootloader-Soc-Internal-Storage-專案"><a href="#創建-Bootloader-Soc-Internal-Storage-專案" class="headerlink" title="創建 Bootloader - Soc Internal Storage 專案"></a>創建 Bootloader - Soc Internal Storage 專案</h2><p><img src="/images/SJeZ176.png"><br>File &gt;&gt; New &gt;&gt; Silicon Labs Project Wizard<br>Target Boards: Sparkfun Thing Plus MGM240P (BRD2704A Rev A00)<br>Target Device: mgm240pb32vna<br>SDK: Deoko SDK Suite<br>IDE&#x2F;Toolchain: Simplicity IDE<br>點擊 Next<br><img src="/images/HyWccAWX6.png"><br>點擊 Bootloader - Soc Internal Storage (1536kB)<br>點擊 Next<br><img src="/images/r1xiqRbX6.png"><br>點擊 Finish</p>
<h2 id="創建-Zigbee-Soc-Switch-專案"><a href="#創建-Zigbee-Soc-Switch-專案" class="headerlink" title="創建 Zigbee - Soc Switch 專案"></a>創建 Zigbee - Soc Switch 專案</h2><p><img src="/images/SJeZ176.png"><br>File &gt;&gt; New &gt;&gt; Silicon Labs Project Wizard<br>Target Boards: Sparkfun Thing Plus MGM240P (BRD2704A Rev A00)<br>Target Device: mgm240pb32vna<br>SDK: Deoko SDK Suite<br>IDE&#x2F;Toolchain: Simplicity IDE<br>點擊 Next<br><img src="/images/HJKFCXT.png"><br>點擊 Zigbee - Soc Switch<br>點擊 Next<br><img src="/images/B1vXqRZXp.png"><br>點擊 Finish</p>
<h2 id="修改-Zigbee-Soc-Switch-專案設定-Part1"><a href="#修改-Zigbee-Soc-Switch-專案設定-Part1" class="headerlink" title="修改 Zigbee - Soc Switch 專案設定 Part1"></a>修改 Zigbee - Soc Switch 專案設定 Part1</h2><p><img src="/images/B17oiRWma.png"><br>點擊 Z3Switch.slcp<br><img src="/images/BkgQlCWm6.png"><br>點擊Software Components<br><img src="/images/r120sCZm6.png"><br>找到Platform &gt;&gt; Driver &gt;&gt; Button &gt;&gt; Simple Button &gt;&gt; bt1<br>點擊 Congiure<br><img src="/images/HyIm2C7p.png"><br>修改 SL_SIMPLE_BUTTON_BTN1 先隨便選一個</p>
<p>再修改<br>找到Service &gt;&gt; IO Stream &gt;&gt; Driver &gt;&gt; IO Stream: USART &gt;&gt; vcom<br>將 Flow Control 改成 Software Flow control</p>
<h2 id="分別燒入-Bootloader-Soc-Internal-Storage-和-Zigbee-Soc-Switch"><a href="#分別燒入-Bootloader-Soc-Internal-Storage-和-Zigbee-Soc-Switch" class="headerlink" title="分別燒入 Bootloader - Soc Internal Storage 和 Zigbee - Soc Switch"></a>分別燒入 Bootloader - Soc Internal Storage 和 Zigbee - Soc Switch</h2><p>參考上面燒入<br><img src="/images/rkD2zJMQT.png"><br>打開console seral 1  可以看到 &gt; Z3Switch 輸入info 看資訊<br>此時不能建立網路 因為現在裝置類型是End Device 而且 創建網路需要增加plugin</p>
<h2 id="修改-Zigbee-Soc-Switch-專案設定-Part2"><a href="#修改-Zigbee-Soc-Switch-專案設定-Part2" class="headerlink" title="修改 Zigbee - Soc Switch 專案設定 Part2"></a>修改 Zigbee - Soc Switch 專案設定 Part2</h2><p>修改<br>找到 Zigbee &gt;&gt; Utility &gt;&gt; Zigbee Device Config<br>將 Primary Network Device Type 改成 Coordonator or Router</p>
<p>找到 Zigbee &gt;&gt; Stack &gt;&gt; Pro Stack &gt;&gt; Pro Leaf Stack<br>將他 Uninstall</p>
<p>找到 Zigbee &gt;&gt; Stack &gt;&gt; Pro Stack &gt;&gt; Pro Stack<br>將他 install</p>
<p>找到 Zigbee &gt;&gt; Utility &gt;&gt; End Device Support<br>將他 Uninstal</p>
<p>找到 Zigbee &gt;&gt; Zigbee3.0 &gt;&gt; Network Creator<br>將他 install</p>
<h2 id="燒入-Zigbee-Soc-Switch-Part2"><a href="#燒入-Zigbee-Soc-Switch-Part2" class="headerlink" title="燒入 Zigbee - Soc Switch Part2"></a>燒入 Zigbee - Soc Switch Part2</h2><p>參考上面燒入<br><img src="/images/r1aTByf7p.png"><br><code>network leave</code><br><img src="/images/B1xGUkGma.png"><br><code>plugin network-creator start 1</code><br><img src="/images/SyBNIyfQa.png"><br><code>info</code> 可以看到當前狀態 nodeId PanId xpan …. 網路已經建立好了<br>之後再輸入<code>plugin network-creator-security open-network</code> 讓其他設備加入</p>
<h1 id="用-Bootloader-NCP-UART-XMODEM-刷-Application"><a href="#用-Bootloader-NCP-UART-XMODEM-刷-Application" class="headerlink" title="用 Bootloader - NCP UART XMODEM 刷 Application"></a>用 Bootloader - NCP UART XMODEM 刷 Application</h1><p><img src="/images/H1RwPNGXT.png"></p>
<h2 id="製作專門給-gecko-bootloader-用的-gbl檔案"><a href="#製作專門給-gecko-bootloader-用的-gbl檔案" class="headerlink" title="製作專門給 gecko bootloader 用的 gbl檔案"></a>製作專門給 gecko bootloader 用的 gbl檔案</h2><p><img src="/images/Hk5bbfM76.png"><br><code>.\commander.exe gbl create ncp-uart-hw.gbl  --app ncp-uart-hw.s37</code> </p>
<h2 id="進入-geoko-bootloader-模式"><a href="#進入-geoko-bootloader-模式" class="headerlink" title="進入 geoko bootloader 模式"></a>進入 geoko bootloader 模式</h2><p><img src="/images/B1glHMGma.jpg"><br>讓板子進入geoko bootloader 模式 預設是PC00接地，接上電源<br>如果沒有Application是直接進入到bootloader模式</p>
<p><img src="/images/Bkpk8fGQp.png"><br>用Tera Term 看 會出現 gecko bootloader v2.03.02 字眼 </p>
<h2 id="上傳-gbl-檔案"><a href="#上傳-gbl-檔案" class="headerlink" title="上傳 gbl 檔案"></a>上傳 gbl 檔案</h2><p><img src="/images/ry6nUMzXa.png"><br>此時Memory Map 裡面只有 bootloader</p>
<p><img src="/images/B14lwMGXp.png"><br>按1進入上傳模式 這裡會持續60s 如果沒有上傳檔案會恢復到Menu狀態</p>
<p><img src="/images/HkUmvzzXT.png"><br>點擊 File &gt;&gt; Transfer &gt;&gt; XMODEM &gt;&gt; Send…</p>
<p><img src="/images/Sy9owMzmT.png"><br>上傳中</p>
<p><img src="/images/Hk66PffX6.png"><br>上傳完顯示 Serial upload complete 這時還是在 bootloader 模式</p>
<p><img src="/images/SJwZMzQ6.png"><br>此時Memory Map 裡面只有 bootloader 和 Application</p>
<p><img src="/images/Hy0SdGzQT.png"><br>按下2 啟動Application 會出現一點亂碼</p>
<p><img src="/images/Syw9Mfm6.png"><br>啟動Application 後的 Memory Map 尾部會出現資料</p>
<h2 id="參考-1"><a href="#參考-1" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug489-gecko-bootloader-user-guide-gsdk-4.pdf">UG489: Silicon Labs Gecko Bootloader User’s Guide for GSDK 4.0 and Higher</a></li>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug162-simplicity-commander-reference-guide.pdf">UG162: Simplicity Commander Reference Guide</a></li>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug103-06-fundamentals-bootloading.pdf">Bootloading Fundamentals</a></li>
<li><a href="https://github.com/dsyx/emberznet-doc/blob/master/UG103.6/UG103.6.md">中文翻譯Bootloading Fundamentals</a></li>
<li><a href="https://github.com/dsyx/docs.silabs.com_zh/blob/master/docs/UG266%20Silicon%20Labs%20Gecko%20Bootloader%20User's%20Guide.md">UG266: Silicon Labs Gecko Bootloader User’s Guide (Rev. 1.5)</a></li>
</ul>
<h1 id="用-Bootloader-NCP-UART-XMODEM-更新-Bootloader"><a href="#用-Bootloader-NCP-UART-XMODEM-更新-Bootloader" class="headerlink" title="用 Bootloader - NCP UART XMODEM 更新 Bootloader"></a>用 Bootloader - NCP UART XMODEM 更新 Bootloader</h1><p><img src="/images/H1Wv54f7a.png"></p>
<blockquote>
<p>這裡更新Bootloader版本只能往上更新<br>編輯Bootloader版本設定  Bootloader Version Main Customer &gt;&gt; Bootloader Core</p>
</blockquote>
<h2 id="製作專門給-gecko-bootloader-用的-gbl檔案-1"><a href="#製作專門給-gecko-bootloader-用的-gbl檔案-1" class="headerlink" title="製作專門給 gecko bootloader 用的 gbl檔案"></a>製作專門給 gecko bootloader 用的 gbl檔案</h2><p><img src="/images/HkXtcNz7T.png"><br><code>.\commander.exe gbl create bootloader-uart-xmodem.gbl --bootloader bootloader-uart-xmodem.s37</code></p>
<h2 id="進入-geoko-bootloader-模式-1"><a href="#進入-geoko-bootloader-模式-1" class="headerlink" title="進入 geoko bootloader 模式"></a>進入 geoko bootloader 模式</h2><p><img src="/images/B1glHMGma.jpg"><br>讓板子進入geoko bootloader 模式 預設是PC00接地，接上電源<br>如果沒有Application是直接進入到bootloader模式</p>
<p><img src="/images/Bkpk8fGQp.png"><br>用Tera Term 看 會出現 gecko bootloader v2.03.02 字眼 </p>
<h2 id="上傳-gbl-檔案-1"><a href="#上傳-gbl-檔案-1" class="headerlink" title="上傳 gbl 檔案"></a>上傳 gbl 檔案</h2><p><img src="/images/B14lwMGXp.png"><br>按1進入上傳模式 這裡會持續60s 如果沒有上傳檔案會恢復到Menu狀態</p>
<p><img src="/images/HkUmvzzXT.png"><br>點擊 File &gt;&gt; Transfer &gt;&gt; XMODEM &gt;&gt; Send…</p>
<p><img src="/images/S199i4MXa.png"><br>上傳完顯示 Serial upload complete 這時還是在 bootloader 模式</p>
<p><img src="/images/rkN3sVzmp.png"><br>按 2 重新啟動 會出現 gecko bootloader v2.03.03 字眼 </p>
<h2 id="參考-2"><a href="#參考-2" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug489-gecko-bootloader-user-guide-gsdk-4.pdf">UG489: Silicon Labs Gecko Bootloader User’s Guide for GSDK 4.0 and Higher</a></li>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug162-simplicity-commander-reference-guide.pdf">UG162: Simplicity Commander Reference Guide</a></li>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug103-06-fundamentals-bootloading.pdf">Bootloading Fundamentals</a></li>
<li><a href="https://github.com/dsyx/emberznet-doc/blob/master/UG103.6/UG103.6.md">中文翻譯Bootloading Fundamentals</a></li>
<li><a href="https://github.com/dsyx/docs.silabs.com_zh/blob/master/docs/UG266%20Silicon%20Labs%20Gecko%20Bootloader%20User's%20Guide.md">UG266: Silicon Labs Gecko Bootloader User’s Guide (Rev. 1.5)</a></li>
</ul>
<h1 id="外接-UART-接法"><a href="#外接-UART-接法" class="headerlink" title="外接 UART 接法"></a>外接 UART 接法</h1><p>如果要走自己拉的 UTN401A + Ambar<br>最左邊要High 最右邊是Low 中間左到右分別是RX TX<br><code>H|_|RX|TX|_|G</code><br><img src="/images/rJpMMU7a.jpg"></p>
<ul>
<li><p>Zigbee - NCP ncp-uart-hw 專案<br>  Service &gt;&gt; IO Stream &gt;&gt; Driver &gt;&gt; IO Stream: USART &gt;&gt; vcom<br>  SL_IOSTREAM_USART_VCOM 變更 RX TX 腳位輸入輸出設定</p>
</li>
<li><p>Bootloader - NCP UART XMODEM 專案</p>
<ul>
<li>Platform &gt;&gt; Bootloader &gt;&gt; Drivers &gt;&gt; Bootloader UART Driver </li>
<li>SL_SERIAL_UART 變更 RX TX 腳位輸入輸出設定</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>zigbee</category>
      </categories>
      <tags>
        <tag>Zigbee</tag>
        <tag>MCU</tag>
        <tag>SOC</tag>
        <tag>SparkFun</tag>
        <tag>MGM240P</tag>
        <tag>simplicity-studio</tag>
        <tag>mgm240pb32vna</tag>
        <tag>silabs</tag>
      </tags>
  </entry>
  <entry>
    <title>UART RS232 RS484</title>
    <url>/posts/20231118193100-f5da1a51.html</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="# 介紹"></a># 介紹</h1><p>UART：<strong>全雙工、異步、串行傳輸</strong>，收發獨立，UART總線並沒有時鐘線，所以需要提前定義好對應的波特率，傳輸速度較慢，物理上4根線（VCC&#x2F;TX&#x2F;RX&#x2F;GND），雖然速度慢，但是可用於不同主機間的通信，通常用於debug調試非常方便；傳輸時數據位可以5、6、7、8位。<br><img src="/images/20231119022253.png"></p>
<h1 id="鮑率-波特率"><a href="#鮑率-波特率" class="headerlink" title="鮑率(波特率)"></a>鮑率(波特率)</h1><p>常見的鮑率 9600 19200 38400 115200<br> <span id="more"></span><br> 1 鮑率 即指每秒傳輸1個符號(bit)<br>9600代表每秒傳輸9600高低電平，如果不匹配會導致亂碼<br>每一個 bit 的時間就是 1&#x2F;9600</p>
<h1 id="數據幀"><a href="#數據幀" class="headerlink" title="數據幀"></a>數據幀</h1><p><img src="/images/20231119022310.png"></p>
<h2 id="啟始位元"><a href="#啟始位元" class="headerlink" title="啟始位元"></a>啟始位元</h2><p>表示資料封包開始， UART 的發送方會將資料傳輸線從高電壓低電壓變成低電壓</p>
<h2 id="資料位元"><a href="#資料位元" class="headerlink" title="資料位元"></a>資料位元</h2><p>可以定義為 5bit、6bit、7bit、8bit</p>
<h2 id="同位位元"><a href="#同位位元" class="headerlink" title="同位位元"></a>同位位元</h2><p>用於檢查資料正確性 同位位元有兩種模式：偶同位(even) 和 奇同位(odd)</p>
<h2 id="停止位元"><a href="#停止位元" class="headerlink" title="停止位元"></a>停止位元</h2><p>表示資料封包結束， UART 的發送方會將資料傳輸線從低電壓變成高電壓並保持1~2位元時間。</p>
<h2 id="現況"><a href="#現況" class="headerlink" title="現況"></a>現況</h2><p>現在 UART 很少使用同位位元來偵錯了。常見的「38400,8,N,1」這種設定，意思就是 38400 bps 的鮑率、8 個資料位元，N 則代表沒有同位位元，1 是 1 個停止位元的意思；現在其實已經很少看到後面不是「8,N,1」的設定，因為 同位位元已經幾乎不再使用，而 8 個資料位元和 1 個停止位元也幾乎成爲標準。</p>
<h2 id="接法"><a href="#接法" class="headerlink" title="接法"></a>接法</h2><p><img src="/images/20231119022341.png"><br>TX接RX RX接TX </p>
<h2 id="TTL電平-Transistor-Transistor-Logic"><a href="#TTL電平-Transistor-Transistor-Logic" class="headerlink" title="TTL電平 Transistor-Transistor Logic"></a>TTL電平 Transistor-Transistor Logic</h2><p><img src="/images/20231119022404.png"><br>2.4v<del>5v 為高電平 0</del>0.4 為低電平<br><img src="/images/20231119022417.png"><br>容易造成干擾 所以通訊距離大約1m內 改進RS232 和 RS485</p>
<h2 id="補充-UART串口流控制（Flow-control）"><a href="#補充-UART串口流控制（Flow-control）" class="headerlink" title="(補充) UART串口流控制（Flow control）"></a>(補充) UART串口流控制（Flow control）</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>是管理两个节点之间数据传输速率的过程，以防止出现接收端的数据缓冲区已满，而发送端依然继续发送数据，所导致数据丢失</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当接收端的数据缓冲区已满，无法处理数据来时，就发出 “不再接收” 的信号，发送端则停止发送，直到发送端收到 “可以继续发送” 的信号再发送数据。<br>计算机中常用的两种流控制分别是<strong>硬件流控制</strong>（RTS &#x2F;CTS、DTR &#x2F;DSR等）和<strong>软件流控制</strong>（XON &#x2F;XOFF）</p>
<h1 id="RS232"><a href="#RS232" class="headerlink" title="RS232"></a>RS232</h1><p>RS(Recommended Stabdard) 推薦標準<br>將TTL電平轉換成232電平 轉換電壓 抗干擾能力變強 還是傳輸原來的數據只是改變電壓 還是全雙工<br>傳輸距離到15米 2M&#x2F;s<br><img src="/images/20231119022441.png"><br>也是只用到 RxD TxD GND<br><img src="/images/20231119022454.png"><br>將TTL電平轉換成232電平<br><img src="/images/20231119022508.png"><br>進去TTL 5V 轉換成232電平 -12V (影片有錯)<br><img src="/images/20231119022520.png"><br>進去TTL 0V 轉換成232電平 +12V (影片有錯)<br><img src="/images/20231119022552.png"><br>正確的轉換<br><img src="/images/20231119022615.png"><br>232電平 高電平為3V-15V 低電平為-3V~-15V 抗干擾能力變強</p>
<h1 id="RS485"><a href="#RS485" class="headerlink" title="RS485"></a>RS485</h1><p>將TTL電平轉換成485電平 轉換差分信號 抗干擾能力變強 變成半雙工<br>傳輸距離到1200米 50M&#x2F;s<br><img src="/images/20231119022632.png"><br><img src="/images/20231119022701.png"><br>差分信號 A大於B訊號為0 B大於A訊號為1<br><img src="/images/20231119022714.png"><br>受干擾時，因為是雙絞線所以基本是是同時干擾，還是差分，干擾能力強</p>
<h1 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h1><p><img src="/images/20231119022730.png"><br>RS232 RS485 只有改變物理層</p>
<h1 id="參考影片"><a href="#參考影片" class="headerlink" title="參考影片"></a>參考影片</h1><ul>
<li><a href="https://www.youtube.com/watch?v=HKQaYN5Odlk">5分钟看懂!串口RS232 RS485最本质的区别！</a></li>
<li><a href="https://youtu.be/ia2x1oenic0">嵌入式系統(I)_洪崇文_單元四 通用非同步收發傳輸UART 與RS-232_Part 1 串列通訊介紹</a></li>
<li><a href="https://youtu.be/xKdV7lcvy1o">嵌入式系統(I)_洪崇文_單元四 通用非同步收發傳輸UART 與 RS-232_Part 2 UART通訊與RS232 I</a></li>
</ul>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://www.block.tw/blog/uart/">UART 串列通訊</a></li>
<li><a href="https://blog.csdn.net/qq_42992084/article/details/104761474">UART串口流控制（Flow control）</a></li>
<li><a href="https://blog.csdn.net/qq_42992084/article/details/104761474">UART串口流控制（Flow control）</a></li>
<li><a href="https://semhuang.pixnet.net/blog/post/141101276">UART 硬體流量控制 CTS及RTS</a></li>
<li><a href="https://silverwind1982.pixnet.net/blog/post/361701597-uart">UART 簡介</a></li>
</ul>
]]></content>
      <categories>
        <category>soc</category>
      </categories>
      <tags>
        <tag>RS232</tag>
        <tag>RS484</tag>
        <tag>TTL</tag>
        <tag>TXRX</tag>
        <tag>UART</tag>
      </tags>
  </entry>
  <entry>
    <title>VM安裝</title>
    <url>/posts/20231129101600-661de22d.html</url>
    <content><![CDATA[<h2 id="Install-Guest-Additions"><a href="#Install-Guest-Additions" class="headerlink" title="Install Guest Additions"></a>Install Guest Additions</h2><p><code>sudo apt-get install gcc make perl -y</code><br><img src="/images/20231129152725.png"><br>插入 Guest Additions CD 映像<br><img src="/images/20231129152840.png"><br>點擊Run<br><img src="/images/20231129152907.png"><br>輸入密碼<br> <span id="more"></span><br> <img src="/images/20231129152934.png"><br>運行中<br><img src="/images/20231129153043.png"><br>無報錯 安裝成功後 reboot 可以縮放 剪貼簿 公用資料夾</p>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://blog.csdn.net/bell_love/article/details/105401852">简单解决Please install the gcc make perl packages from your distribution问题</a></li>
</ul>
<h2 id="共用資料夾"><a href="#共用資料夾" class="headerlink" title="共用資料夾"></a>共用資料夾</h2><p><img src="/images/20231129154247.png"><br>點擊共用資料夾設定<br><img src="/images/20231129154432.png"><br>點擊加號<br><img src="/images/20231129154530.png"><br>輸入要掛載的資料夾 和 掛載點 點擊確認<br><img src="/images/20231129154609.png"><br>成功會出現在掛載點</p>
<h3 id="參考-1"><a href="#參考-1" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://www.jinnsblog.com/2021/05/virtualbox-shared-folder-permission-setting.html">[Linux &#x2F; Windows] VirtualBox 共用資料夾與雙向剪貼簿之權限設定</a></li>
</ul>
<h2 id="加入憑證"><a href="#加入憑證" class="headerlink" title="加入憑證"></a>加入憑證</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> my-ca-certificate.crt /usr/local/share/ca-certificates/</span><br><span class="line"><span class="built_in">cd</span> /usr/local/share/ca-certificates/</span><br><span class="line">sudo <span class="built_in">chmod</span> 644 my-ca-certificate.crt</span><br><span class="line">sudo  update-ca-certificates</span><br></pre></td></tr></table></figure>
<h3 id="參考-2"><a href="#參考-2" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://blog.kkbruce.net/2020/01/linux-windows-container-add-cert.html">如何為LINUX, WINDOWS容器加入憑證?</a></li>
</ul>
<h2 id="Samba"><a href="#Samba" class="headerlink" title="Samba"></a>Samba</h2><p><img src="/images/20231129163310.png"><br>新增網路介面卡2 僅限主機 介面卡</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install samba -y</span><br><span class="line">smbpasswd -a root #設定root 密碼</span><br><span class="line">vim /etc/samba/smb.conf </span><br></pre></td></tr></table></figure>
<p>smb.conf 加入底下的設定 使用root 登入 &#x2F;media&#x2F;new_drive 需要存在</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[brian]</span><br><span class="line">   comment = new_drive</span><br><span class="line">   public = yes</span><br><span class="line">   path = /media/new_drive</span><br><span class="line">   guest ok = yes</span><br><span class="line">   read only = no</span><br><span class="line">   browseable = yes</span><br><span class="line">   create mask = 777</span><br><span class="line">   directory mask = 777</span><br><span class="line">   writable = yes</span><br><span class="line">   valid users = root</span><br></pre></td></tr></table></figure>
<p><img src="/images/20231129160349.png"><br><code>samba restart</code> or <code>/etc/init.d/smbd restart</code><br><img src="/images/20231129160659.png"><br>本機右鍵 連線網路磁碟機<br><img src="/images/20231129160740.png"><br>輸入上面資訊 <code>\\192.168.56.108\brian</code> brian 為設定檔<code>[brian]</code><br>之後 按完成 需要輸入密碼 </p>
<h3 id="參考-3"><a href="#參考-3" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://hollyqood.wordpress.com/2016/12/08/virtualbox%e8%99%9b%e6%93%ac%e6%a9%9fubuntu%e4%bd%bf%e7%94%a8samba%e5%9c%96%e6%96%87%e6%95%99%e5%ad%b8/">virtualbox虛擬機ubuntu使用samba圖文教學</a></li>
</ul>
<h2 id="SSH-Server"><a href="#SSH-Server" class="headerlink" title="SSH Server"></a>SSH Server</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get install ssh -y</span><br><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>編輯這些參數</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Port 22</span><br><span class="line">PermitRootLogin yes</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line">AuthorizedKeysFile	.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<p>(可選)如果用root登入需要設定root密碼<br><code>sudo passwd</code><br>重啟ssh<br><code>/etc/init.d/ssh restart</code></p>
<h3 id="參考-4"><a href="#參考-4" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://www.ewdna.com/2012/06/ubuntu-ssh-server.html">Ubuntu 安裝與設定 ssh server</a></li>
<li><a href="https://askubuntu.com/questions/171521/what-is-the-password-for-ssh-rootlocalhost">What is the password for <code>ssh root@localhost</code>?</a></li>
</ul>
<h2 id="zsh-oh-my-zsh"><a href="#zsh-oh-my-zsh" class="headerlink" title="zsh + oh my zsh"></a>zsh + oh my zsh</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install zsh -y</span><br><span class="line">sudo sh -c <span class="string">&quot;echo <span class="subst">$(which zsh)</span> &gt;&gt; /etc/shells&quot;</span></span><br><span class="line">chsh -s /bin/zsh</span><br><span class="line">apt install git curl -y</span><br><span class="line"></span><br><span class="line"><span class="comment">#oh my zsh</span></span><br><span class="line">curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh | sh -s</span><br><span class="line"></span><br><span class="line"><span class="comment"># plugin zsh-autosuggestions</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br><span class="line"></span><br><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="comment"># plugins=(git zsh-autosuggestions) plugin添加zsh-autosuggestions</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># plugin zsh-syntax-highlighting</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br><span class="line"></span><br><span class="line">vim ~/.zshrc</span><br><span class="line"><span class="comment"># plugins=(git zsh-syntax-highlighting) plugin添加zsh-syntax-highlighting</span></span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>
<h3 id="參考-5"><a href="#參考-5" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://magiclen.org/zsh/">如何在Linux作業系統上使用 Z Shell (Zsh)？</a></li>
<li><a href="https://www.jianshu.com/p/43c1b6e40c69">zsh 命令自动补全插件 zsh-autosuggestions 安装和配置</a></li>
</ul>
<p><code>apt-get iputils-ping net-tools traceroute vim</code> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;&#123;&quot;</span>bip<span class="string">&quot;:&quot;</span>172.15.0.1/16<span class="string">&quot;&#125;&quot;</span> &gt; /etc/docker/daemon.json</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
        <tag>samba</tag>
        <tag>ssh-server</tag>
        <tag>vm</tag>
      </tags>
  </entry>
  <entry>
    <title>Zigbee介紹</title>
    <url>/posts/20231118195000-c8085013.html</url>
    <content><![CDATA[<ul>
<li><a href="https://blog.csdn.net/u011350258/article/details/113062464">1、ZigBee 开发教程之基础篇—ZigBee简介和学习方法</a></li>
<li><a href="https://zigbeealliance.org/wp-content/uploads/2019/12/Getting-Started-with-Zigbee-3.0-CN.pdf">手把手指南—— 开启你的 Zigbee 之旅</a> <span id="more"></span></li>
<li>Youtube <a href="https://www.youtube.com/playlist?list=PLkc2nflOpCG1jYSnd6gOWpV8XhrlEF-2J">Zigbee</a></li>
<li><a href="https://www.youtube.com/watch?v=iuhY4f_DvfI&ab_channel=TorchIoTBootCamp">Day 1-1 ZigBee基础知识</a></li>
<li><a href="https://blog.csdn.net/lexiyao/article/details/120969009">Zigbee快速入门第二节 – Zigbee基础介绍</a></li>
<li><a href="https://csa-iot.org/wp-content/uploads/2023/04/05-3474-23-csg-zigbee-specification-compressed.pdf">zigbee-specification</a></li>
</ul>
<h1 id="ZigBee基础知识"><a href="#ZigBee基础知识" class="headerlink" title="ZigBee基础知识"></a>ZigBee基础知识</h1><h2 id="What-is-ZigBee"><a href="#What-is-ZigBee" class="headerlink" title="What is ZigBee"></a>What is ZigBee</h2><h3 id="Zigbee"><a href="#Zigbee" class="headerlink" title="Zigbee"></a>Zigbee</h3><p><img src="/images/20231119024254.png"><br>右邊是覆蓋範圍大(10KM) 大多需要被管制的 由運營商主導 城市範圍的覆蓋<br>左邊是覆蓋範圍小(100m) 家庭 樓道用<br>Zigbee 短距離通訊技術 低速通訊技術 最大速度是250Kpbs<br>傳輸控制命令 和 數據採集<br>低功耗的技術 <a href="https://support.tuya.com/zh/help/_detail/K9skz5907xerr">休眠电流在uA級別</a><br>Mesh網路拓譜結構 網路輕鬆擴展 最大節點數 65535(wifi 50 BT 8)<br>2bytes&#x3D;16bits&#x3D;2^16&#x3D;65535<br>zigbee：10-100m，蓝牙：2-10m，Wi-Fi：30-100m</p>
<h3 id="Zigbee網路拓譜"><a href="#Zigbee網路拓譜" class="headerlink" title="Zigbee網路拓譜"></a>Zigbee網路拓譜</h3><p>Star(WiFi) vs Mesh(Zigbee) 主要差別在有無中心節點，中心節點壞了就不能正常工作</p>
<p>Zigbee(star mesh tree)<br><img src="/images/20231119024320.png"></p>
<h3 id="Zigbee-歷史"><a href="#Zigbee-歷史" class="headerlink" title="Zigbee 歷史"></a>Zigbee 歷史</h3><p><img src="/images/20231119024339.png"><br>2003年 Zigbee誕生<br>2016年 發布Zigbee3.0(整合統一之前的標準)</p>
<p><a href="https://www.51cto.com/article/496376.html">ZigBee 3.0版标准，强化低延迟与低功耗优势，并加入网际网路通讯协定(IP)支援能力</a></p>
<p>ZigBee完全相容Wi-Fi&#x2F;IP</p>
<p>ZigBee 3.0完全相容IP。ZigBee设备与Wi-Fi设备类似，通常透过路由器、闸道或机上盒连接到互联网，让人可在世界其他地方利用连接互联网的个人电脑、平板或智慧手机应用程式等任何其他设备实现即时控制(图3)。由于ZigBee完全相容Wi-Fi和IP，因此没必要在手机本身插入ZigBee晶片，从而发现和控制ZigBee连接的智慧家居和物联网设备。只要通过任何联网中心均可让这一切实现，这意味着，透过Wi-Fi或蜂窝网进行联网的个人电脑和智慧手机可以作为指示板，并可毫不费力发现并与其他ZigBee设备进行通讯。</p>
<p><a href="https://blog.csdn.net/mengqidluffy/article/details/116061885">小白也能读懂的 ZigBee 3.0 简介</a></p>
<h3 id="Zigbee-聯盟"><a href="#Zigbee-聯盟" class="headerlink" title="Zigbee 聯盟"></a>Zigbee 聯盟</h3><p><img src="/images/20231119024356.png"><br>推广Zigbee技术的主要力量。这是一个开放的组织。任何公司都可以加入Zigbee联盟作为成员。Silicon Labs是Zigbee联盟的董事会成员。</p>
<ul>
<li>为IoT（物联网）的无线设备端到设备端的通信制定开放的全球标准</li>
<li>通过我们的认证计划对产品进行认证，以帮助确保互操作性(產品和平台的認證)</li>
<li>在全球范围内推广我们的标准</li>
</ul>
<p><img src="/images/20231119024412.png"><br>Zigbee聯盟更名，同步推出與亞馬遜、蘋果及Google共同制定連接標準Matter</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="Zigbee協議"><a href="#Zigbee協議" class="headerlink" title="Zigbee協議"></a>Zigbee協議</h3><p><img src="/images/20231119024438.png"><br>基於<a href="https://baike.baidu.hk/item/IEEE%20802.15.4/6657379">IEEE802.15.4</a>標準基礎上定義<br>MAC層和物理層沿用IEEE802.15.4標準<br>網路層 APS層(Application Support Sub Layer) 應用層 是Zigbee定義的標準</p>
<p>網路層和APS層有加密的特性:加密 驗證 重傳保護</p>
<ul>
<li>物理層 由晶片實現 無線電的收發管理 調製解調</li>
<li>MAC層 一半硬體 一辦軟體實現 數據收發 確認 重傳 掃描</li>
<li>網路層 路由 設備狀狀態維護 子節點管理</li>
<li>APS層 端到端重傳和確認 </li>
<li>應用層 ZDO(ZigBee Device Object 特殊的設備管理功能) User應用</li>
</ul>
<p>灰色部分是晶片處理<br>綠色是平台供應商實現<br>橘色是應用層開發</p>
<blockquote>
<p>IEEE 802.15.4是一種技術標準，它定義了低速率無線個域網 （LR-WPAN）的協議。 它規定了LR-WPAN的物理層和媒體訪問控制 ，並由IEEE 802.15工作組維護，該工作組在2003年定義了該標準。它是Zigbee的基礎，諸如 ISA100.11a ， WirelessHART ， MiWi ， 6LoWPAN ，<br>PAN 個人區域網路</p>
</blockquote>
<h3 id="Zigbee物理層"><a href="#Zigbee物理層" class="headerlink" title="Zigbee物理層"></a>Zigbee物理層</h3><p><img src="/images/20231119024455.png"></p>
<h4 id="工作範圍在-2-4GHz-868MHz-915MHz"><a href="#工作範圍在-2-4GHz-868MHz-915MHz" class="headerlink" title="工作範圍在 2.4GHz 868MHz 915MHz"></a>工作範圍在 2.4GHz 868MHz 915MHz</h4><ul>
<li>2.4GHz  全球通用 250kpbs 11-26通道 2400MHz~2600MHz 每5MHz一個通道</li>
<li>868MHz 英國電表 水表(Smart Engery) 20kpbs 0通道 </li>
<li>915MHz 北美Zigbee 40kpbs 1-10通道 每2MHz一個通道</li>
</ul>
<h4 id="物理層功能"><a href="#物理層功能" class="headerlink" title="物理層功能"></a>物理層功能</h4><ul>
<li>物理无线和MAC层的接口</li>
<li>無線電收發管理</li>
<li>无线电开&#x2F;关控制</li>
<li>调制与解调</li>
<li>信道选择</li>
<li>链接质量估算</li>
<li>能量检测</li>
<li>功率調節</li>
</ul>
<h4 id="Zigbee-和-WIFI-共存"><a href="#Zigbee-和-WIFI-共存" class="headerlink" title="Zigbee 和 WIFI 共存??"></a>Zigbee 和 WIFI 共存??</h4><p><img src="/images/20231119024508.png"><br>Zigbee 和 WIFI 都使工作在2.4GHz 底下 會存在相互干擾的情況<br><a href="https://www.ebyte.com/new-view-info.aspx?id=1082">怎样设置Zigbee和wifi信道避免干扰？</a><br><a href="https://bbs.16rd.com/thread-574907-1-1.html">Zigbee和Wi-Fi的干擾和共存</a><br><a href="https://www.mwrf.net/tech/rfic/2020/27496.html">在2.4GHz共存-WLAN、蓝牙、ZigBee和Thread在2.4GHz频段共存</a></p>
<h3 id="Zigbee-MAC層"><a href="#Zigbee-MAC層" class="headerlink" title="Zigbee MAC層"></a>Zigbee MAC層</h3><h4 id="MAC幀"><a href="#MAC幀" class="headerlink" title="MAC幀"></a>MAC幀</h4><p><img src="/images/20231119024520.png"><br>前面PERAMBLE SPD PHYHeader 由物理層封裝<br>Frame Control(2bytes):標示frame類型</p>
<ul>
<li>Beacon 掃描網路</li>
<li>Data 上層數據</li>
<li>ACK 確認用</li>
<li>MAC Command 入網時候使用的命令 MAC关联过程。<br>CRC(最後2bytes): 驗證資料包的完整性 (空氣中傳播 受到干擾 資料會丟掉)</li>
</ul>
<h4 id="MAC-傳送確認"><a href="#MAC-傳送確認" class="headerlink" title="MAC 傳送確認"></a>MAC 傳送確認</h4><p><img src="/images/20231119024532.png"><br>MAC层还为节点提供了一种方法，该方法可通过确认得知节点已成功接收到1跳单播传输，并且已通过验证CRC保留了所传输消息的完整性。 多跳传输应在每个跳上进行确认。节点执行CCA检查并发送消息后，它会等待MAC确认。如果未收到消息，则该节点应尝试多次重发该消息，直到其最终成功或最大的重试次数已用尽。<br><img src="/images/20231119024545.png"><br>從NodeA到NodeD發送資料通常是應用層和應用層的傳送<br>NodeA 傳到到 NodeB 確認收到回傳MAC Ack 到 NodeA<br>不是NobeB接收的資料(資料最多在網路層) 往NodeC傳直到傳到正確的接收方<br>NodeD正確的接收要回傳APS Ack確認回NodeA</p>
<p>兩種不同的確認 如果沒收到Ack就會重傳</p>
<ul>
<li>MAC Ack 是點跟點的確認</li>
<li>APS Ack 是端到端的確認</li>
</ul>
<h4 id="CSMA-x2F-CA-避免干擾"><a href="#CSMA-x2F-CA-避免干擾" class="headerlink" title="CSMA&#x2F;CA 避免干擾"></a><a href="https://zhuanlan.zhihu.com/p/51412066">CSMA&#x2F;CA 避免干擾</a></h4><p>Listen Before Talk 發送資料前聽一下<br>判斷channel是否有人在使用<br>802.15.4允许多个网络位于同一通道上。因此，需要采取某种方式来避免来自不同网络的数据包在空中碰撞而造成通信错误。MAC子层使用CSMA-CA（Carrier Sense Multiple Access&#x2F;Collision Avoidance）控制对无线电的访问。避免碰撞是通过CCA（Clear Channel Assessment）完成的。在发送之前，每个节点必须检查电波是否可以正常发送（RSSI低于CCA阈值）。如果是，则节点应继续进行并在进行少量随机退避后进行传输。如果CCA没有通过，则该节点应等待多个退避周期，然后才能再次尝试该过程。随机退避允许多个节点交错传输，因此它们总是可以在某个时间点找到干净的无线空间来作数据传输。尽管比特率很低，因为数据包比较小（128 bytes），即使在非常嘈杂的信道上每一个节点也可以成功地完成数据传输。</p>
<p><a href="https://www.youtube.com/watch?v=wXbcBSQDnFA">CSMA&#x2F;CD</a> 兩種解決碰撞問題的機制<br>CSMA(Carrier Sense Mutiple Access) 防止碰撞機制 先偵測Hub上有無通訊 無才可通訊<br>CD(Collision Detection) 偵測碰撞 當偵測碰撞到碰撞時，發出JAM訊號 清空資料 再用 後退演算法錯開<br>CA(Collision Avoidance) 避免碰撞<br><a href="https://wiki.mbalib.com/zh-tw/CSMA/CA">CSMA&#x2F;CA</a></p>
<blockquote>
<p>CSMA&#x2F;CA是先聽一下附近有沒有人講話，沒有人講話再講話<br>CSMA&#x2F;CD是不管了直接傳，發現打斷其他人講話時就回來等一下再傳</p>
</blockquote>
<p>(一)差異： </p>
<ol>
<li>CSMA&#x2F;CD主要應用在有線網路，CSMA&#x2F;CA主要應用在無線網路。</li>
<li>CSMA&#x2F;CD是使用碰撞偵測處理(Collision Detection)，在有線網路的環境中，可以檢測碰撞，但不容易去 避免。CSMA&#x2F;CA是使用避免碰撞處理(Collision Avoidance)，在無線網路的環境中，要使用CD去偵測碰 撞是困難的，所以在無線網路中採取CA的方式避免碰撞。 </li>
<li>CSMA&#x2F;CD的傳輸效率較佳，但硬體成本比較高。CSMA&#x2F;CA的傳輸效率較差，但硬體成本比較低。<br>(二)運作過程： </li>
<li>CSMA&#x2F;CD是在偵測是否有通道空閒後，在發送資料時同時進行防止Collision的檢查，如果在發送數據過 程中檢測到衝突，就立即停止發送資料，並等待一段時間，再重新發送碰撞的資料。</li>
<li>CSMA&#x2F;CA在送出資料前，先送RTS封包確認或是聆聽網路上的狀態，若沒有人使用，等待一段時間後， 如果還沒有人使用，才送出資料。</li>
</ol>
<h3 id="Zigbee-網路層"><a href="#Zigbee-網路層" class="headerlink" title="Zigbee 網路層"></a>Zigbee 網路層</h3><h4 id="裝置類型"><a href="#裝置類型" class="headerlink" title="裝置類型"></a>裝置類型</h4><p><img src="/images/20231119024603.png"></p>
<ul>
<li>Coordinator 協調員<ul>
<li>一個Zigbee網路只能有一個</li>
<li>創建網路  第一個成員 地址為0x000</li>
<li>可以路由 添加成員</li>
<li>不能睡眠</li>
</ul>
</li>
<li>Router 路由<ul>
<li>可以路由</li>
<li>不能睡眠</li>
</ul>
</li>
<li>End Device&#x2F; Sleepy End Device 終端設備<ul>
<li>必須附著在 Coordinator 或 Router 上</li>
<li>不能路由 只能接收</li>
<li>可睡眠</li>
</ul>
</li>
</ul>
<h4 id="Device-Announce-加入網路時所發送的訊息"><a href="#Device-Announce-加入網路時所發送的訊息" class="headerlink" title="Device Announce (加入網路時所發送的訊息)"></a>Device Announce (加入網路時所發送的訊息)</h4><p><img src="/images/20231119024617.png"><br>Device Type(IEEE-802.15.4定义了两种设备类型)：</p>
<ul>
<li>FFD(Full Function Device), 全功能设备，能够执行IEEE 802.15.4标准中描述的所有职责，并且可以在网络中担任任何角色。Coordinator&#x2F;Router</li>
<li>RFD(Reduced Function Device), 剪裁功能设备，功能有限。 End Device&#x2F; Sleepy End Device</li>
</ul>
<blockquote>
<p>RFD设备的处理能力和内存大小通常小于FFD设备。<br><img src="/images/20231119024634.png"><br>Alternate PAN Coordination 標示是否為 Coordinator<br><img src="/images/20231119024648.png"><br>Power Source Main 電源供電或者電池供電</p>
</blockquote>
<h4 id="網路地址-Addressing-PAN-ID-and-xPan-ID-Extended-PAN-ID"><a href="#網路地址-Addressing-PAN-ID-and-xPan-ID-Extended-PAN-ID" class="headerlink" title="網路地址 Addressing PAN ID and (xPan ID)Extended PAN ID"></a>網路地址 Addressing PAN ID and (xPan ID)Extended PAN ID</h4><p><img src="/images/20231119024701.png"></p>
<ul>
<li>PAN ID: 短的(不唯一) 16bit 由用戶或Coordinator隨機生成 用於mac層過濾用 0xFFFF 用於廣播 </li>
<li>xPan ID: 長的(唯一值) Coordinator隨機生成 只有在Beacon會傳送  用於解決PAN ID衝突</li>
</ul>
<blockquote>
<p>低速通訊技術 250kpbs 有效數據負荷占比低(mac頭部 network頭部…) 如果每次用64bit效數據負荷占比低 所以用短的網路地址</p>
</blockquote>
<blockquote>
<p>mac層收到不是自己的PAN ID 就丟掉</p>
</blockquote>
<p><img src="/images/20231119024719.png"><br>☝️Beacon的封包</p>
<h4 id="設備地址-Addressing-Node-ID-and-IEEE-Address"><a href="#設備地址-Addressing-Node-ID-and-IEEE-Address" class="headerlink" title="設備地址 Addressing Node ID and IEEE Address"></a>設備地址 Addressing Node ID and IEEE Address</h4><ul>
<li>Node ID(Short ID) 16bits加入網路時父節點分配 可能會衝突</li>
<li>IEEE Address(Long ID) 64bits (MAC Address) 出廠就設定好 解決Node ID衝突<br>再傳送的時候用NodeID傳送<br>如果出現衝突就更改NodeID</li>
</ul>
<h3 id="Zigbee-應用層"><a href="#Zigbee-應用層" class="headerlink" title="Zigbee 應用層"></a>Zigbee 應用層</h3><h4 id="EndPoint-有點像Port的概念-範圍0-255"><a href="#EndPoint-有點像Port的概念-範圍0-255" class="headerlink" title="EndPoint 有點像Port的概念 範圍0-255"></a>EndPoint 有點像Port的概念 範圍0-255</h4><p><img src="/images/20231119024733.png"></p>
<p>EndPoint 1-239 用戶開發用<br>EndPoint 0, 240-255 保留用 0(ZDO Zigbee設備管理用) 255 廣播所有EndPoint</p>
<p>Endpoints存在於每個節點中，以1~240的數字編號，<br>每個endpoint定義了一個在ZigBee節點上運行的application<br>(一個node可以有多個applications，也就是多個endpoints)</p>
<p>Endpoints的三個用途：</p>
<ul>
<li>允許不同的app profiles存在於一個節點</li>
<li>允許一個節點中的不同控制點</li>
<li>允許一個節點中有不同的devices<br><img src="/images/20231119024755.png"><br>通訊是 EndPoint to EndPoint<br>一個當 Client 一個當 Server<br>通訊內容是由<strong>Cluster</strong>格式定義<br><img src="/images/20231119024811.png"><br>Cluster: 通訊Model<br>Client&#x2F;Server model<br>每一個Cluster定義一個功能(On&#x2F;Off Cluster、Level Cluster) ZCL(Zigbee Cluster Library)<br>定義命令和屬性<br><img src="/images/20231119024826.png"><br>以控制燈開關為例 開關為Client 燈為Server<br>On&#x2F;Off Cluster:<br>Commend: OnOff、Toggle<br>Attribute: On、Off</li>
</ul>
<blockquote>
<p>Cluster大多定義好了功用的 但也可以客製化定義 但這樣就不通用</p>
</blockquote>
<h2 id="安全特性-偽造-重傳"><a href="#安全特性-偽造-重傳" class="headerlink" title="安全特性(偽造 重傳)"></a>安全特性(偽造 重傳)</h2><h3 id="應用層安全"><a href="#應用層安全" class="headerlink" title="應用層安全"></a>應用層安全</h3><p><img src="/images/20231119024856.png"><br>將Applocation層的Payload加密 中間加安全頭部 然後算出Hash值 加到最後面往下傳<br>通過檢查Hash值(APS MIC)檢查應用層有無被篡改</p>
<h3 id="網路層安全"><a href="#網路層安全" class="headerlink" title="網路層安全"></a>網路層安全</h3><p><img src="/images/20231119024909.png"><br>將Network層的Payload加密 中間加安全頭部 然後算出Hash值 加到最後面往下傳<br>通過檢查Hash值(NWK MIC)檢查應用層有無被篡改</p>
<blockquote>
<p>應用層網路層對稱加密: AES128<br><img src="/images/20231119024953.png"><br>安全頭部(APS Auxiliary HDR、NWK Auxiliary HDR)有Frame Counter防止重傳</p>
</blockquote>
<h3 id="Frame-Counter-防止重傳"><a href="#Frame-Counter-防止重傳" class="headerlink" title="Frame Counter 防止重傳"></a>Frame Counter 防止重傳</h3><p><img src="/images/20231119025007.png"><br>接收端會記錄收到的 FrameCounter 如果接收到一樣就會丟掉封包 (只會紀錄周圍節點的FrameCounter)<br>發送端每次發送封包時會將 FrameCounter++ 達到每次FrameCounter都不一樣</p>
<h3 id="安全特點-端到端-點到點"><a href="#安全特點-端到端-點到點" class="headerlink" title="安全特點 端到端 點到點"></a>安全特點 端到端 點到點</h3><p><img src="/images/20231119025021.png"><br>NodeA傳到NodeC 中間NodeB不會去解開APS層的資料 NodeB只會解開網路層的資料<br>APS層是 端到端 端跟端之間有秘鑰(Link Key)<br>網路層是 點到點 點跟點之間有秘鑰(NWK Key)</p>
<h3 id="NWK-Key"><a href="#NWK-Key" class="headerlink" title="NWK Key"></a>NWK Key</h3><p><img src="/images/20231119025033.png"></p>
<ul>
<li>整個網路用的NWK Key都是一樣</li>
<li>在創建網路時隨機生成 16-byte</li>
<li>NWK 靠應用層加密傳輸</li>
<li>Trust Center: 提供NWK Key的裝置(通常是Coordinator)</li>
<li>有兩種模式 Centralized Distrbuted</li>
</ul>
<h4 id="傳送-NWK-Key"><a href="#傳送-NWK-Key" class="headerlink" title="傳送 NWK Key"></a>傳送 NWK Key</h4><h3 id="Link-Key"><a href="#Link-Key" class="headerlink" title="Link Key"></a>Link Key</h3><ul>
<li>16-byte</li>
<li>Trust Center Link Key 新設備加入網路傳送NWK key</li>
<li>(install code[出廠設定] + 算法) 或 (<strong>ZigbeeAlliance09</strong>)</li>
</ul>
<h4 id="install-code-是透過人工完成的-更安全"><a href="#install-code-是透過人工完成的-更安全" class="headerlink" title="install code 是透過人工完成的 更安全"></a>install code 是透過人工完成的 更安全</h4><p><img src="/images/20231119025052.png"></p>
<h2 id="加入網路"><a href="#加入網路" class="headerlink" title="加入網路"></a><a href="https://blog.csdn.net/lee_jimmy/article/details/109162896">加入網路</a></h2><h3 id="通用Link-Key-ZigbeeAlliance09"><a href="#通用Link-Key-ZigbeeAlliance09" class="headerlink" title="通用Link Key(ZigbeeAlliance09)"></a>通用Link Key(ZigbeeAlliance09)</h3><p><img src="/images/20231119025110.png"></p>
<ul>
<li>Coordinator 創建網路 設定PAN ID、xPAN ID、通道、功率</li>
<li>設備可以加入網路</li>
<li>掃描網路，新設備在每個通道發起Beacon Request等待有無回應 無回應往下一個通道發Beacon Request (因為不知道所以全發)</li>
<li>Coordinator收到Beacon Request回覆 一個Beacon(包含PAN ID xPAN ID…)</li>
<li>設備可能會收到很多Beacon，選擇用rssi最強當作父節點 再發送Association Request 包含(自己設備的能力…)</li>
<li>父節點發送Association Response(分配給他沒人用 Node ID)</li>
<li>等待接收NWK Key (Trust Center 會用Link Key(ZigbeeAlliance09)加密NWK Key) 用ZigbeeAlliance09解密</li>
<li>router会发送一个device announce的报文（从目的地址为广播地址可以看出）通知全网，我入网了、我的设备信息都有哪些。</li>
<li>之後就可以通訊了</li>
</ul>
<h3 id="使用Install-Code"><a href="#使用Install-Code" class="headerlink" title="使用Install Code"></a>使用Install Code</h3><p><img src="/images/20231119025123.png"></p>
<ul>
<li>Coordinator 創建網路 設定PAN ID、xPAN ID、通道、功率</li>
<li>設備可以加入網路</li>
<li>Coordinator 掃描 新設備Install Code建立Link Key</li>
<li>掃描網路，新設備在每個通道發起Beacon Request等待有無回應 無回應往下一個通道發Beacon Request (因為不知道所以全發)</li>
<li>Coordinator收到Beacon Request回覆 一個Beacon(包含PAN ID xPAN ID…)</li>
<li>設備可能會收到很多Beacon，選擇用rssi最強當作父節點 再發送Association Request 包含(自己設備的能力…)</li>
<li>父節點發送Association Response(分配給他沒人用 Node ID)</li>
<li>等待接收NWK Key (Trust Center 會用Link Key(由掃描到的Install Code建立)加密NWK Key) 用設備上的Install Code產生Link Key解密</li>
<li>router会发送一个device announce的报文（从目的地址为广播地址可以看出）通知全网，我入网了、我的设备信息都有哪些。</li>
<li>之後就可以通訊了</li>
</ul>
<p><a href="https://blog.csdn.net/u012993936/article/details/88225371">Zigbee抓包工具</a></p>
<ul>
<li>Packet Sniffer</li>
<li>Ubiqua</li>
<li>Wireshark <ul>
<li><a href="https://segmentfault.com/a/1190000041469759">手把手教你如何通过CC2531抓取Zigbee包，并解析加密Zigbee包</a></li>
<li><a href="https://www.twblogs.net/a/5b8f25562b717718834a0ac9">使用CC2531 USB Dongle 抓取小米Zigbee智能硬件數據包</a></li>
<li><a href="https://www.ruten.com.tw/find/?q=+CC2531">露天CC2531</a></li>
<li><a href="https://www.twblogs.net/a/5c80fb1fbd9eee35fc136d05">如何用Wireshark對Zigbee進行抓包分析</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/489493842">ZigBee 无线报文的抓取与分析</a></li>
<li><a href="https://item.taobao.com/item.htm?id=657969866117">USB Dongle CC2530 CC2531 ZigBee 协议栈 分析 抓包 工具 模块</a></li>
<li><a href="http://bbs.sunsili.com/thread-226165-1-1.html">利用Wireshark对Zigbee进行抓包分析</a></li>
</ul>
</li>
</ul>
<h2 id="认识Profile和Cluster"><a href="#认识Profile和Cluster" class="headerlink" title="认识Profile和Cluster"></a><a href="https://blog.csdn.net/yanwumuxi/article/details/123866005">认识Profile和Cluster</a></h2><p><a href="https://community.nxp.com/pwmxy87654/attachments/pwmxy87654/wireless-connectivity/698/1/075367r03ZB_AFG-Home_Automation_Profile_for_Public_Download.pdf">Zigbee Profile</a><br><img src="/images/20231119025145.png"></p>
<hr>
<h3 id="Silicon-Labs-GeckoSDK"><a href="#Silicon-Labs-GeckoSDK" class="headerlink" title="Silicon Labs GeckoSDK"></a>Silicon Labs GeckoSDK</h3><ul>
<li><a href="https://www.silabs.com/documents/public/user-guides/ug491-zigbee-app-framework-dev-guide-sdk-7x.pdf">zigbee-app-framework-dev-guide-sdk-pdf</a></li>
<li><a href="https://community.silabs.com/s/question/0D58Y00008aZEGPSA4/hello-im-working-on-a-zigbee-minimals-project-with-the-efr32-xxx-and-i-would-like-to-ask-you-how-to-create-a-callback-to-do-an-action-every-5-minutes-thank-you?language=zh_TW">New Callback</a></li>
<li><a href="https://github.com/SiliconLabs/IoT-Developer-Boot-Camp/wiki/Zigbee-Boot-Camp">Zigbee-Boot-Camp</a></li>
<li><a href="https://www.silabs.com/wireless/zigbee/efr32mg24-series-2-modules/device.mgm240pa32vnn?tab=specs">MGM240PA32VNN</a></li>
<li><a href="https://blog.csdn.net/lexiyao/article/details/109153280">Zigbee应用程序框架开发指南 - 概述</a></li>
<li><a href="https://www.sekorm.com/news/30245981.html">【经验】EmberZnet CLI指令之绑定功能实现过程</a></li>
<li><a href="https://blog.csdn.net/yanwumuxi/article/details/123866005">Zigbee Profile</a></li>
<li><a href="https://community.silabs.com/s/article/zigbee-3-0-tutorial-light-and-switch-from-scratch-step-5?language=en_US">ZigBee 3.0 Tutorial - Light and Switch from Scratch</a></li>
<li><a href="https://github.com/SiliconLabs/zigbee_applications/tree/a90ebc1e6a06ac7dd1e158f435f58e910595a477">zigbee_applications example</a></li>
<li><a href="https://space.bilibili.com/641942011/channel/seriesdetail?sid=726018">bilibili</a></li>
<li><a href="https://workshop.siliconforce.com/?p=862">Silicon Labs EFM8 的 Hello World 程式</a></li>
</ul>
<hr>
<h3 id="TI-Z-Stack"><a href="#TI-Z-Stack" class="headerlink" title="TI Z-Stack"></a>TI Z-Stack</h3><ul>
<li><a href="https://www.ti.com/zh-tw/homepage.html">Texas Instruments</a></li>
<li><a href="https://software-dl.ti.com/simplelink/esd/plugins/simplelink_zigbee_sdk_plugin/1.60.01.09/exports/docs/zigbee_user_guide/html/zigbee/introduction.html">TI Z-Stack User Guide</a></li>
<li><a href="https://www.bilibili.com/video/BV1d94y117kj/">ZigBee开发-嵌入式物联网开发教程学习</a></li>
<li><a href="https://blog.csdn.net/yanwumuxi/article/details/126485087">Zigbee学习（三）Z-Stack代码框架解析</a></li>
<li><a href="https://blog.csdn.net/yanwumuxi/article/details/131128082">Zigbee学习（四）入网流程及抓包分析</a></li>
<li><a href="https://docs.wireless-tech.cn/doc/101/">Zigbee驱动安装-抓包环境搭建</a></li>
<li><a href="https://blog.csdn.net/lixiaocheng1983/article/details/123090679?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5-123090679-blog-88225371.235%5Ev38%5Epc_relevant_sort_base1&spm=1001.2101.3001.4242.4&utm_relevant_index=8">手把手教你如何通过CC2531抓取Zigbee包，并解析加密Zigbee包</a></li>
</ul>
<hr>
<h3 id="zigpy"><a href="#zigpy" class="headerlink" title="zigpy"></a>zigpy</h3><p><a href="https://github.com/zigpy/zigpy">zigpy</a><br><a href="https://github.com/zigpy/zigpy-cli">zugpy-cli</a></p>
<h3 id="ZDO"><a href="#ZDO" class="headerlink" title="ZDO"></a><a href="https://www.wpgdadatong.com/question/detail/15822">ZDO</a></h3><p>提供了所有ZigBee设备共同的特殊应用，以管理已描述的各种过程。此应用程序是ZigBee设备对象或ZDO。它位于节点的应用层，并且可以使用 ZigBee设备配置文件（ZDP）和相关 cluster通过端点0与远程节点通信。它具有以下作用：</p>
<ol>
<li>定义网络设备的类型：协调器、路由器或终端设备</li>
<li>初始化节点以允许应用程序运行。</li>
<li>执行设备发现和服务发现过程。</li>
<li>实现允许协调器创建网络以及路由器和终端设备加入和离开网络所需的过程。</li>
<li>启动并响应绑定请求。</li>
<li>启动并响应绑定请求提供允许在应用程序之间建立安全关系的安全服务。</li>
<li>允许远程节点从节点检索信息，如路由表和绑定表，并执行节点的远程管理，如指示它离开网络。</li>
</ol>
<p>ZDO使用堆栈内的服务来实现这些角色，并提供了一种允许用户应用程序访问堆栈服务的方法。</p>
<p><a href="https://blog.csdn.net/qq_35413125/article/details/116986028">ZigBeePro协议栈词汇名词解释</a></p>
<p><a href="https://blog.csdn.net/Msymbol/article/details/111194158">Thread协议介绍</a><br><a href="https://iknow.stpi.narl.org.tw/Post/Read.aspx?PostID=10327">Thread可能取代Zigbee -ZHA並衝擊智慧家庭的通訊標準</a><br><a href="https://www.kocpc.com.tw/archives/476397">無線技術 Thread 是什麼？它會是智慧家庭的未來嗎？</a><br><a href="https://turadise.com/matter-thread/">Matter智慧家庭控制標準協定,用Thread整合智能居家控制系統</a></p>
]]></content>
      <categories>
        <category>zigbee</category>
      </categories>
      <tags>
        <tag>Zigbee</tag>
        <tag>IEEE802154</tag>
      </tags>
  </entry>
  <entry>
    <title>git@github.com Permission denied (publickey)</title>
    <url>/posts/20230505084825-9174ad3f.html</url>
    <content><![CDATA[<p>git clone permission denied(publickey)<br><img src="/images/pasted-0.png"><br>原因：git clone 沒有ssh的publickey<br>解決：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>

<p>如果沒有產生過公鑰，會產下面錯誤</p>
<blockquote>
<p>cat: &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub: No such file or directory</p>
</blockquote>
<p>使用ssh-keygen產公鑰(遇到提示按Enter)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br></pre></td></tr></table></figure>

<p>將印出來的公鑰設定去<a href="https://github.com/settings/ssh/new">SSH Add New Key</a> or (GitHub &gt;&gt; Settings &gt;&gt; SSH and GPG keys &gt;&gt; New SSH key)<br><img src="/images/pasted-2.png"></p>
]]></content>
  </entry>
  <entry>
    <title>html隱藏元素的方法</title>
    <url>/posts/20240122061800-aae208a6.html</url>
    <content><![CDATA[<ol>
<li><a href="https://api.jquery.com/hide/">用jquery hide()的方式控制style</a><br> <code>$(&quot;.target&quot;).hide();</code></li>
<li><strong>用Html的方式直接更改hidden屬性</strong><br> <code>hidden=&quot;true&quot;</code></li>
<li><strong>用css style的方式直接更改display屬性</strong><br> <code>style=&#39;display:none&#39;</code></li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>hidden</tag>
      </tags>
  </entry>
  <entry>
    <title>python進度條tqdm</title>
    <url>/posts/20240124061700-2ff23ae2.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在查網站時，無意間逛到<a href="https://stackoverflow.com/questions/276052/how-to-get-current-cpu-and-ram-usage-in-python/69511430#69511430">stackoverflow</a>，有人用python的tqdm顯示記憶體和cpu的使用量，看起來有點酷炫，就來複製貼上玩一下吧，也可以用在python需要耗時的程式上，也不用一直print log看起來非常亂。<br> <span id="more"></span></p>
<h1 id="tqdm"><a href="#tqdm" class="headerlink" title="tqdm"></a>tqdm</h1><h2 id="pip-安裝-tqdm"><a href="#pip-安裝-tqdm" class="headerlink" title="pip 安裝 tqdm"></a>pip 安裝 tqdm</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 -m pip install tqdm </span><br><span class="line"># or</span><br><span class="line">pip3 install tqdm</span><br></pre></td></tr></table></figure>
<h2 id="複製程式碼"><a href="#複製程式碼" class="headerlink" title="複製程式碼"></a>複製程式碼</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tqdm import tqdm</span><br><span class="line">from time import sleep</span><br><span class="line">import psutil</span><br><span class="line"></span><br><span class="line">with tqdm(total=100, desc=&#x27;cpu%&#x27;, position=1) as cpubar, tqdm(total=100, desc=&#x27;ram%&#x27;, position=0) as rambar:</span><br><span class="line">    while True:</span><br><span class="line">        rambar.n=psutil.virtual_memory().percent</span><br><span class="line">        cpubar.n=psutil.cpu_percent()</span><br><span class="line">        rambar.refresh()</span><br><span class="line">        cpubar.refresh()</span><br><span class="line">        sleep(0.5)</span><br></pre></td></tr></table></figure>
<h2 id="看看成果"><a href="#看看成果" class="headerlink" title="看看成果"></a>看看成果</h2><p><img src="/images/20240124113531.gif"><br>是不是非常酷炫<br><code>tqdm(total=100, desc=&#39;cpu%&#39;, position=1) as cpubar</code><br><code>tqdm(total=100, desc=&#39;ram%&#39;, position=0) as rambar</code><br>個別宣告兩個進度條 <code>position</code>是顯示在第幾條位置<br>然後用<code>.n</code>更新值，再用 <code>.refresh()</code>去刷新terminal</p>
<h2 id="再上範例1-單進程"><a href="#再上範例1-單進程" class="headerlink" title="再上範例1 單進程"></a>再上範例1 單進程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">total = 300</span><br><span class="line">for i in range(total):</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>
<p>假設任務有300個 ++ 就算完成 每次都print 一下<br>結果如下，就會非常凌亂，不夠炫炮<br><img src="/images/20240125155025.png"></p>
<h3 id="使用-tqdm"><a href="#使用-tqdm" class="headerlink" title="使用 tqdm"></a>使用 tqdm</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from tqdm import tqdm</span><br><span class="line">from time import sleep</span><br><span class="line">total = 300</span><br><span class="line">progress = tqdm(total=total, desc=&#x27;progress&#x27;, position=1)</span><br><span class="line"></span><br><span class="line">for i in range(total):</span><br><span class="line">    progress.set_description(f&#x27;Processing: &#123;i&#125;&#x27;)</span><br><span class="line">    progress.update()</span><br><span class="line">    sleep(0.1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>這裡也假設任務有300個 ++ 就算完成 每次都去 <code>update()</code> 進度條一下<br><code>update()</code>就是去++ 進度條的值 因為 total 有設定 所以會自動算出完成度幾 percent<br><img src="/images/20240125160318.gif"><br>套用在自己耗時的程式馬上，就不會印的很凌亂，非常直覺</p>
<h2 id="再上範例2-多進程"><a href="#再上範例2-多進程" class="headerlink" title="再上範例2 多進程"></a>再上範例2 多進程</h2><blockquote>
<p>需要考慮競爭的問題</p>
</blockquote>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><p><a href="https://stackoverflow.com/questions/276052/how-to-get-current-cpu-and-ram-usage-in-python/69511430#69511430">stackoverflow</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>裝B</tag>
        <tag>酷炫</tag>
      </tags>
  </entry>
  <entry>
    <title>使用WebCodecs API對H264解碼</title>
    <url>/posts/20240122021600-ef8abaf3.html</url>
    <content><![CDATA[<h1 id="介紹"><a href="#介紹" class="headerlink" title="介紹"></a>介紹</h1><p>WebCodecs API 是可以讓開發者直接使用硬體資源，拿來處理影片或聲音，在還沒個出來之前大多的實作方法是用 webassembly 或是 原生 JavaScript 處理，這些方法需要多加載另外的資源，而且也無法使用到像是GPU的資源，使得效率低。</p>
<h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p><img src="/images/20240122092416.png"></p>
<ol>
<li><code>H264NALu</code> 轉成 <code>EncodedVideoChunk</code> 物件 <span id="more"></span></li>
<li>交給 <code>VideoDecoder</code> 做解碼 </li>
<li>產物為 <code>VideoFrame</code> 會後交給 <code>Canvas</code> 渲染<br>其中 <code>EncodedVideoChunk</code> <code>VideoDecoder</code> <code>VideoFrame</code> 為  WebCodecs API 內物件</li>
</ol>
<h1 id="上程式"><a href="#上程式" class="headerlink" title="上程式"></a>上程式</h1><h2 id="建立-VideoDecoder"><a href="#建立-VideoDecoder" class="headerlink" title="建立 VideoDecoder"></a>建立 VideoDecoder</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleFrame</span>(<span class="params">frame</span>) &#123;</span><br><span class="line">	<span class="comment">// render by canvas</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = &#123;</span><br><span class="line">	<span class="attr">output</span>: handleFrame,</span><br><span class="line">	<span class="attr">error</span>: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">	  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">message</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">	<span class="attr">codec</span>: <span class="string">&quot;avc1.4d401e&quot;</span>,</span><br><span class="line">	<span class="attr">codedWidth</span>: <span class="number">1920</span>,</span><br><span class="line">	<span class="attr">codedHeight</span>: <span class="number">1080</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decoder = <span class="keyword">new</span> <span class="title class_">VideoDecoder</span>(init);</span><br><span class="line">decoder.<span class="title function_">configure</span>(config);</span><br></pre></td></tr></table></figure>
<p><code>handleFrame</code>為decoder解碼完產生<code>VideoFrame</code>的callback方法，產出的每一幀都會調用這個方法，之後就是交給 <code>Canvas</code> 渲染<br><code>init</code>和<code>config</code>使用配置<code>VideoDecoder</code>的參數</p>
<blockquote>
<p>使用 <code>await VideoDecoder.isConfigSupported(config)</code><br> 檢查<code>config</code> 是否支援</p>
</blockquote>
<h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><p><a href="https://developer.mozilla.org/en-US/docs/Web/API/VideoDecoder">VideoDecoder</a></p>
<h2 id="將-H264NALU轉換成EncodedVideoChunk"><a href="#將-H264NALU轉換成EncodedVideoChunk" class="headerlink" title="將 H264NALU轉換成EncodedVideoChunk"></a>將 H264NALU轉換成<code>EncodedVideoChunk</code></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> init = &#123;</span><br><span class="line">  <span class="attr">type</span>: unit.<span class="property">type</span> === <span class="number">5</span> ? <span class="string">&#x27;key&#x27;</span> : <span class="string">&#x27;delta&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: h26XBuffer,</span><br><span class="line">  <span class="attr">timestamp</span>: timestamp,</span><br><span class="line">&#125;;</span><br><span class="line">chunk = <span class="keyword">new</span> <span class="title class_">EncodedVideoChunk</span>(init);</span><br><span class="line">decoder.<span class="title function_">decode</span>(chunk);</span><br></pre></td></tr></table></figure>
<p><code>EncodedVideoChunk</code> 初始化要分辨這一幀是 <code>key</code> 或 <code>delta</code> (使用NALu的unit_type)<br><code>key</code>:  IDR幀 關鍵幀<br><code>delta</code>: P幀 或 B幀<br>產生出來的 <code>chunk</code> 就可以餵到<code>decoder</code>去解碼了</p>
<h3 id="參考-1"><a href="#參考-1" class="headerlink" title="參考"></a>參考</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk/EncodedVideoChunk">EncodedVideoChunk</a></li>
<li><a href="/posts/20240116080900-8a796e7c.html" title="H264基礎知識">H264基礎知識</a></li>
</ul>
<h2 id="將Video渲染到Canva上"><a href="#將Video渲染到Canva上" class="headerlink" title="將Video渲染到Canva上"></a>將<code>Video</code>渲染到<code>Canva</code>上</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function handleFrame(frame) &#123;</span><br><span class="line">	const bitmap = await createImageBitmap(frame);</span><br><span class="line">	ctx.drawImage(bitmap, 0, 0);</span><br><span class="line">	frame.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>上述程式帶大家大致過一下WebCodecs API的流程，具體還有很多細節沒有說明，大家再小心服用，至於H265格式，可以參考<a href="/posts/20240125024300-49fdb147.html" title="使用WebCodecs API對H265解碼">使用WebCodecs API對H265解碼</a> </p>
<h1 id="參考-2"><a href="#參考-2" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="https://chenng.cn/posts/WebCodecs%E5%AF%B9%E9%9F%B3%E8%A7%86%E9%A2%91%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81/">WebCodecs对音视频进行编码解码</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WebCodecs_API">WebCodecs API</a></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>H264</tag>
        <tag>WebCodecsAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>使用WebCodecs API對H265解碼</title>
    <url>/posts/20240125024300-49fdb147.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>這邊接續<a href="/posts/20240122021600-ef8abaf3.html" title="使用WebCodecs API對H264解碼">使用WebCodecs API對H264解碼</a>，現在處理H265格式，這裡的只是將程式碼有一點小改動</p>
<h1 id="差異"><a href="#差異" class="headerlink" title="差異"></a>差異</h1><h2 id="建立-VideoDecoder"><a href="#建立-VideoDecoder" class="headerlink" title="建立 VideoDecoder"></a>建立 VideoDecoder</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleFrame</span>(<span class="params">frame</span>) &#123;</span><br><span class="line">	<span class="comment">// render by canvas</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> init = &#123;</span><br><span class="line">	<span class="attr">output</span>: handleFrame,</span><br><span class="line">	<span class="attr">error</span>: <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">	  <span class="variable language_">console</span>.<span class="title function_">log</span>(e.<span class="property">message</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">	<span class="attr">codec</span>: <span class="string">&quot;hev1.1.6.L123.B0&quot;</span>,</span><br><span class="line">	<span class="attr">codedWidth</span>: <span class="number">1920</span>,</span><br><span class="line">	<span class="attr">codedHeight</span>: <span class="number">1080</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> decoder = <span class="keyword">new</span> <span class="title class_">VideoDecoder</span>(init);</span><br><span class="line">decoder.<span class="title function_">configure</span>(config);</span><br></pre></td></tr></table></figure>
<p>這裡的不同的是  H264 和 H265 使用的 codec 不同</p>
<blockquote>
<p>使用 <code>await VideoDecoder.isConfigSupported(config)</code><br> <span id="more"></span><br>檢查<code>config</code> 是否支援</p>
</blockquote>
<p>H265目前在chrome上只支援硬解，可以參考底下的連結看看硬體是否支援，<br>如果硬體不行也可以下載支援H265軟硬解的 Chromium 試試看<br>附上採坑日常 <a href="/posts/20240123163300-3f5d67a6.html" title="20240123小日常">20240123小日常</a></p>
<h2 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h2><ul>
<li><a href="https://github.com/StaZhu/enable-chromium-hevc-hardware-decoding">enable-chromium-hevc-hardware-decoding</a></li>
<li><a href="https://blog.csdn.net/Dontla/article/details/132752490?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-132752490-blog-135105844.235%5Ev40%5Epc_relevant_anti_vip&spm=1001.2101.3001.4242.2&utm_relevant_index=4">解决chrome浏览器不能播放H265….）DXVA Checker、GPU-Z</a></li>
<li><a href="https://codepen.io/danm8675123/pen/abNavqG">HEVC Video Test</a></li>
<li><a href="https://bluesky-soft.com/en/DXVAChecker.html">DXVAChecker</a></li>
</ul>
<h2 id="將-H265NALU轉換成EncodedVideoChunk"><a href="#將-H265NALU轉換成EncodedVideoChunk" class="headerlink" title="將 H265NALU轉換成EncodedVideoChunk"></a>將 H265NALU轉換成<code>EncodedVideoChunk</code></h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> init = &#123;</span><br><span class="line">  <span class="attr">type</span>: unit.<span class="property">type</span> === <span class="number">19</span> ? <span class="string">&#x27;key&#x27;</span> : <span class="string">&#x27;delta&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: h26XBuffer,</span><br><span class="line">  <span class="attr">timestamp</span>: timestamp,</span><br><span class="line">&#125;;</span><br><span class="line">chunk = <span class="keyword">new</span> <span class="title class_">EncodedVideoChunk</span>(init);</span><br><span class="line">decoder.<span class="title function_">decode</span>(chunk);</span><br></pre></td></tr></table></figure>
<p><code>EncodedVideoChunk</code> 初始化要分辨這一幀是 <code>key</code> 或 <code>delta</code> (使用NALU的unit_type)<br>這裡的不同的是 NALU的 unit_type H264 和 H265 代表的不一樣，算出unit_type的方式也有所不同，<br>大家要非常的小心</p>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>H265 和 H264 使用 WebCodecs 的流程大致上沒有太大的區別，需要注意的是H265對於硬體的要求比較高，當今天硬體不支援時，該如何判斷，該如何處理，還有如何解析出H264 H265 unit_type，這也需要工程師閱讀資料得知了- 可以參考<a href="https://www.twblogs.net/a/5c6d2817bd9eee5c86dcca4a">HEVC&#x2F;H265幀類型判斷及NALU TYPE介紹</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>H265</tag>
        <tag>WebCodecsAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>實作 Nginx 負載平衡 load balance</title>
    <url>/posts/20230417154300-ab2a7258.html</url>
    <content><![CDATA[<h2 id="三種-load-balancing-方法"><a href="#三種-load-balancing-方法" class="headerlink" title="三種 load balancing 方法"></a>三種 load balancing 方法</h2><ol>
<li>round-robin：預設值，會將請留輪流平均分配到每台伺服器上</li>
<li>lest-connected：會將請求分配到目前連接數最少的伺服器上</li>
<li>ip-hash：利用 hash-function 來決定使用者要被分配到的伺服器，此方法可以達到同一個使用者 (IP address) 每次連結的伺服器都是相同的</li>
</ol>
<h2 id="設定不同付載平衡模式"><a href="#設定不同付載平衡模式" class="headerlink" title="設定不同付載平衡模式"></a>設定不同付載平衡模式</h2> <span id="more"></span>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	upstream myapp &#123;</span><br><span class="line">		ip_hash; #付載平衡模式 round-robin(default 不寫), lest_conn , ip-hash</span><br><span class="line">		server srv1.example.com;</span><br><span class="line">		server srv2.example.com;</span><br><span class="line">		server srv3.example.com;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	server &#123;</span><br><span class="line">		listen 80;</span><br><span class="line"></span><br><span class="line">		location / &#123;</span><br><span class="line">			proxy_pass	 http://myapp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Round-robin-分配權重-weight"><a href="#Round-robin-分配權重-weight" class="headerlink" title="Round-robin 分配權重 weight"></a>Round-robin 分配權重 weight</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	upstream myapp &#123;</span><br><span class="line">		server srv1.example.com weight=3;</span><br><span class="line">		server srv2.example.com weight=2;</span><br><span class="line">		server srv3.example.com;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	server &#123;</span><br><span class="line">		listen 80;</span><br><span class="line"></span><br><span class="line">		location / &#123;</span><br><span class="line">			proxy_pass	 http://myapp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="備份-backup-backup-代表，所有伺服器都掛掉之後，此伺服器才會生效"><a href="#備份-backup-backup-代表，所有伺服器都掛掉之後，此伺服器才會生效" class="headerlink" title="備份 backup backup 代表，所有伺服器都掛掉之後，此伺服器才會生效"></a>備份 backup backup 代表，所有伺服器都掛掉之後，此伺服器才會生效</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">	upstream myapp &#123;</span><br><span class="line">		server srv1.example.com weight=3;</span><br><span class="line">		server srv2.example.com backup;</span><br><span class="line">		server srv3.example.com;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	server &#123;</span><br><span class="line">		listen 80;</span><br><span class="line"></span><br><span class="line">		location / &#123;</span><br><span class="line">			proxy_pass	 http://myapp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h1><ul>
<li><a href="maxlist.xyz/2020/06/18/flask-nginx/">maxlist.xyz&#x2F;2020&#x2F;06&#x2F;18&#x2F;flask-nginx&#x2F;</a></li>
</ul>
]]></content>
      <tags>
        <tag>load_balance</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
</search>
